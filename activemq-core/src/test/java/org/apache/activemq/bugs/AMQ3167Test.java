begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|bugs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Destination
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|MessageConsumer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|MessageProducer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Session
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|ActiveMQConnectionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|broker
operator|.
name|BrokerService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|broker
operator|.
name|TransportConnector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|broker
operator|.
name|region
operator|.
name|policy
operator|.
name|PolicyEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|broker
operator|.
name|region
operator|.
name|policy
operator|.
name|PolicyMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQDestination
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_comment
comment|/**  * Test the loss of messages detected during testing with ActiveMQ 5.4.1 and 5.4.2.  *<p/>  * Symptoms:  * - 1 record is lost "early" in the stream.  * - no more records lost.  *<p/>  * Test Configuration:  * - Broker Settings:  * - Destination Policy  * - Occurs with "Destination Policy" using Store Cursor and a memory limit  * - Not reproduced without "Destination Policy" defined  * - Persistence Adapter  * - Memory: Does not occur.  * - KahaDB: Occurs.  * - Messages  * - Occurs with TextMessage and BinaryMessage  * - Persistent messages.  *<p/>  * Notes:  * - Lower memory limits increase the rate of occurrence.  * - Higher memory limits may prevent the problem (probably because memory limits not reached).  * - Producers sending a number of messages before consumers come online increases rate of occurrence.  */
end_comment

begin_class
specifier|public
class|class
name|AMQ3167Test
block|{
specifier|protected
name|BrokerService
name|embeddedBroker
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|int
name|MEMORY_LIMIT
init|=
literal|16
operator|*
literal|1024
decl_stmt|;
specifier|protected
specifier|static
name|boolean
name|Debug_f
init|=
literal|false
decl_stmt|;
specifier|protected
name|long
name|Producer_stop_time
init|=
literal|0
decl_stmt|;
specifier|protected
name|long
name|Consumer_stop_time
init|=
literal|0
decl_stmt|;
specifier|protected
name|long
name|Consumer_startup_delay_ms
init|=
literal|2000
decl_stmt|;
specifier|protected
name|boolean
name|Stop_after_error
init|=
literal|true
decl_stmt|;
specifier|protected
name|Connection
name|JMS_conn
decl_stmt|;
specifier|protected
name|long
name|Num_error
init|=
literal|0
decl_stmt|;
comment|////             ////
comment|////  UTILITIES  ////
comment|////             ////
comment|/**      * Create a new, unsecured, client connection to the test broker using the given username and password.  This      * connection bypasses all security.      *<p/>      * Don't forget to start the connection or no messages will be received by consumers even though producers      * will work fine.      *      * @username name of the JMS user for the connection; may be null.      * @password Password for the JMS user; may be null.      */
specifier|protected
name|Connection
name|createUnsecuredConnection
parameter_list|(
name|String
name|username
parameter_list|,
name|String
name|password
parameter_list|)
throws|throws
name|javax
operator|.
name|jms
operator|.
name|JMSException
block|{
name|ActiveMQConnectionFactory
name|conn_fact
decl_stmt|;
name|conn_fact
operator|=
operator|new
name|ActiveMQConnectionFactory
argument_list|(
name|embeddedBroker
operator|.
name|getVmConnectorURI
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|conn_fact
operator|.
name|createConnection
argument_list|(
name|username
argument_list|,
name|password
argument_list|)
return|;
block|}
comment|////                      ////
comment|////  TEST FUNCTIONALITY  ////
comment|////                      ////
annotation|@
name|Before
specifier|public
name|void
name|testPrep
parameter_list|()
throws|throws
name|Exception
block|{
name|embeddedBroker
operator|=
operator|new
name|BrokerService
argument_list|()
expr_stmt|;
name|configureBroker
argument_list|(
name|embeddedBroker
argument_list|)
expr_stmt|;
name|embeddedBroker
operator|.
name|start
argument_list|()
expr_stmt|;
name|embeddedBroker
operator|.
name|waitUntilStarted
argument_list|()
expr_stmt|;
comment|// Prepare the connection
name|JMS_conn
operator|=
name|createUnsecuredConnection
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|JMS_conn
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
annotation|@
name|After
specifier|public
name|void
name|testCleanup
parameter_list|()
throws|throws
name|java
operator|.
name|lang
operator|.
name|Exception
block|{
name|JMS_conn
operator|.
name|stop
argument_list|()
expr_stmt|;
name|embeddedBroker
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|void
name|configureBroker
parameter_list|(
name|BrokerService
name|broker_svc
parameter_list|)
throws|throws
name|Exception
block|{
name|TransportConnector
name|conn
decl_stmt|;
name|broker_svc
operator|.
name|setBrokerName
argument_list|(
literal|"testbroker1"
argument_list|)
expr_stmt|;
name|broker_svc
operator|.
name|setUseJmx
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|broker_svc
operator|.
name|setPersistent
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|broker_svc
operator|.
name|setDataDirectory
argument_list|(
literal|"target/AMQ3167Test"
argument_list|)
expr_stmt|;
name|configureDestinationPolicy
argument_list|(
name|broker_svc
argument_list|)
expr_stmt|;
block|}
comment|/**      * NOTE: overrides any prior policy map defined for the broker service.      */
specifier|protected
name|void
name|configureDestinationPolicy
parameter_list|(
name|BrokerService
name|broker_svc
parameter_list|)
block|{
name|PolicyMap
name|pol_map
decl_stmt|;
name|PolicyEntry
name|pol_ent
decl_stmt|;
name|ArrayList
argument_list|<
name|PolicyEntry
argument_list|>
name|ent_list
decl_stmt|;
name|ent_list
operator|=
operator|new
name|ArrayList
argument_list|<
name|PolicyEntry
argument_list|>
argument_list|()
expr_stmt|;
comment|//
comment|// QUEUES
comment|//
name|pol_ent
operator|=
operator|new
name|PolicyEntry
argument_list|()
expr_stmt|;
name|pol_ent
operator|.
name|setQueue
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
name|pol_ent
operator|.
name|setMemoryLimit
argument_list|(
name|MEMORY_LIMIT
argument_list|)
expr_stmt|;
name|pol_ent
operator|.
name|setProducerFlowControl
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|ent_list
operator|.
name|add
argument_list|(
name|pol_ent
argument_list|)
expr_stmt|;
comment|//
comment|// COMPLETE POLICY MAP
comment|//
name|pol_map
operator|=
operator|new
name|PolicyMap
argument_list|()
expr_stmt|;
name|pol_map
operator|.
name|setPolicyEntries
argument_list|(
name|ent_list
argument_list|)
expr_stmt|;
name|broker_svc
operator|.
name|setDestinationPolicy
argument_list|(
name|pol_map
argument_list|)
expr_stmt|;
block|}
comment|////        ////
comment|////  TEST  ////
comment|////        ////
annotation|@
name|Test
specifier|public
name|void
name|testQueueLostMessage
parameter_list|()
throws|throws
name|Exception
block|{
name|Destination
name|dest
decl_stmt|;
name|dest
operator|=
name|ActiveMQDestination
operator|.
name|createDestination
argument_list|(
literal|"lostmsgtest.queue"
argument_list|,
name|ActiveMQDestination
operator|.
name|QUEUE_TYPE
argument_list|)
expr_stmt|;
comment|// 10 seconds from now
name|Producer_stop_time
operator|=
name|java
operator|.
name|lang
operator|.
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
operator|(
literal|10L
operator|*
literal|1000000000L
operator|)
expr_stmt|;
comment|// 15 seconds from now
name|Consumer_stop_time
operator|=
name|Producer_stop_time
operator|+
operator|(
literal|5L
operator|*
literal|1000000000L
operator|)
expr_stmt|;
name|runLostMsgTest
argument_list|(
name|dest
argument_list|,
literal|1000000
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Make sure failures in the threads are thoroughly reported in the JUnit framework.
name|assertTrue
argument_list|(
name|Num_error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      *      */
specifier|protected
specifier|static
name|void
name|log
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
if|if
condition|(
name|Debug_f
condition|)
name|java
operator|.
name|lang
operator|.
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/**      * Main body of the lost-message test.      */
specifier|protected
name|void
name|runLostMsgTest
parameter_list|(
name|Destination
name|dest
parameter_list|,
name|int
name|num_msg
parameter_list|,
name|int
name|num_send_per_sess
parameter_list|,
name|int
name|num_recv_per_sess
parameter_list|,
name|boolean
name|topic_f
parameter_list|)
throws|throws
name|Exception
block|{
name|Thread
name|prod_thread
decl_stmt|;
name|Thread
name|cons_thread
decl_stmt|;
name|String
name|tag
decl_stmt|;
name|Session
name|sess
decl_stmt|;
name|MessageProducer
name|prod
decl_stmt|;
name|MessageConsumer
name|cons
decl_stmt|;
name|int
name|ack_mode
decl_stmt|;
comment|//
comment|// Start the producer
comment|//
name|tag
operator|=
literal|"prod"
expr_stmt|;
name|log
argument_list|(
literal|">> Starting producer "
operator|+
name|tag
argument_list|)
expr_stmt|;
name|sess
operator|=
name|JMS_conn
operator|.
name|createSession
argument_list|(
operator|(
name|num_send_per_sess
operator|>
literal|1
operator|)
argument_list|,
name|Session
operator|.
name|AUTO_ACKNOWLEDGE
argument_list|)
expr_stmt|;
name|prod
operator|=
name|sess
operator|.
name|createProducer
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|prod_thread
operator|=
operator|new
name|producerThread
argument_list|(
name|sess
argument_list|,
name|prod
argument_list|,
name|tag
argument_list|,
name|num_msg
argument_list|,
name|num_send_per_sess
argument_list|)
expr_stmt|;
name|prod_thread
operator|.
name|start
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"Started producer "
operator|+
name|tag
argument_list|)
expr_stmt|;
comment|//
comment|// Delay before starting consumers
comment|//
name|log
argument_list|(
literal|"Waiting before starting consumers"
argument_list|)
expr_stmt|;
name|java
operator|.
name|lang
operator|.
name|Thread
operator|.
name|sleep
argument_list|(
name|Consumer_startup_delay_ms
argument_list|)
expr_stmt|;
comment|//
comment|// Now create and start the consumer
comment|//
name|tag
operator|=
literal|"cons"
expr_stmt|;
name|log
argument_list|(
literal|">> Starting consumer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_recv_per_sess
operator|>
literal|1
condition|)
name|ack_mode
operator|=
name|Session
operator|.
name|CLIENT_ACKNOWLEDGE
expr_stmt|;
else|else
name|ack_mode
operator|=
name|Session
operator|.
name|AUTO_ACKNOWLEDGE
expr_stmt|;
name|sess
operator|=
name|JMS_conn
operator|.
name|createSession
argument_list|(
literal|false
argument_list|,
name|ack_mode
argument_list|)
expr_stmt|;
name|cons
operator|=
name|sess
operator|.
name|createConsumer
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cons_thread
operator|=
operator|new
name|consumerThread
argument_list|(
name|sess
argument_list|,
name|cons
argument_list|,
name|tag
argument_list|,
name|num_msg
argument_list|,
name|num_recv_per_sess
argument_list|)
expr_stmt|;
name|cons_thread
operator|.
name|start
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"Started consumer "
operator|+
name|tag
argument_list|)
expr_stmt|;
comment|//
comment|// Wait for the producer and consumer to finish.
comment|//
name|log
argument_list|(
literal|"< waiting for producer."
argument_list|)
expr_stmt|;
name|prod_thread
operator|.
name|join
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"< waiting for consumer."
argument_list|)
expr_stmt|;
name|cons_thread
operator|.
name|join
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"Shutting down"
argument_list|)
expr_stmt|;
block|}
comment|////                    ////
comment|////  INTERNAL CLASSES  ////
comment|////                    ////
comment|/**      * Producer thread - runs a single producer until the maximum number of messages is sent, the producer stop      * time is reached, or a test error is detected.      */
specifier|protected
class|class
name|producerThread
extends|extends
name|Thread
block|{
specifier|protected
name|Session
name|msgSess
decl_stmt|;
specifier|protected
name|MessageProducer
name|msgProd
decl_stmt|;
specifier|protected
name|String
name|producerTag
decl_stmt|;
specifier|protected
name|int
name|numMsg
decl_stmt|;
specifier|protected
name|int
name|numPerSess
decl_stmt|;
specifier|protected
name|long
name|producer_stop_time
decl_stmt|;
name|producerThread
parameter_list|(
name|Session
name|sess
parameter_list|,
name|MessageProducer
name|prod
parameter_list|,
name|String
name|tag
parameter_list|,
name|int
name|num_msg
parameter_list|,
name|int
name|sess_size
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|producer_stop_time
operator|=
literal|0
expr_stmt|;
name|msgSess
operator|=
name|sess
expr_stmt|;
name|msgProd
operator|=
name|prod
expr_stmt|;
name|producerTag
operator|=
name|tag
expr_stmt|;
name|numMsg
operator|=
name|num_msg
expr_stmt|;
name|numPerSess
operator|=
name|sess_size
expr_stmt|;
block|}
specifier|public
name|void
name|execTest
parameter_list|()
throws|throws
name|Exception
block|{
name|Message
name|msg
decl_stmt|;
name|int
name|sess_start
decl_stmt|;
name|int
name|cur
decl_stmt|;
name|sess_start
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|cur
operator|<
name|numMsg
operator|)
operator|&&
operator|(
operator|!
name|didTimeOut
argument_list|()
operator|)
operator|&&
operator|(
operator|(
operator|!
name|Stop_after_error
operator|)
operator|||
operator|(
name|Num_error
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|msg
operator|=
name|msgSess
operator|.
name|createTextMessage
argument_list|(
literal|"test message from "
operator|+
name|producerTag
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setStringProperty
argument_list|(
literal|"testprodtag"
argument_list|,
name|producerTag
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setIntProperty
argument_list|(
literal|"seq"
argument_list|,
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|instanceof
name|ActiveMQMessage
condition|)
block|{
operator|(
operator|(
name|ActiveMQMessage
operator|)
name|msg
operator|)
operator|.
name|setResponseRequired
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Send the message.
comment|//
name|msgProd
operator|.
name|send
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|cur
operator|++
expr_stmt|;
comment|//
comment|// Commit if the number of messages per session has been reached, and
comment|//  transactions are being used (only when> 1 msg per sess).
comment|//
if|if
condition|(
operator|(
name|numPerSess
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|(
name|cur
operator|-
name|sess_start
operator|)
operator|>=
name|numPerSess
operator|)
condition|)
block|{
name|msgSess
operator|.
name|commit
argument_list|()
expr_stmt|;
name|sess_start
operator|=
name|cur
expr_stmt|;
block|}
block|}
comment|// Make sure to send the final commit, if there were sends since the last commit.
if|if
condition|(
operator|(
name|numPerSess
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|(
name|cur
operator|-
name|sess_start
operator|)
operator|>
literal|0
operator|)
condition|)
name|msgSess
operator|.
name|commit
argument_list|()
expr_stmt|;
if|if
condition|(
name|cur
operator|<
name|numMsg
condition|)
name|log
argument_list|(
literal|"* Producer "
operator|+
name|producerTag
operator|+
literal|" timed out at "
operator|+
name|java
operator|.
name|lang
operator|.
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
literal|" (stop time "
operator|+
name|producer_stop_time
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/**          * Check whether it is time for the producer to terminate.          */
specifier|protected
name|boolean
name|didTimeOut
parameter_list|()
block|{
if|if
condition|(
operator|(
name|Producer_stop_time
operator|>
literal|0
operator|)
operator|&&
operator|(
name|java
operator|.
name|lang
operator|.
name|System
operator|.
name|nanoTime
argument_list|()
operator|>=
name|Producer_stop_time
operator|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
comment|/**          * Run the producer.          */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|log
argument_list|(
literal|"- running producer "
operator|+
name|producerTag
argument_list|)
expr_stmt|;
name|execTest
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"- finished running producer "
operator|+
name|producerTag
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|thrown
parameter_list|)
block|{
name|Num_error
operator|++
expr_stmt|;
name|fail
argument_list|(
literal|"producer "
operator|+
name|producerTag
operator|+
literal|" failed: "
operator|+
name|thrown
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|Error
argument_list|(
literal|"producer "
operator|+
name|producerTag
operator|+
literal|" failed"
argument_list|,
name|thrown
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|producerTag
return|;
block|}
block|}
comment|/**      * Producer thread - runs a single consumer until the maximum number of messages is received, the consumer stop      * time is reached, or a test error is detected.      */
specifier|protected
class|class
name|consumerThread
extends|extends
name|Thread
block|{
specifier|protected
name|Session
name|msgSess
decl_stmt|;
specifier|protected
name|MessageConsumer
name|msgCons
decl_stmt|;
specifier|protected
name|String
name|consumerTag
decl_stmt|;
specifier|protected
name|int
name|numMsg
decl_stmt|;
specifier|protected
name|int
name|numPerSess
decl_stmt|;
name|consumerThread
parameter_list|(
name|Session
name|sess
parameter_list|,
name|MessageConsumer
name|cons
parameter_list|,
name|String
name|tag
parameter_list|,
name|int
name|num_msg
parameter_list|,
name|int
name|sess_size
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|msgSess
operator|=
name|sess
expr_stmt|;
name|msgCons
operator|=
name|cons
expr_stmt|;
name|consumerTag
operator|=
name|tag
expr_stmt|;
name|numMsg
operator|=
name|num_msg
expr_stmt|;
name|numPerSess
operator|=
name|sess_size
expr_stmt|;
block|}
specifier|public
name|void
name|execTest
parameter_list|()
throws|throws
name|Exception
block|{
name|Message
name|msg
decl_stmt|;
name|int
name|sess_start
decl_stmt|;
name|int
name|cur
decl_stmt|;
name|msg
operator|=
literal|null
expr_stmt|;
name|sess_start
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|cur
operator|<
name|numMsg
operator|)
operator|&&
operator|(
operator|!
name|didTimeOut
argument_list|()
operator|)
operator|&&
operator|(
operator|(
operator|!
name|Stop_after_error
operator|)
operator|||
operator|(
name|Num_error
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|//
comment|// Use a timeout of 1 second to periodically check the consumer timeout.
comment|//
name|msg
operator|=
name|msgCons
operator|.
name|receive
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|null
condition|)
block|{
name|checkMessage
argument_list|(
name|msg
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|cur
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|numPerSess
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|(
name|cur
operator|-
name|sess_start
operator|)
operator|>=
name|numPerSess
operator|)
condition|)
block|{
name|msg
operator|.
name|acknowledge
argument_list|()
expr_stmt|;
name|sess_start
operator|=
name|cur
expr_stmt|;
block|}
block|}
block|}
comment|// Acknowledge the last messages, if they were not yet acknowledged.
if|if
condition|(
operator|(
name|numPerSess
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|(
name|cur
operator|-
name|sess_start
operator|)
operator|>
literal|0
operator|)
condition|)
name|msg
operator|.
name|acknowledge
argument_list|()
expr_stmt|;
if|if
condition|(
name|cur
operator|<
name|numMsg
condition|)
name|log
argument_list|(
literal|"* Consumer "
operator|+
name|consumerTag
operator|+
literal|" timed out"
argument_list|)
expr_stmt|;
block|}
comment|/**          * Check whether it is time for the consumer to terminate.          */
specifier|protected
name|boolean
name|didTimeOut
parameter_list|()
block|{
if|if
condition|(
operator|(
name|Consumer_stop_time
operator|>
literal|0
operator|)
operator|&&
operator|(
name|java
operator|.
name|lang
operator|.
name|System
operator|.
name|nanoTime
argument_list|()
operator|>=
name|Consumer_stop_time
operator|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
comment|/**          * Verify the message received.  Sequence numbers are checked and are expected to exactly match the          * message number (starting at 0).          */
specifier|protected
name|void
name|checkMessage
parameter_list|(
name|Message
name|msg
parameter_list|,
name|int
name|exp_seq
parameter_list|)
throws|throws
name|javax
operator|.
name|jms
operator|.
name|JMSException
block|{
name|int
name|seq
decl_stmt|;
name|seq
operator|=
name|msg
operator|.
name|getIntProperty
argument_list|(
literal|"seq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp_seq
operator|!=
name|seq
condition|)
block|{
name|Num_error
operator|++
expr_stmt|;
name|fail
argument_list|(
literal|"*** Consumer "
operator|+
name|consumerTag
operator|+
literal|" expected seq "
operator|+
name|exp_seq
operator|+
literal|"; received "
operator|+
name|seq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Run the consumer.          */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|log
argument_list|(
literal|"- running consumer "
operator|+
name|consumerTag
argument_list|)
expr_stmt|;
name|execTest
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"- running consumer "
operator|+
name|consumerTag
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|thrown
parameter_list|)
block|{
name|Num_error
operator|++
expr_stmt|;
name|fail
argument_list|(
literal|"consumer "
operator|+
name|consumerTag
operator|+
literal|" failed: "
operator|+
name|thrown
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|Error
argument_list|(
literal|"consumer "
operator|+
name|consumerTag
operator|+
literal|" failed"
argument_list|,
name|thrown
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|consumerTag
return|;
block|}
block|}
block|}
end_class

end_unit

