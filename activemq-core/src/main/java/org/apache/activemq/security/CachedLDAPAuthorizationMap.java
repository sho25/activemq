begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|security
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQDestination
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQTopic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|filter
operator|.
name|DestinationMapEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|jaas
operator|.
name|GroupPrincipal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|jaas
operator|.
name|UserPrincipal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|beans
operator|.
name|factory
operator|.
name|DisposableBean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|springframework
operator|.
name|beans
operator|.
name|factory
operator|.
name|InitializingBean
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|Binding
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|InvalidNameException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|NamingEnumeration
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|NamingException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|directory
operator|.
name|*
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|event
operator|.
name|*
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|ldap
operator|.
name|LdapName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|ldap
operator|.
name|Rdn
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * A {@link DefaultAuthorizationMap} implementation which uses LDAP to initialize and update authorization  * policy.  *  * @org.apache.xbean.XBean  */
end_comment

begin_class
specifier|public
class|class
name|CachedLDAPAuthorizationMap
extends|extends
name|DefaultAuthorizationMap
implements|implements
name|InitializingBean
implements|,
name|DisposableBean
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CachedLDAPAuthorizationMap
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Configuration Options
specifier|private
name|String
name|initialContextFactory
init|=
literal|"com.sun.jndi.ldap.LdapCtxFactory"
decl_stmt|;
specifier|private
name|String
name|connectionURL
init|=
literal|"ldap://localhost:1024"
decl_stmt|;
specifier|private
name|String
name|connectionUsername
init|=
literal|"uid=admin,ou=system"
decl_stmt|;
specifier|private
name|String
name|connectionPassword
init|=
literal|"secret"
decl_stmt|;
specifier|private
name|String
name|connectionProtocol
init|=
literal|"s"
decl_stmt|;
specifier|private
name|String
name|authentication
init|=
literal|"simple"
decl_stmt|;
specifier|private
name|int
name|queuePrefixLength
init|=
literal|4
decl_stmt|;
specifier|private
name|int
name|topicPrefixLength
init|=
literal|4
decl_stmt|;
specifier|private
name|int
name|tempPrefixLength
init|=
literal|4
decl_stmt|;
specifier|private
name|String
name|queueSearchBase
init|=
literal|"ou=Queue,ou=Destination,ou=ActiveMQ,ou=system"
decl_stmt|;
specifier|private
name|String
name|topicSearchBase
init|=
literal|"ou=Topic,ou=Destination,ou=ActiveMQ,ou=system"
decl_stmt|;
specifier|private
name|String
name|tempSearchBase
init|=
literal|"ou=Temp,ou=Destination,ou=ActiveMQ,ou=system"
decl_stmt|;
specifier|private
name|String
name|permissionGroupMemberAttribute
init|=
literal|"member"
decl_stmt|;
specifier|private
name|String
name|adminPermissionGroupSearchFilter
init|=
literal|"(cn=Admin)"
decl_stmt|;
specifier|private
name|String
name|readPermissionGroupSearchFilter
init|=
literal|"(cn=Read)"
decl_stmt|;
specifier|private
name|String
name|writePermissionGroupSearchFilter
init|=
literal|"(cn=Write)"
decl_stmt|;
specifier|private
name|boolean
name|legacyGroupMapping
init|=
literal|true
decl_stmt|;
specifier|private
name|String
name|groupObjectClass
init|=
literal|"groupOfNames"
decl_stmt|;
specifier|private
name|String
name|userObjectClass
init|=
literal|"person"
decl_stmt|;
specifier|private
name|String
name|groupNameAttribute
init|=
literal|"cn"
decl_stmt|;
specifier|private
name|String
name|userNameAttribute
init|=
literal|"uid"
decl_stmt|;
specifier|private
name|int
name|refreshInterval
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|boolean
name|refreshDisabled
init|=
literal|false
decl_stmt|;
comment|// Internal State
specifier|private
name|long
name|lastUpdated
decl_stmt|;
specifier|private
specifier|static
name|String
name|ANY_DESCENDANT
init|=
literal|"\\$"
decl_stmt|;
specifier|private
name|DirContext
name|context
decl_stmt|;
specifier|private
name|EventDirContext
name|eventContext
decl_stmt|;
specifier|protected
name|HashMap
argument_list|<
name|ActiveMQDestination
argument_list|,
name|AuthorizationEntry
argument_list|>
name|entries
init|=
operator|new
name|HashMap
argument_list|<
name|ActiveMQDestination
argument_list|,
name|AuthorizationEntry
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Returns the existing open context or creates a new one and registers listeners for      * push notifications if such an update style is enabled.  This implementation should not      * be invoked concurrently.      *      * @return the current context      *      * @throws NamingException if there is an error setting things up      */
specifier|protected
name|DirContext
name|open
parameter_list|()
throws|throws
name|NamingException
block|{
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
return|return
name|context
return|;
block|}
try|try
block|{
name|Hashtable
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
operator|new
name|Hashtable
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|env
operator|.
name|put
argument_list|(
name|Context
operator|.
name|INITIAL_CONTEXT_FACTORY
argument_list|,
name|initialContextFactory
argument_list|)
expr_stmt|;
if|if
condition|(
name|connectionUsername
operator|!=
literal|null
operator|||
operator|!
literal|""
operator|.
name|equals
argument_list|(
name|connectionUsername
argument_list|)
condition|)
block|{
name|env
operator|.
name|put
argument_list|(
name|Context
operator|.
name|SECURITY_PRINCIPAL
argument_list|,
name|connectionUsername
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|connectionPassword
operator|!=
literal|null
operator|||
operator|!
literal|""
operator|.
name|equals
argument_list|(
name|connectionPassword
argument_list|)
condition|)
block|{
name|env
operator|.
name|put
argument_list|(
name|Context
operator|.
name|SECURITY_CREDENTIALS
argument_list|,
name|connectionPassword
argument_list|)
expr_stmt|;
block|}
name|env
operator|.
name|put
argument_list|(
name|Context
operator|.
name|SECURITY_PROTOCOL
argument_list|,
name|connectionProtocol
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|Context
operator|.
name|PROVIDER_URL
argument_list|,
name|connectionURL
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|Context
operator|.
name|SECURITY_AUTHENTICATION
argument_list|,
name|authentication
argument_list|)
expr_stmt|;
name|context
operator|=
operator|new
name|InitialDirContext
argument_list|(
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|refreshInterval
operator|==
operator|-
literal|1
operator|&&
operator|!
name|refreshDisabled
condition|)
block|{
name|eventContext
operator|=
operator|(
operator|(
name|EventDirContext
operator|)
name|context
operator|.
name|lookup
argument_list|(
literal|""
argument_list|)
operator|)
expr_stmt|;
specifier|final
name|SearchControls
name|constraints
init|=
operator|new
name|SearchControls
argument_list|()
decl_stmt|;
name|constraints
operator|.
name|setSearchScope
argument_list|(
name|SearchControls
operator|.
name|SUBTREE_SCOPE
argument_list|)
expr_stmt|;
comment|// Listeners for Queue policy //
comment|// Listeners for each type of permission
for|for
control|(
name|PermissionType
name|permissionType
range|:
name|PermissionType
operator|.
name|values
argument_list|()
control|)
block|{
name|eventContext
operator|.
name|addNamingListener
argument_list|(
name|queueSearchBase
argument_list|,
name|getFilterForPermissionType
argument_list|(
name|permissionType
argument_list|)
argument_list|,
name|constraints
argument_list|,
name|this
operator|.
expr|new
name|CachedLDAPAuthorizationMapNamespaceChangeListener
argument_list|(
name|DestinationType
operator|.
name|QUEUE
argument_list|,
name|permissionType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Listener for changes to the destination pattern entry itself and not a permission entry.
name|eventContext
operator|.
name|addNamingListener
argument_list|(
name|queueSearchBase
argument_list|,
literal|"cn=*"
argument_list|,
operator|new
name|SearchControls
argument_list|()
argument_list|,
name|this
operator|.
expr|new
name|CachedLDAPAuthorizationMapNamespaceChangeListener
argument_list|(
name|DestinationType
operator|.
name|QUEUE
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// Listeners for Topic policy //
comment|// Listeners for each type of permission
for|for
control|(
name|PermissionType
name|permissionType
range|:
name|PermissionType
operator|.
name|values
argument_list|()
control|)
block|{
name|eventContext
operator|.
name|addNamingListener
argument_list|(
name|topicSearchBase
argument_list|,
name|getFilterForPermissionType
argument_list|(
name|permissionType
argument_list|)
argument_list|,
name|constraints
argument_list|,
name|this
operator|.
expr|new
name|CachedLDAPAuthorizationMapNamespaceChangeListener
argument_list|(
name|DestinationType
operator|.
name|TOPIC
argument_list|,
name|permissionType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Listener for changes to the destination pattern entry itself and not a permission entry.
name|eventContext
operator|.
name|addNamingListener
argument_list|(
name|topicSearchBase
argument_list|,
literal|"cn=*"
argument_list|,
operator|new
name|SearchControls
argument_list|()
argument_list|,
name|this
operator|.
expr|new
name|CachedLDAPAuthorizationMapNamespaceChangeListener
argument_list|(
name|DestinationType
operator|.
name|TOPIC
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// Listeners for Temp policy //
comment|// Listeners for each type of permission
for|for
control|(
name|PermissionType
name|permissionType
range|:
name|PermissionType
operator|.
name|values
argument_list|()
control|)
block|{
name|eventContext
operator|.
name|addNamingListener
argument_list|(
name|tempSearchBase
argument_list|,
name|getFilterForPermissionType
argument_list|(
name|permissionType
argument_list|)
argument_list|,
name|constraints
argument_list|,
name|this
operator|.
expr|new
name|CachedLDAPAuthorizationMapNamespaceChangeListener
argument_list|(
name|DestinationType
operator|.
name|TEMP
argument_list|,
name|permissionType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NamingException
name|e
parameter_list|)
block|{
name|context
operator|=
literal|null
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
name|context
return|;
block|}
comment|/**      * Queries the directory and initializes the policy based on the data in the directory.      * This implementation should not be invoked concurrently.      *       * @throws Exception if there is an unrecoverable error processing the directory contents      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|protected
name|void
name|query
parameter_list|()
throws|throws
name|Exception
block|{
name|DirContext
name|currentContext
init|=
name|open
argument_list|()
decl_stmt|;
specifier|final
name|SearchControls
name|constraints
init|=
operator|new
name|SearchControls
argument_list|()
decl_stmt|;
name|constraints
operator|.
name|setSearchScope
argument_list|(
name|SearchControls
operator|.
name|SUBTREE_SCOPE
argument_list|)
expr_stmt|;
for|for
control|(
name|PermissionType
name|permissionType
range|:
name|PermissionType
operator|.
name|values
argument_list|()
control|)
block|{
try|try
block|{
name|processQueryResults
argument_list|(
name|currentContext
operator|.
name|search
argument_list|(
name|queueSearchBase
argument_list|,
name|getFilterForPermissionType
argument_list|(
name|permissionType
argument_list|)
argument_list|,
name|constraints
argument_list|)
argument_list|,
name|DestinationType
operator|.
name|QUEUE
argument_list|,
name|permissionType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied!.  Error processing policy under '"
operator|+
name|queueSearchBase
operator|+
literal|"' with filter '"
operator|+
name|getFilterForPermissionType
argument_list|(
name|permissionType
argument_list|)
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|PermissionType
name|permissionType
range|:
name|PermissionType
operator|.
name|values
argument_list|()
control|)
block|{
try|try
block|{
name|processQueryResults
argument_list|(
name|currentContext
operator|.
name|search
argument_list|(
name|topicSearchBase
argument_list|,
name|getFilterForPermissionType
argument_list|(
name|permissionType
argument_list|)
argument_list|,
name|constraints
argument_list|)
argument_list|,
name|DestinationType
operator|.
name|TOPIC
argument_list|,
name|permissionType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied!.  Error processing policy under '"
operator|+
name|topicSearchBase
operator|+
literal|"' with filter '"
operator|+
name|getFilterForPermissionType
argument_list|(
name|permissionType
argument_list|)
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|PermissionType
name|permissionType
range|:
name|PermissionType
operator|.
name|values
argument_list|()
control|)
block|{
try|try
block|{
name|processQueryResults
argument_list|(
name|currentContext
operator|.
name|search
argument_list|(
name|tempSearchBase
argument_list|,
name|getFilterForPermissionType
argument_list|(
name|permissionType
argument_list|)
argument_list|,
name|constraints
argument_list|)
argument_list|,
name|DestinationType
operator|.
name|TEMP
argument_list|,
name|permissionType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied!.  Error processing policy under '"
operator|+
name|tempSearchBase
operator|+
literal|"' with filter '"
operator|+
name|getFilterForPermissionType
argument_list|(
name|permissionType
argument_list|)
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|setEntries
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|DestinationMapEntry
argument_list|>
argument_list|(
name|entries
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|updated
argument_list|()
expr_stmt|;
block|}
comment|/**      * Processes results from a directory query in the context of a given destination type and permission type.      * This implementation should not be invoked concurrently.      *      * @param results the results to process      * @param destinationType the type of the destination for which the directory results apply      * @param permissionType the type of the permission for which the directory results apply      *      * @throws Exception if there is an error processing the results      */
specifier|protected
name|void
name|processQueryResults
parameter_list|(
name|NamingEnumeration
argument_list|<
name|SearchResult
argument_list|>
name|results
parameter_list|,
name|DestinationType
name|destinationType
parameter_list|,
name|PermissionType
name|permissionType
parameter_list|)
throws|throws
name|Exception
block|{
while|while
condition|(
name|results
operator|.
name|hasMore
argument_list|()
condition|)
block|{
name|SearchResult
name|result
init|=
name|results
operator|.
name|next
argument_list|()
decl_stmt|;
name|AuthorizationEntry
name|entry
init|=
literal|null
decl_stmt|;
try|try
block|{
name|entry
operator|=
name|getEntry
argument_list|(
operator|new
name|LdapName
argument_list|(
name|result
operator|.
name|getNameInNamespace
argument_list|()
argument_list|)
argument_list|,
name|destinationType
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied!  Error parsing authorization policy entry under "
operator|+
name|result
operator|.
name|getNameInNamespace
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|applyACL
argument_list|(
name|entry
argument_list|,
name|result
argument_list|,
name|permissionType
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Marks the time at which the authorization state was last refreshed.  Relevant for synchronous policy updates.      * This implementation should not be invoked concurrently.      */
specifier|protected
name|void
name|updated
parameter_list|()
block|{
name|lastUpdated
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
comment|/**      * Retrieves or creates the {@link AuthorizationEntry} that corresponds to      * the DN in {@code dn}.  This implementation should not be invoked concurrently.      *       * @param dn      *            the DN representing the policy entry in the directory      * @param destinationType the type of the destination to get/create the entry for      *       * @return the corresponding authorization entry for the DN      *       * @throws IllegalArgumentException      *             if destination type is not one of {@link DestinationType#QUEUE}, {@link DestinationType#TOPIC},      *             {@link DestinationType#TEMP} or if the policy entry DN is malformed      */
specifier|protected
name|AuthorizationEntry
name|getEntry
parameter_list|(
name|LdapName
name|dn
parameter_list|,
name|DestinationType
name|destinationType
parameter_list|)
block|{
name|AuthorizationEntry
name|entry
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|destinationType
condition|)
block|{
case|case
name|TEMP
case|:
comment|// handle temp entry
if|if
condition|(
name|dn
operator|.
name|size
argument_list|()
operator|!=
name|getPrefixLengthForDestinationType
argument_list|(
name|destinationType
argument_list|)
operator|+
literal|1
condition|)
block|{
comment|// handle unknown entry
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Malformed policy structure for a temporary destination "
operator|+
literal|"policy entry.  The permission group entries should be immediately below the "
operator|+
literal|"temporary policy base DN."
argument_list|)
throw|;
block|}
name|entry
operator|=
name|getTempDestinationAuthorizationEntry
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
name|entry
operator|=
operator|new
name|TempDestinationAuthorizationEntry
argument_list|()
expr_stmt|;
name|setTempDestinationAuthorizationEntry
argument_list|(
operator|(
name|TempDestinationAuthorizationEntry
operator|)
name|entry
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QUEUE
case|:
case|case
name|TOPIC
case|:
comment|// handle regular destinations
if|if
condition|(
name|dn
operator|.
name|size
argument_list|()
operator|!=
name|getPrefixLengthForDestinationType
argument_list|(
name|destinationType
argument_list|)
operator|+
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Malformed policy structure for a queue or topic destination "
operator|+
literal|"policy entry.  The destination pattern and permission group entries should be "
operator|+
literal|"nested below the queue or topic policy base DN."
argument_list|)
throw|;
block|}
name|ActiveMQDestination
name|dest
init|=
name|formatDestination
argument_list|(
name|dn
argument_list|,
name|destinationType
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|!=
literal|null
condition|)
block|{
name|entry
operator|=
name|entries
operator|.
name|get
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
name|entry
operator|=
operator|new
name|AuthorizationEntry
argument_list|()
expr_stmt|;
name|entry
operator|.
name|setDestination
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|entries
operator|.
name|put
argument_list|(
name|dest
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|// handle unknown entry
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown destination type "
operator|+
name|destinationType
argument_list|)
throw|;
block|}
return|return
name|entry
return|;
block|}
comment|/**      * Applies the policy from the directory to the given entry within the context of the provided      * permission type.      *      * @param entry the policy entry to apply the policy to      * @param result the results from the directory to apply to the policy entry      * @param permissionType the permission type of the data in the directory      *      * @throws NamingException if there is an error applying the ACL      */
specifier|protected
name|void
name|applyACL
parameter_list|(
name|AuthorizationEntry
name|entry
parameter_list|,
name|SearchResult
name|result
parameter_list|,
name|PermissionType
name|permissionType
parameter_list|)
throws|throws
name|NamingException
block|{
comment|// Find members
name|Attribute
name|memberAttribute
init|=
name|result
operator|.
name|getAttributes
argument_list|()
operator|.
name|get
argument_list|(
name|permissionGroupMemberAttribute
argument_list|)
decl_stmt|;
name|NamingEnumeration
argument_list|<
name|?
argument_list|>
name|memberAttributeEnum
init|=
name|memberAttribute
operator|.
name|getAll
argument_list|()
decl_stmt|;
name|HashSet
argument_list|<
name|Object
argument_list|>
name|members
init|=
operator|new
name|HashSet
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|memberAttributeEnum
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|String
name|memberDn
init|=
operator|(
name|String
operator|)
name|memberAttributeEnum
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|boolean
name|group
init|=
literal|false
decl_stmt|;
name|boolean
name|user
init|=
literal|false
decl_stmt|;
name|String
name|principalName
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|legacyGroupMapping
condition|)
block|{
comment|// Lookup of member to determine principal type (group or user) and name.
name|Attributes
name|memberAttributes
decl_stmt|;
try|try
block|{
name|memberAttributes
operator|=
name|context
operator|.
name|getAttributes
argument_list|(
name|memberDn
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"objectClass"
block|,
name|groupNameAttribute
block|,
name|userNameAttribute
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NamingException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied! Unknown member "
operator|+
name|memberDn
operator|+
literal|" in policy entry "
operator|+
name|result
operator|.
name|getNameInNamespace
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Attribute
name|memberEntryObjectClassAttribute
init|=
name|memberAttributes
operator|.
name|get
argument_list|(
literal|"objectClass"
argument_list|)
decl_stmt|;
name|NamingEnumeration
argument_list|<
name|?
argument_list|>
name|memberEntryObjectClassAttributeEnum
init|=
name|memberEntryObjectClassAttribute
operator|.
name|getAll
argument_list|()
decl_stmt|;
while|while
condition|(
name|memberEntryObjectClassAttributeEnum
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|String
name|objectClass
init|=
operator|(
name|String
operator|)
name|memberEntryObjectClassAttributeEnum
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|objectClass
operator|.
name|equalsIgnoreCase
argument_list|(
name|groupObjectClass
argument_list|)
condition|)
block|{
name|group
operator|=
literal|true
expr_stmt|;
name|Attribute
name|name
init|=
name|memberAttributes
operator|.
name|get
argument_list|(
name|groupNameAttribute
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied! Group "
operator|+
name|memberDn
operator|+
literal|"does not have name attribute "
operator|+
name|groupNameAttribute
operator|+
literal|" under entry "
operator|+
name|result
operator|.
name|getNameInNamespace
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|principalName
operator|=
operator|(
name|String
operator|)
name|name
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|objectClass
operator|.
name|equalsIgnoreCase
argument_list|(
name|userObjectClass
argument_list|)
condition|)
block|{
name|user
operator|=
literal|true
expr_stmt|;
name|Attribute
name|name
init|=
name|memberAttributes
operator|.
name|get
argument_list|(
name|userNameAttribute
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied! User "
operator|+
name|memberDn
operator|+
literal|" does not have name attribute "
operator|+
name|userNameAttribute
operator|+
literal|" under entry "
operator|+
name|result
operator|.
name|getNameInNamespace
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|principalName
operator|=
operator|(
name|String
operator|)
name|name
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|group
operator|=
literal|true
expr_stmt|;
name|principalName
operator|=
name|memberDn
operator|.
name|replaceAll
argument_list|(
literal|"(cn|CN)="
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|group
operator|&&
operator|!
name|user
operator|)
operator|||
operator|(
name|group
operator|&&
name|user
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied! Can't determine type of member "
operator|+
name|memberDn
operator|+
literal|" under entry "
operator|+
name|result
operator|.
name|getNameInNamespace
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|principalName
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|group
operator|&&
operator|!
name|user
condition|)
block|{
name|members
operator|.
name|add
argument_list|(
operator|new
name|GroupPrincipal
argument_list|(
name|principalName
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|group
operator|&&
name|user
condition|)
block|{
name|members
operator|.
name|add
argument_list|(
operator|new
name|UserPrincipal
argument_list|(
name|principalName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
try|try
block|{
name|applyAcl
argument_list|(
name|entry
argument_list|,
name|permissionType
argument_list|,
name|members
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied! Error adding principals to ACL under "
operator|+
name|result
operator|.
name|getNameInNamespace
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Applies policy to the entry given the actual principals that will be applied to the policy entry.      *      * @param entry the policy entry to which the policy should be applied      * @param permissionType the type of the permission that the policy will be applied to      * @param acls the principals that represent the actual policy      *      * @throw IllegalArgumentException if {@code permissionType} is unsupported      */
specifier|protected
name|void
name|applyAcl
parameter_list|(
name|AuthorizationEntry
name|entry
parameter_list|,
name|PermissionType
name|permissionType
parameter_list|,
name|Set
argument_list|<
name|Object
argument_list|>
name|acls
parameter_list|)
block|{
switch|switch
condition|(
name|permissionType
condition|)
block|{
case|case
name|READ
case|:
name|entry
operator|.
name|setReadACLs
argument_list|(
name|acls
argument_list|)
expr_stmt|;
break|break;
case|case
name|WRITE
case|:
name|entry
operator|.
name|setWriteACLs
argument_list|(
name|acls
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADMIN
case|:
name|entry
operator|.
name|setAdminACLs
argument_list|(
name|acls
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown permission "
operator|+
name|permissionType
operator|+
literal|"."
argument_list|)
throw|;
block|}
block|}
comment|/**      * Parses a DN into the equivalent {@link ActiveMQDestination}.  The default implementation      * expects a format of cn=<PERMISSION_NAME>,ou=<DESTINATION_PATTERN>,.... or       * ou=<DESTINATION_PATTERN>,.... for permission and destination entries, respectively.      * For example {@code cn=admin,ou=$,ou=...} or {@code ou=$,ou=...}.       *      * @param dn the DN to parse      * @param destinationType the type of the destination that we are parsing      *      * @return the destination that the DN represents      *      * @throws IllegalArgumentException if {@code destinationType} is {@link DestinationType#TEMP} or      * if the format of {@code dn} is incorrect for for a topic or queue      *      * @see #formatDestination(Rdn, DestinationType)      */
specifier|protected
name|ActiveMQDestination
name|formatDestination
parameter_list|(
name|LdapName
name|dn
parameter_list|,
name|DestinationType
name|destinationType
parameter_list|)
block|{
name|ActiveMQDestination
name|destination
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|destinationType
condition|)
block|{
case|case
name|QUEUE
case|:
case|case
name|TOPIC
case|:
comment|// There exists a need to deal with both names representing a permission or simply a
comment|// destination.  As such, we need to determine the proper RDN to work with based
comment|// on the destination type and the DN size.
if|if
condition|(
name|dn
operator|.
name|size
argument_list|()
operator|==
operator|(
name|getPrefixLengthForDestinationType
argument_list|(
name|destinationType
argument_list|)
operator|+
literal|2
operator|)
condition|)
block|{
name|destination
operator|=
name|formatDestination
argument_list|(
name|dn
operator|.
name|getRdn
argument_list|(
name|dn
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
argument_list|,
name|destinationType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn
operator|.
name|size
argument_list|()
operator|==
operator|(
name|getPrefixLengthForDestinationType
argument_list|(
name|destinationType
argument_list|)
operator|+
literal|1
operator|)
condition|)
block|{
name|destination
operator|=
name|formatDestination
argument_list|(
name|dn
operator|.
name|getRdn
argument_list|(
name|dn
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|,
name|destinationType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Malformed DN for representing a permission or destination entry."
argument_list|)
throw|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot format destination for destination type "
operator|+
name|destinationType
argument_list|)
throw|;
block|}
return|return
name|destination
return|;
block|}
comment|/**      * Parses RDN values representing the destination name/pattern and      * destination type into the equivalent {@link ActiveMQDestination}.      *       * @param destinationName      *            the RDN representing the name or pattern for the destination      * @param destinationType      *            the type of the destination      *       * @return the destination that the RDN represent      *       * @throws IllegalArgumentException      *             if {@code destinationType} is not one of {@link DestinationType#TOPIC} or      *             {@link DestinationType#QUEUE}.      *       * @see #formatDestinationName(Rdn)      * @see #formatDestination(LdapName, DestinationType)      */
specifier|protected
name|ActiveMQDestination
name|formatDestination
parameter_list|(
name|Rdn
name|destinationName
parameter_list|,
name|DestinationType
name|destinationType
parameter_list|)
block|{
name|ActiveMQDestination
name|dest
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|destinationType
condition|)
block|{
case|case
name|QUEUE
case|:
name|dest
operator|=
operator|new
name|ActiveMQQueue
argument_list|(
name|formatDestinationName
argument_list|(
name|destinationName
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOPIC
case|:
name|dest
operator|=
operator|new
name|ActiveMQTopic
argument_list|(
name|formatDestinationName
argument_list|(
name|destinationName
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown destination type: "
operator|+
name|destinationType
argument_list|)
throw|;
block|}
return|return
name|dest
return|;
block|}
comment|/**      * Parses the RDN representing a destination name/pattern into the standard string representation      * of the name/pattern.  This implementation does not care about the type of the RDN such that the RDN could      * be a CN or OU.      *      * @param destinationName the RDN representing the name or pattern for the destination      *      * @see #formatDestination(Rdn, Rdn)      */
specifier|protected
name|String
name|formatDestinationName
parameter_list|(
name|Rdn
name|destinationName
parameter_list|)
block|{
return|return
name|destinationName
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|replaceAll
argument_list|(
name|ANY_DESCENDANT
argument_list|,
literal|">"
argument_list|)
return|;
block|}
comment|/**      * Transcribes an existing set into a new set. Used to make defensive copies      * for concurrent access.      *       * @param source      *            the source set or {@code null}      *       * @return a new set containing the same elements as {@code source} or      *         {@code null} if {@code source} is {@code null}      */
specifier|protected
parameter_list|<
name|T
parameter_list|>
name|Set
argument_list|<
name|T
argument_list|>
name|transcribeSet
parameter_list|(
name|Set
argument_list|<
name|T
argument_list|>
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|T
argument_list|>
argument_list|(
name|source
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Returns the filter string for the given permission type.      *       * @throws IllegalArgumentException if {@code permissionType} is not supported      *      * @see #setAdminPermissionGroupSearchFilter(String)      * @see #setReadPermissionGroupSearchFilter(String)      * @see #setWritePermissionGroupSearchFilter(String)      */
specifier|protected
name|String
name|getFilterForPermissionType
parameter_list|(
name|PermissionType
name|permissionType
parameter_list|)
block|{
name|String
name|filter
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|permissionType
condition|)
block|{
case|case
name|ADMIN
case|:
name|filter
operator|=
name|adminPermissionGroupSearchFilter
expr_stmt|;
break|break;
case|case
name|READ
case|:
name|filter
operator|=
name|readPermissionGroupSearchFilter
expr_stmt|;
break|break;
case|case
name|WRITE
case|:
name|filter
operator|=
name|writePermissionGroupSearchFilter
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown permission type "
operator|+
name|permissionType
argument_list|)
throw|;
block|}
return|return
name|filter
return|;
block|}
comment|/**      * Returns the DN prefix size based on the given destination type.      *      * @throws IllegalArgumentException if {@code destinationType} is not supported      *      * @see #setQueueSearchBase(String)      * @see #setTopicSearchBase(String)      * @see #setTempSearchBase(String)      */
specifier|protected
name|int
name|getPrefixLengthForDestinationType
parameter_list|(
name|DestinationType
name|destinationType
parameter_list|)
block|{
name|int
name|filter
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|destinationType
condition|)
block|{
case|case
name|QUEUE
case|:
name|filter
operator|=
name|queuePrefixLength
expr_stmt|;
break|break;
case|case
name|TOPIC
case|:
name|filter
operator|=
name|topicPrefixLength
expr_stmt|;
break|break;
case|case
name|TEMP
case|:
name|filter
operator|=
name|tempPrefixLength
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown permission type "
operator|+
name|destinationType
argument_list|)
throw|;
block|}
return|return
name|filter
return|;
block|}
comment|/**      * Performs a check for updates from the server in the event that synchronous updates are enabled       * and are the refresh interval has elapsed.      */
specifier|protected
name|void
name|checkForUpdates
parameter_list|()
block|{
if|if
condition|(
operator|!
name|refreshDisabled
operator|&&
operator|(
name|refreshInterval
operator|!=
operator|-
literal|1
operator|&&
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|>=
name|lastUpdated
operator|+
name|refreshInterval
operator|)
condition|)
block|{
name|reset
argument_list|()
expr_stmt|;
name|setTempDestinationAuthorizationEntry
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|entries
operator|.
name|clear
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updating authorization map!"
argument_list|)
expr_stmt|;
try|try
block|{
name|query
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error updating authorization map.  Partial policy "
operator|+
literal|"may be applied until the next successful update."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Authorization Map
comment|/**      * Provides synchronous refresh capabilities if so configured before delegating to the super implementation,      * and otherwise simply delegates to the super implementation.      */
annotation|@
name|Override
specifier|protected
specifier|synchronized
name|Set
argument_list|<
name|AuthorizationEntry
argument_list|>
name|getAllEntries
parameter_list|(
name|ActiveMQDestination
name|destination
parameter_list|)
block|{
name|checkForUpdates
argument_list|()
expr_stmt|;
return|return
name|super
operator|.
name|getAllEntries
argument_list|(
name|destination
argument_list|)
return|;
block|}
comment|/**      * Provides synchronized and defensive access to the admin ACLs for temp destinations as the super      * implementation returns live copies of the ACLs and {@link AuthorizationEntry} is not      * setup for concurrent access.      */
annotation|@
name|Override
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|Object
argument_list|>
name|getTempDestinationAdminACLs
parameter_list|()
block|{
name|checkForUpdates
argument_list|()
expr_stmt|;
return|return
name|transcribeSet
argument_list|(
name|super
operator|.
name|getTempDestinationAdminACLs
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Provides synchronized and defensive access to the read ACLs for temp destinations as the super      * implementation returns live copies of the ACLs and {@link AuthorizationEntry} is not      * setup for concurrent access.      */
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|Object
argument_list|>
name|getTempDestinationReadACLs
parameter_list|()
block|{
name|checkForUpdates
argument_list|()
expr_stmt|;
return|return
name|transcribeSet
argument_list|(
name|super
operator|.
name|getTempDestinationReadACLs
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Provides synchronized and defensive access to the write ACLs for temp destinations as the super      * implementation returns live copies of the ACLs and {@link AuthorizationEntry} is not      * setup for concurrent access.      */
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|Object
argument_list|>
name|getTempDestinationWriteACLs
parameter_list|()
block|{
name|checkForUpdates
argument_list|()
expr_stmt|;
return|return
name|transcribeSet
argument_list|(
name|super
operator|.
name|getTempDestinationWriteACLs
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Provides synchronized access to the admin ACLs for the destinations as       * {@link AuthorizationEntry} is not setup for concurrent access.      */
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|Object
argument_list|>
name|getAdminACLs
parameter_list|(
name|ActiveMQDestination
name|destination
parameter_list|)
block|{
return|return
name|super
operator|.
name|getAdminACLs
argument_list|(
name|destination
argument_list|)
return|;
block|}
comment|/**      * Provides synchronized access to the read ACLs for the destinations as       * {@link AuthorizationEntry} is not setup for concurrent access.      */
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|Object
argument_list|>
name|getReadACLs
parameter_list|(
name|ActiveMQDestination
name|destination
parameter_list|)
block|{
return|return
name|super
operator|.
name|getReadACLs
argument_list|(
name|destination
argument_list|)
return|;
block|}
comment|/**      * Provides synchronized access to the write ACLs for the destinations as       * {@link AuthorizationEntry} is not setup for concurrent access.      */
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|Object
argument_list|>
name|getWriteACLs
parameter_list|(
name|ActiveMQDestination
name|destination
parameter_list|)
block|{
return|return
name|super
operator|.
name|getWriteACLs
argument_list|(
name|destination
argument_list|)
return|;
block|}
comment|/**      * Handler for new policy entries in the directory.      *      * @param namingEvent the new entry event that occurred       * @param destinationType the type of the destination to which the event applies      * @param permissionType the permission type to which the event applies      */
specifier|public
specifier|synchronized
name|void
name|objectAdded
parameter_list|(
name|NamingEvent
name|namingEvent
parameter_list|,
name|DestinationType
name|destinationType
parameter_list|,
name|PermissionType
name|permissionType
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding object: "
operator|+
name|namingEvent
operator|.
name|getNewBinding
argument_list|()
argument_list|)
expr_stmt|;
name|SearchResult
name|result
init|=
operator|(
name|SearchResult
operator|)
name|namingEvent
operator|.
name|getNewBinding
argument_list|()
decl_stmt|;
try|try
block|{
name|LdapName
name|name
init|=
operator|new
name|LdapName
argument_list|(
name|result
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|AuthorizationEntry
name|entry
init|=
name|getEntry
argument_list|(
name|name
argument_list|,
name|destinationType
argument_list|)
decl_stmt|;
name|applyACL
argument_list|(
name|entry
argument_list|,
name|result
argument_list|,
name|permissionType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|instanceof
name|TempDestinationAuthorizationEntry
operator|)
condition|)
block|{
name|put
argument_list|(
name|entry
operator|.
name|getDestination
argument_list|()
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InvalidNameException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied!  Error parsing DN for addition of "
operator|+
name|result
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied!  Error processing object addition for addition of "
operator|+
name|result
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Handler for removed policy entries in the directory.      *      * @param namingEvent the removed entry event that occurred       * @param destinationType the type of the destination to which the event applies      * @param permissionType the permission type to which the event applies      */
specifier|public
specifier|synchronized
name|void
name|objectRemoved
parameter_list|(
name|NamingEvent
name|namingEvent
parameter_list|,
name|DestinationType
name|destinationType
parameter_list|,
name|PermissionType
name|permissionType
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing object: "
operator|+
name|namingEvent
operator|.
name|getOldBinding
argument_list|()
argument_list|)
expr_stmt|;
name|Binding
name|result
init|=
name|namingEvent
operator|.
name|getOldBinding
argument_list|()
decl_stmt|;
try|try
block|{
name|LdapName
name|name
init|=
operator|new
name|LdapName
argument_list|(
name|result
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|AuthorizationEntry
name|entry
init|=
name|getEntry
argument_list|(
name|name
argument_list|,
name|destinationType
argument_list|)
decl_stmt|;
name|applyAcl
argument_list|(
name|entry
argument_list|,
name|permissionType
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Object
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidNameException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied!  Error parsing DN for object removal for removal of "
operator|+
name|result
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied!  Error processing object removal for removal of "
operator|+
name|result
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Handler for renamed policy entries in the directory.  This handler deals with the renaming      * of destination entries as well as permission entries.  If the permission type is not null, it is      * assumed that we are dealing with the renaming of a permission entry.  Otherwise, it is assumed      * that we are dealing with the renaming of a destination entry.      *      * @param namingEvent the renaming entry event that occurred       * @param destinationType the type of the destination to which the event applies      * @param permissionType the permission type to which the event applies      */
specifier|public
specifier|synchronized
name|void
name|objectRenamed
parameter_list|(
name|NamingEvent
name|namingEvent
parameter_list|,
name|DestinationType
name|destinationType
parameter_list|,
name|PermissionType
name|permissionType
parameter_list|)
block|{
name|Binding
name|oldBinding
init|=
name|namingEvent
operator|.
name|getOldBinding
argument_list|()
decl_stmt|;
name|Binding
name|newBinding
init|=
name|namingEvent
operator|.
name|getNewBinding
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Renaming object: "
operator|+
name|oldBinding
operator|+
literal|" to "
operator|+
name|newBinding
argument_list|)
expr_stmt|;
try|try
block|{
name|LdapName
name|oldName
init|=
operator|new
name|LdapName
argument_list|(
name|oldBinding
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|ActiveMQDestination
name|oldDest
init|=
name|formatDestination
argument_list|(
name|oldName
argument_list|,
name|destinationType
argument_list|)
decl_stmt|;
name|LdapName
name|newName
init|=
operator|new
name|LdapName
argument_list|(
name|newBinding
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|ActiveMQDestination
name|newDest
init|=
name|formatDestination
argument_list|(
name|newName
argument_list|,
name|destinationType
argument_list|)
decl_stmt|;
if|if
condition|(
name|permissionType
operator|!=
literal|null
condition|)
block|{
comment|// Handle the case where a permission entry is being renamed.
name|objectRemoved
argument_list|(
name|namingEvent
argument_list|,
name|destinationType
argument_list|,
name|permissionType
argument_list|)
expr_stmt|;
name|SearchControls
name|controls
init|=
operator|new
name|SearchControls
argument_list|()
decl_stmt|;
name|controls
operator|.
name|setSearchScope
argument_list|(
name|SearchControls
operator|.
name|OBJECT_SCOPE
argument_list|)
expr_stmt|;
name|boolean
name|matchedToType
init|=
literal|false
decl_stmt|;
for|for
control|(
name|PermissionType
name|newPermissionType
range|:
name|PermissionType
operator|.
name|values
argument_list|()
control|)
block|{
name|NamingEnumeration
argument_list|<
name|SearchResult
argument_list|>
name|results
init|=
name|context
operator|.
name|search
argument_list|(
name|newName
argument_list|,
name|getFilterForPermissionType
argument_list|(
name|newPermissionType
argument_list|)
argument_list|,
name|controls
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|.
name|hasMore
argument_list|()
condition|)
block|{
name|objectAdded
argument_list|(
name|namingEvent
argument_list|,
name|destinationType
argument_list|,
name|newPermissionType
argument_list|)
expr_stmt|;
name|matchedToType
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|matchedToType
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied!  Error processing object rename for rename of "
operator|+
name|oldBinding
operator|.
name|getName
argument_list|()
operator|+
literal|" to "
operator|+
name|newBinding
operator|.
name|getName
argument_list|()
operator|+
literal|".  Could not determine permission type of new object."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Handle the case where a destination entry is being renamed.
if|if
condition|(
name|oldDest
operator|!=
literal|null
operator|&&
name|newDest
operator|!=
literal|null
condition|)
block|{
name|AuthorizationEntry
name|entry
init|=
name|entries
operator|.
name|remove
argument_list|(
name|oldDest
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|entry
operator|.
name|setDestination
argument_list|(
name|newDest
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|newDest
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|oldDest
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entries
operator|.
name|put
argument_list|(
name|newDest
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No authorization entry for "
operator|+
name|oldDest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InvalidNameException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied!  Error parsing DN for object rename for rename of "
operator|+
name|oldBinding
operator|.
name|getName
argument_list|()
operator|+
literal|" to "
operator|+
name|newBinding
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Policy not applied!  Error processing object rename for rename of "
operator|+
name|oldBinding
operator|.
name|getName
argument_list|()
operator|+
literal|" to "
operator|+
name|newBinding
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Handler for changed policy entries in the directory.      *      * @param namingEvent the changed entry event that occurred       * @param destinationType the type of the destination to which the event applies      * @param permissionType the permission type to which the event applies      */
specifier|public
specifier|synchronized
name|void
name|objectChanged
parameter_list|(
name|NamingEvent
name|namingEvent
parameter_list|,
name|DestinationType
name|destinationType
parameter_list|,
name|PermissionType
name|permissionType
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Changing object "
operator|+
name|namingEvent
operator|.
name|getOldBinding
argument_list|()
operator|+
literal|" to "
operator|+
name|namingEvent
operator|.
name|getNewBinding
argument_list|()
argument_list|)
expr_stmt|;
name|objectRemoved
argument_list|(
name|namingEvent
argument_list|,
name|destinationType
argument_list|,
name|permissionType
argument_list|)
expr_stmt|;
name|objectAdded
argument_list|(
name|namingEvent
argument_list|,
name|destinationType
argument_list|,
name|permissionType
argument_list|)
expr_stmt|;
block|}
comment|/**      * Handler for exception events from the registry.      *      * @param namingExceptionEvent the exception event      */
specifier|public
name|void
name|namingExceptionThrown
parameter_list|(
name|NamingExceptionEvent
name|namingExceptionEvent
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Caught unexpected exception."
argument_list|,
name|namingExceptionEvent
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Init / Destroy
annotation|@
name|Override
specifier|public
name|void
name|afterPropertiesSet
parameter_list|()
throws|throws
name|Exception
block|{
name|query
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|destroy
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|eventContext
operator|!=
literal|null
condition|)
block|{
name|eventContext
operator|.
name|close
argument_list|()
expr_stmt|;
name|eventContext
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|!=
literal|null
condition|)
block|{
name|context
operator|.
name|close
argument_list|()
expr_stmt|;
name|context
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Getters and Setters
specifier|public
name|String
name|getConnectionURL
parameter_list|()
block|{
return|return
name|connectionURL
return|;
block|}
specifier|public
name|void
name|setConnectionURL
parameter_list|(
name|String
name|connectionURL
parameter_list|)
block|{
name|this
operator|.
name|connectionURL
operator|=
name|connectionURL
expr_stmt|;
block|}
specifier|public
name|String
name|getConnectionUsername
parameter_list|()
block|{
return|return
name|connectionUsername
return|;
block|}
specifier|public
name|void
name|setConnectionUsername
parameter_list|(
name|String
name|connectionUsername
parameter_list|)
block|{
name|this
operator|.
name|connectionUsername
operator|=
name|connectionUsername
expr_stmt|;
block|}
specifier|public
name|String
name|getConnectionPassword
parameter_list|()
block|{
return|return
name|connectionPassword
return|;
block|}
specifier|public
name|void
name|setConnectionPassword
parameter_list|(
name|String
name|connectionPassword
parameter_list|)
block|{
name|this
operator|.
name|connectionPassword
operator|=
name|connectionPassword
expr_stmt|;
block|}
specifier|public
name|String
name|getConnectionProtocol
parameter_list|()
block|{
return|return
name|connectionProtocol
return|;
block|}
specifier|public
name|void
name|setConnectionProtocol
parameter_list|(
name|String
name|connectionProtocol
parameter_list|)
block|{
name|this
operator|.
name|connectionProtocol
operator|=
name|connectionProtocol
expr_stmt|;
block|}
specifier|public
name|String
name|getAuthentication
parameter_list|()
block|{
return|return
name|authentication
return|;
block|}
specifier|public
name|void
name|setAuthentication
parameter_list|(
name|String
name|authentication
parameter_list|)
block|{
name|this
operator|.
name|authentication
operator|=
name|authentication
expr_stmt|;
block|}
specifier|public
name|String
name|getQueueSearchBase
parameter_list|()
block|{
return|return
name|queueSearchBase
return|;
block|}
specifier|public
name|void
name|setQueueSearchBase
parameter_list|(
name|String
name|queueSearchBase
parameter_list|)
block|{
try|try
block|{
name|LdapName
name|baseName
init|=
operator|new
name|LdapName
argument_list|(
name|queueSearchBase
argument_list|)
decl_stmt|;
name|queuePrefixLength
operator|=
name|baseName
operator|.
name|size
argument_list|()
expr_stmt|;
name|this
operator|.
name|queueSearchBase
operator|=
name|queueSearchBase
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidNameException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid base DN value "
operator|+
name|queueSearchBase
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|String
name|getTopicSearchBase
parameter_list|()
block|{
return|return
name|topicSearchBase
return|;
block|}
specifier|public
name|void
name|setTopicSearchBase
parameter_list|(
name|String
name|topicSearchBase
parameter_list|)
block|{
try|try
block|{
name|LdapName
name|baseName
init|=
operator|new
name|LdapName
argument_list|(
name|topicSearchBase
argument_list|)
decl_stmt|;
name|topicPrefixLength
operator|=
name|baseName
operator|.
name|size
argument_list|()
expr_stmt|;
name|this
operator|.
name|topicSearchBase
operator|=
name|topicSearchBase
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidNameException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid base DN value "
operator|+
name|topicSearchBase
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|String
name|getTempSearchBase
parameter_list|()
block|{
return|return
name|tempSearchBase
return|;
block|}
specifier|public
name|void
name|setTempSearchBase
parameter_list|(
name|String
name|tempSearchBase
parameter_list|)
block|{
try|try
block|{
name|LdapName
name|baseName
init|=
operator|new
name|LdapName
argument_list|(
name|tempSearchBase
argument_list|)
decl_stmt|;
name|tempPrefixLength
operator|=
name|baseName
operator|.
name|size
argument_list|()
expr_stmt|;
name|this
operator|.
name|tempSearchBase
operator|=
name|tempSearchBase
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidNameException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid base DN value "
operator|+
name|tempSearchBase
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|String
name|getPermissionGroupMemberAttribute
parameter_list|()
block|{
return|return
name|permissionGroupMemberAttribute
return|;
block|}
specifier|public
name|void
name|setPermissionGroupMemberAttribute
parameter_list|(
name|String
name|permissionGroupMemberAttribute
parameter_list|)
block|{
name|this
operator|.
name|permissionGroupMemberAttribute
operator|=
name|permissionGroupMemberAttribute
expr_stmt|;
block|}
specifier|public
name|String
name|getAdminPermissionGroupSearchFilter
parameter_list|()
block|{
return|return
name|adminPermissionGroupSearchFilter
return|;
block|}
specifier|public
name|void
name|setAdminPermissionGroupSearchFilter
parameter_list|(
name|String
name|adminPermissionGroupSearchFilter
parameter_list|)
block|{
name|this
operator|.
name|adminPermissionGroupSearchFilter
operator|=
name|adminPermissionGroupSearchFilter
expr_stmt|;
block|}
specifier|public
name|String
name|getReadPermissionGroupSearchFilter
parameter_list|()
block|{
return|return
name|readPermissionGroupSearchFilter
return|;
block|}
specifier|public
name|void
name|setReadPermissionGroupSearchFilter
parameter_list|(
name|String
name|readPermissionGroupSearchFilter
parameter_list|)
block|{
name|this
operator|.
name|readPermissionGroupSearchFilter
operator|=
name|readPermissionGroupSearchFilter
expr_stmt|;
block|}
specifier|public
name|String
name|getWritePermissionGroupSearchFilter
parameter_list|()
block|{
return|return
name|writePermissionGroupSearchFilter
return|;
block|}
specifier|public
name|void
name|setWritePermissionGroupSearchFilter
parameter_list|(
name|String
name|writePermissionGroupSearchFilter
parameter_list|)
block|{
name|this
operator|.
name|writePermissionGroupSearchFilter
operator|=
name|writePermissionGroupSearchFilter
expr_stmt|;
block|}
specifier|public
name|boolean
name|isLegacyGroupMapping
parameter_list|()
block|{
return|return
name|legacyGroupMapping
return|;
block|}
specifier|public
name|void
name|setLegacyGroupMapping
parameter_list|(
name|boolean
name|legacyGroupMapping
parameter_list|)
block|{
name|this
operator|.
name|legacyGroupMapping
operator|=
name|legacyGroupMapping
expr_stmt|;
block|}
specifier|public
name|String
name|getGroupObjectClass
parameter_list|()
block|{
return|return
name|groupObjectClass
return|;
block|}
specifier|public
name|void
name|setGroupObjectClass
parameter_list|(
name|String
name|groupObjectClass
parameter_list|)
block|{
name|this
operator|.
name|groupObjectClass
operator|=
name|groupObjectClass
expr_stmt|;
block|}
specifier|public
name|String
name|getUserObjectClass
parameter_list|()
block|{
return|return
name|userObjectClass
return|;
block|}
specifier|public
name|void
name|setUserObjectClass
parameter_list|(
name|String
name|userObjectClass
parameter_list|)
block|{
name|this
operator|.
name|userObjectClass
operator|=
name|userObjectClass
expr_stmt|;
block|}
specifier|public
name|String
name|getGroupNameAttribute
parameter_list|()
block|{
return|return
name|groupNameAttribute
return|;
block|}
specifier|public
name|void
name|setGroupNameAttribute
parameter_list|(
name|String
name|groupNameAttribute
parameter_list|)
block|{
name|this
operator|.
name|groupNameAttribute
operator|=
name|groupNameAttribute
expr_stmt|;
block|}
specifier|public
name|String
name|getUserNameAttribute
parameter_list|()
block|{
return|return
name|userNameAttribute
return|;
block|}
specifier|public
name|void
name|setUserNameAttribute
parameter_list|(
name|String
name|userNameAttribute
parameter_list|)
block|{
name|this
operator|.
name|userNameAttribute
operator|=
name|userNameAttribute
expr_stmt|;
block|}
specifier|public
name|boolean
name|isRefreshDisabled
parameter_list|()
block|{
return|return
name|refreshDisabled
return|;
block|}
specifier|public
name|void
name|setRefreshDisabled
parameter_list|(
name|boolean
name|refreshDisabled
parameter_list|)
block|{
name|this
operator|.
name|refreshDisabled
operator|=
name|refreshDisabled
expr_stmt|;
block|}
specifier|public
name|int
name|getRefreshInterval
parameter_list|()
block|{
return|return
name|refreshInterval
return|;
block|}
specifier|public
name|void
name|setRefreshInterval
parameter_list|(
name|int
name|refreshInterval
parameter_list|)
block|{
name|this
operator|.
name|refreshInterval
operator|=
name|refreshInterval
expr_stmt|;
block|}
specifier|protected
specifier|static
enum|enum
name|DestinationType
block|{
name|QUEUE
block|,
name|TOPIC
block|,
name|TEMP
block|;     }
specifier|protected
specifier|static
enum|enum
name|PermissionType
block|{
name|READ
block|,
name|WRITE
block|,
name|ADMIN
block|;     }
comment|/**      * Listener implementation for directory changes that maps change events to      * destination types.      */
specifier|protected
class|class
name|CachedLDAPAuthorizationMapNamespaceChangeListener
implements|implements
name|NamespaceChangeListener
implements|,
name|ObjectChangeListener
block|{
specifier|private
specifier|final
name|DestinationType
name|destinationType
decl_stmt|;
specifier|private
specifier|final
name|PermissionType
name|permissionType
decl_stmt|;
comment|/**          * Creates a new listener.  If {@code permissionType} is {@code null}, add          * and remove events are ignored as they do not directly affect policy state.          * This configuration is used when listening for changes on entries that represent          * destination patterns and not for entries that represent permissions.          *          * @param destinationType the type of the destination being listened for          * @param permissionType the optional permission type being listened for          */
specifier|public
name|CachedLDAPAuthorizationMapNamespaceChangeListener
parameter_list|(
name|DestinationType
name|destinationType
parameter_list|,
name|PermissionType
name|permissionType
parameter_list|)
block|{
name|this
operator|.
name|destinationType
operator|=
name|destinationType
expr_stmt|;
name|this
operator|.
name|permissionType
operator|=
name|permissionType
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|namingExceptionThrown
parameter_list|(
name|NamingExceptionEvent
name|evt
parameter_list|)
block|{
name|CachedLDAPAuthorizationMap
operator|.
name|this
operator|.
name|namingExceptionThrown
argument_list|(
name|evt
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|objectAdded
parameter_list|(
name|NamingEvent
name|evt
parameter_list|)
block|{
comment|// This test is a hack to work around the fact that Apache DS 2.0 seems to trigger notifications
comment|// for the entire sub-tree even when one-level is the selected search scope.
if|if
condition|(
name|permissionType
operator|!=
literal|null
condition|)
block|{
name|CachedLDAPAuthorizationMap
operator|.
name|this
operator|.
name|objectAdded
argument_list|(
name|evt
argument_list|,
name|destinationType
argument_list|,
name|permissionType
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|objectRemoved
parameter_list|(
name|NamingEvent
name|evt
parameter_list|)
block|{
comment|// This test is a hack to work around the fact that Apache DS 2.0 seems to trigger notifications
comment|// for the entire sub-tree even when one-level is the selected search scope.
if|if
condition|(
name|permissionType
operator|!=
literal|null
condition|)
block|{
name|CachedLDAPAuthorizationMap
operator|.
name|this
operator|.
name|objectRemoved
argument_list|(
name|evt
argument_list|,
name|destinationType
argument_list|,
name|permissionType
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|objectRenamed
parameter_list|(
name|NamingEvent
name|evt
parameter_list|)
block|{
name|CachedLDAPAuthorizationMap
operator|.
name|this
operator|.
name|objectRenamed
argument_list|(
name|evt
argument_list|,
name|destinationType
argument_list|,
name|permissionType
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|objectChanged
parameter_list|(
name|NamingEvent
name|evt
parameter_list|)
block|{
comment|// This test is a hack to work around the fact that Apache DS 2.0 seems to trigger notifications
comment|// for the entire sub-tree even when one-level is the selected search scope.
if|if
condition|(
name|permissionType
operator|!=
literal|null
condition|)
block|{
name|CachedLDAPAuthorizationMap
operator|.
name|this
operator|.
name|objectChanged
argument_list|(
name|evt
argument_list|,
name|destinationType
argument_list|,
name|permissionType
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

