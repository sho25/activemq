begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Copyright 2005-2006 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|activemq
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|BytesMessage
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Destination
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|IllegalStateException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|InvalidDestinationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|InvalidSelectorException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|JMSException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|MapMessage
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|MessageConsumer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|MessageListener
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|MessageProducer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|ObjectMessage
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|QueueBrowser
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|QueueReceiver
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|QueueSender
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|QueueSession
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Session
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|StreamMessage
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TemporaryQueue
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TemporaryTopic
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TextMessage
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Topic
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TopicPublisher
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TopicSession
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TopicSubscriber
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TransactionRolledBackException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQBytesMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQDestination
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQMapMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQObjectMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQStreamMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQTextMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQTopic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|Command
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ConsumerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|MessageAck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|MessageDispatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|MessageId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ProducerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|Response
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|SessionId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|SessionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|TransactionId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|management
operator|.
name|JMSSessionStatsImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|management
operator|.
name|StatsCapable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|management
operator|.
name|StatsImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|thread
operator|.
name|Scheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transaction
operator|.
name|Synchronization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|Callback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|LongSequenceGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|edu
operator|.
name|emory
operator|.
name|mathcs
operator|.
name|backport
operator|.
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|edu
operator|.
name|emory
operator|.
name|mathcs
operator|.
name|backport
operator|.
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_comment
comment|/**  *<P>  * A<CODE>Session</CODE> object is a single-threaded context for producing  * and consuming messages. Although it may allocate provider resources outside  * the Java virtual machine (JVM), it is considered a lightweight JMS object.  *<P>  * A session serves several purposes:  *<UL>  *<LI>It is a factory for its message producers and consumers.  *<LI>It supplies provider-optimized message factories.  *<LI>It is a factory for<CODE>TemporaryTopics</CODE> and<CODE>TemporaryQueues</CODE>.  *<LI>It provides a way to create<CODE>Queue</CODE> or<CODE>Topic</CODE>  * objects for those clients that need to dynamically manipulate  * provider-specific destination names.  *<LI>It supports a single series of transactions that combine work spanning  * its producers and consumers into atomic units.  *<LI>It defines a serial order for the messages it consumes and the messages  * it produces.  *<LI>It retains messages it consumes until they have been acknowledged.  *<LI>It serializes execution of message listeners registered with its message  * consumers.  *<LI>It is a factory for<CODE>QueueBrowsers</CODE>.  *</UL>  *<P>  * A session can create and service multiple message producers and consumers.  *<P>  * One typical use is to have a thread block on a synchronous<CODE>MessageConsumer</CODE>  * until a message arrives. The thread may then use one or more of the<CODE>Session</CODE>'s<CODE>MessageProducer</CODE>s.  *<P>  * If a client desires to have one thread produce messages while others consume  * them, the client should use a separate session for its producing thread.  *<P>  * Once a connection has been started, any session with one or more registered  * message listeners is dedicated to the thread of control that delivers  * messages to it. It is erroneous for client code to use this session or any of  * its constituent objects from another thread of control. The only exception to  * this rule is the use of the session or connection<CODE>close</CODE>  * method.  *<P>  * It should be easy for most clients to partition their work naturally into  * sessions. This model allows clients to start simply and incrementally add  * message processing complexity as their need for concurrency grows.  *<P>  * The<CODE>close</CODE> method is the only session method that can be called  * while some other session method is being executed in another thread.  *<P>  * A session may be specified as transacted. Each transacted session supports a  * single series of transactions. Each transaction groups a set of message sends  * and a set of message receives into an atomic unit of work. In effect,  * transactions organize a session's input message stream and output message  * stream into series of atomic units. When a transaction commits, its atomic  * unit of input is acknowledged and its associated atomic unit of output is  * sent. If a transaction rollback is done, the transaction's sent messages are  * destroyed and the session's input is automatically recovered.  *<P>  * The content of a transaction's input and output units is simply those  * messages that have been produced and consumed within the session's current  * transaction.  *<P>  * A transaction is completed using either its session's<CODE>commit</CODE>  * method or its session's<CODE>rollback</CODE> method. The completion of a  * session's current transaction automatically begins the next. The result is  * that a transacted session always has a current transaction within which its  * work is done.  *<P>  * The Java Transaction Service (JTS) or some other transaction monitor may be  * used to combine a session's transaction with transactions on other resources  * (databases, other JMS sessions, etc.). Since Java distributed transactions  * are controlled via the Java Transaction API (JTA), use of the session's  *<CODE>commit</CODE> and<CODE>rollback</CODE> methods in this context is  * prohibited.  *<P>  * The JMS API does not require support for JTA; however, it does define how a  * provider supplies this support.  *<P>  * Although it is also possible for a JMS client to handle distributed  * transactions directly, it is unlikely that many JMS clients will do this.  * Support for JTA in the JMS API is targeted at systems vendors who will be  * integrating the JMS API into their application server products.  *   * @version $Revision: 1.34 $  * @see javax.jms.Session  * @see javax.jms.QueueSession  * @see javax.jms.TopicSession  * @see javax.jms.XASession  */
end_comment

begin_class
specifier|public
class|class
name|ActiveMQSession
implements|implements
name|Session
implements|,
name|QueueSession
implements|,
name|TopicSession
implements|,
name|StatsCapable
implements|,
name|ActiveMQDispatcher
block|{
specifier|public
specifier|static
interface|interface
name|DeliveryListener
block|{
specifier|public
name|void
name|beforeDelivery
parameter_list|(
name|ActiveMQSession
name|session
parameter_list|,
name|Message
name|msg
parameter_list|)
function_decl|;
specifier|public
name|void
name|afterDelivery
parameter_list|(
name|ActiveMQSession
name|session
parameter_list|,
name|Message
name|msg
parameter_list|)
function_decl|;
block|}
specifier|private
specifier|static
specifier|final
name|Log
name|log
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ActiveMQSession
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
name|int
name|acknowledgementMode
decl_stmt|;
specifier|private
name|MessageListener
name|messageListener
decl_stmt|;
specifier|private
name|JMSSessionStatsImpl
name|stats
decl_stmt|;
specifier|private
name|TransactionContext
name|transactionContext
decl_stmt|;
specifier|private
name|DeliveryListener
name|deliveryListener
decl_stmt|;
specifier|protected
specifier|final
name|ActiveMQConnection
name|connection
decl_stmt|;
specifier|protected
specifier|final
name|SessionInfo
name|info
decl_stmt|;
specifier|protected
specifier|final
name|LongSequenceGenerator
name|consumerIdGenerator
init|=
operator|new
name|LongSequenceGenerator
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|LongSequenceGenerator
name|producerIdGenerator
init|=
operator|new
name|LongSequenceGenerator
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|LongSequenceGenerator
name|deliveryIdGenerator
init|=
operator|new
name|LongSequenceGenerator
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|ActiveMQSessionExecutor
name|executor
init|=
operator|new
name|ActiveMQSessionExecutor
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|AtomicBoolean
name|started
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|CopyOnWriteArrayList
name|consumers
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|CopyOnWriteArrayList
name|producers
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|()
decl_stmt|;
specifier|protected
name|boolean
name|closed
decl_stmt|;
specifier|protected
name|boolean
name|asyncDispatch
decl_stmt|;
comment|/**      * Construct the Session      *       * @param connection      * @param acknowledgeMode      *            n.b if transacted - the acknowledgeMode ==      *            Session.SESSION_TRANSACTED      * @throws JMSException      *             on internal error      */
specifier|protected
name|ActiveMQSession
parameter_list|(
name|ActiveMQConnection
name|connection
parameter_list|,
name|SessionId
name|sessionId
parameter_list|,
name|int
name|acknowledgeMode
parameter_list|,
name|boolean
name|asyncDispatch
parameter_list|)
throws|throws
name|JMSException
block|{
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|acknowledgementMode
operator|=
name|acknowledgeMode
expr_stmt|;
name|this
operator|.
name|asyncDispatch
operator|=
name|asyncDispatch
expr_stmt|;
name|this
operator|.
name|info
operator|=
operator|new
name|SessionInfo
argument_list|(
name|connection
operator|.
name|getConnectionInfo
argument_list|()
argument_list|,
name|sessionId
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|setTransactionContext
argument_list|(
operator|new
name|TransactionContext
argument_list|(
name|connection
argument_list|)
argument_list|)
expr_stmt|;
name|connection
operator|.
name|addSession
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|new
name|JMSSessionStatsImpl
argument_list|(
name|producers
argument_list|,
name|consumers
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|.
name|asyncSendPacket
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|.
name|isStarted
argument_list|()
condition|)
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**      * Sets the transaction context of the session.      *       * @param transactionContext -      *            provides the means to control a JMS transaction.      */
specifier|public
name|void
name|setTransactionContext
parameter_list|(
name|TransactionContext
name|transactionContext
parameter_list|)
block|{
name|this
operator|.
name|transactionContext
operator|=
name|transactionContext
expr_stmt|;
block|}
comment|/**      * Returns the transaction context of the session.      *       * @return transactionContext - session's transaction context.      */
specifier|public
name|TransactionContext
name|getTransactionContext
parameter_list|()
block|{
return|return
name|transactionContext
return|;
block|}
comment|/*      * (non-Javadoc)      *       * @see org.apache.activemq.management.StatsCapable#getStats()      */
specifier|public
name|StatsImpl
name|getStats
parameter_list|()
block|{
return|return
name|stats
return|;
block|}
comment|/**      * Returns the session's statistics.      *       * @return stats - session's statistics.      */
specifier|public
name|JMSSessionStatsImpl
name|getSessionStats
parameter_list|()
block|{
return|return
name|stats
return|;
block|}
comment|/**      * Creates a<CODE>BytesMessage</CODE> object. A<CODE>BytesMessage</CODE>      * object is used to send a message containing a stream of uninterpreted      * bytes.      *       * @return the an ActiveMQBytesMessage      * @throws JMSException      *             if the JMS provider fails to create this message due to some      *             internal error.      */
specifier|public
name|BytesMessage
name|createBytesMessage
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|ActiveMQBytesMessage
name|message
init|=
operator|new
name|ActiveMQBytesMessage
argument_list|()
decl_stmt|;
name|message
operator|.
name|setConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates a<CODE>MapMessage</CODE> object. A<CODE>MapMessage</CODE>      * object is used to send a self-defining set of name-value pairs, where      * names are<CODE>String</CODE> objects and values are primitive values      * in the Java programming language.      *       * @return an ActiveMQMapMessage      * @throws JMSException      *             if the JMS provider fails to create this message due to some      *             internal error.      */
specifier|public
name|MapMessage
name|createMapMessage
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|ActiveMQMapMessage
name|message
init|=
operator|new
name|ActiveMQMapMessage
argument_list|()
decl_stmt|;
name|message
operator|.
name|setConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates a<CODE>Message</CODE> object. The<CODE>Message</CODE>      * interface is the root interface of all JMS messages. A<CODE>Message</CODE>      * object holds all the standard message header information. It can be sent      * when a message containing only header information is sufficient.      *       * @return an ActiveMQMessage      * @throws JMSException      *             if the JMS provider fails to create this message due to some      *             internal error.      */
specifier|public
name|Message
name|createMessage
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|ActiveMQMessage
name|message
init|=
operator|new
name|ActiveMQMessage
argument_list|()
decl_stmt|;
name|message
operator|.
name|setConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates an<CODE>ObjectMessage</CODE> object. An<CODE>ObjectMessage</CODE>      * object is used to send a message that contains a serializable Java      * object.      *       * @return an ActiveMQObjectMessage      * @throws JMSException      *             if the JMS provider fails to create this message due to some      *             internal error.      */
specifier|public
name|ObjectMessage
name|createObjectMessage
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|ActiveMQObjectMessage
name|message
init|=
operator|new
name|ActiveMQObjectMessage
argument_list|()
decl_stmt|;
name|message
operator|.
name|setConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates an initialized<CODE>ObjectMessage</CODE> object. An<CODE>ObjectMessage</CODE>      * object is used to send a message that contains a serializable Java      * object.      *       * @param object      *            the object to use to initialize this message      * @return an ActiveMQObjectMessage      * @throws JMSException      *             if the JMS provider fails to create this message due to some      *             internal error.      */
specifier|public
name|ObjectMessage
name|createObjectMessage
parameter_list|(
name|Serializable
name|object
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|ActiveMQObjectMessage
name|message
init|=
operator|new
name|ActiveMQObjectMessage
argument_list|()
decl_stmt|;
name|message
operator|.
name|setConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|message
operator|.
name|setObject
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates a<CODE>StreamMessage</CODE> object. A<CODE>StreamMessage</CODE>      * object is used to send a self-defining stream of primitive values in the      * Java programming language.      *       * @return an ActiveMQStreamMessage      * @throws JMSException      *             if the JMS provider fails to create this message due to some      *             internal error.      */
specifier|public
name|StreamMessage
name|createStreamMessage
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|ActiveMQStreamMessage
name|message
init|=
operator|new
name|ActiveMQStreamMessage
argument_list|()
decl_stmt|;
name|message
operator|.
name|setConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates a<CODE>TextMessage</CODE> object. A<CODE>TextMessage</CODE>      * object is used to send a message containing a<CODE>String</CODE>      * object.      *       * @return an ActiveMQTextMessage      * @throws JMSException      *             if the JMS provider fails to create this message due to some      *             internal error.      */
specifier|public
name|TextMessage
name|createTextMessage
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|ActiveMQTextMessage
name|message
init|=
operator|new
name|ActiveMQTextMessage
argument_list|()
decl_stmt|;
name|message
operator|.
name|setConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates an initialized<CODE>TextMessage</CODE> object. A<CODE>TextMessage</CODE>      * object is used to send a message containing a<CODE>String</CODE>.      *       * @param text      *            the string used to initialize this message      * @return an ActiveMQTextMessage      * @throws JMSException      *             if the JMS provider fails to create this message due to some      *             internal error.      */
specifier|public
name|TextMessage
name|createTextMessage
parameter_list|(
name|String
name|text
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|ActiveMQTextMessage
name|message
init|=
operator|new
name|ActiveMQTextMessage
argument_list|()
decl_stmt|;
name|message
operator|.
name|setText
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|message
operator|.
name|setConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Indicates whether the session is in transacted mode.      *       * @return true if the session is in transacted mode      * @throws JMSException      *             if there is some internal error.      */
specifier|public
name|boolean
name|getTransacted
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|acknowledgementMode
operator|==
name|Session
operator|.
name|SESSION_TRANSACTED
operator|)
operator|||
operator|(
name|transactionContext
operator|.
name|isInXATransaction
argument_list|()
operator|)
operator|)
return|;
block|}
comment|/**      * Returns the acknowledgement mode of the session. The acknowledgement mode      * is set at the time that the session is created. If the session is      * transacted, the acknowledgement mode is ignored.      *       * @return If the session is not transacted, returns the current      *         acknowledgement mode for the session. If the session is      *         transacted, returns SESSION_TRANSACTED.      * @throws JMSException      * @see javax.jms.Connection#createSession(boolean,int)      * @since 1.1 exception JMSException if there is some internal error.      */
specifier|public
name|int
name|getAcknowledgeMode
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|acknowledgementMode
return|;
block|}
comment|/**      * Commits all messages done in this transaction and releases any locks      * currently held.      *       * @throws JMSException      *             if the JMS provider fails to commit the transaction due to      *             some internal error.      * @throws TransactionRolledBackException      *             if the transaction is rolled back due to some internal error      *             during commit.      * @throws javax.jms.IllegalStateException      *             if the method is not called by a transacted session.      */
specifier|public
name|void
name|commit
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getTransacted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|javax
operator|.
name|jms
operator|.
name|IllegalStateException
argument_list|(
literal|"Not a transacted session"
argument_list|)
throw|;
block|}
name|transactionContext
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
comment|/**      * Rolls back any messages done in this transaction and releases any locks      * currently held.      *       * @throws JMSException      *             if the JMS provider fails to roll back the transaction due to      *             some internal error.      * @throws javax.jms.IllegalStateException      *             if the method is not called by a transacted session.      */
specifier|public
name|void
name|rollback
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getTransacted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|javax
operator|.
name|jms
operator|.
name|IllegalStateException
argument_list|(
literal|"Not a transacted session"
argument_list|)
throw|;
block|}
name|transactionContext
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
comment|/**      * Closes the session.      *<P>      * Since a provider may allocate some resources on behalf of a session      * outside the JVM, clients should close the resources when they are not      * needed. Relying on garbage collection to eventually reclaim these      * resources may not be timely enough.      *<P>      * There is no need to close the producers and consumers of a closed      * session.      *<P>      * This call will block until a<CODE>receive</CODE> call or message      * listener in progress has completed. A blocked message consumer<CODE>receive</CODE>      * call returns<CODE>null</CODE> when this session is closed.      *<P>      * Closing a transacted session must roll back the transaction in progress.      *<P>      * This method is the only<CODE>Session</CODE> method that can be called      * concurrently.      *<P>      * Invoking any other<CODE>Session</CODE> method on a closed session must      * throw a<CODE> JMSException.IllegalStateException</CODE>. Closing a      * closed session must<I>not</I> throw an exception.      *       * @throws JMSException      *             if the JMS provider fails to close the session due to some      *             internal error.      */
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|JMSException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
name|dispose
argument_list|()
expr_stmt|;
name|connection
operator|.
name|asyncSendPacket
argument_list|(
name|info
operator|.
name|createRemoveCommand
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|dispose
parameter_list|()
throws|throws
name|JMSException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
for|for
control|(
name|Iterator
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|consumer
init|=
operator|(
name|ActiveMQMessageConsumer
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|consumer
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
name|consumers
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
name|iter
init|=
name|producers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageProducer
name|producer
init|=
operator|(
name|ActiveMQMessageProducer
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|producer
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
name|producers
operator|.
name|clear
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|getTransactionContext
argument_list|()
operator|.
name|isInLocalTransaction
argument_list|()
condition|)
block|{
name|rollback
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|JMSException
name|e
parameter_list|)
block|{             }
name|connection
operator|.
name|removeSession
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|transactionContext
operator|=
literal|null
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**      * Check if the session is closed. It is used for ensuring that the session      * is open before performing various operations.      *       * @throws IllegalStateException      *             if the Session is closed      */
specifier|protected
name|void
name|checkClosed
parameter_list|()
throws|throws
name|IllegalStateException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The Session is closed"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Stops message delivery in this session, and restarts message delivery      * with the oldest unacknowledged message.      *<P>      * All consumers deliver messages in a serial order. Acknowledging a      * received message automatically acknowledges all messages that have been      * delivered to the client.      *<P>      * Restarting a session causes it to take the following actions:      *<UL>      *<LI>Stop message delivery      *<LI>Mark all messages that might have been delivered but not      * acknowledged as "redelivered"      *<LI>Restart the delivery sequence including all unacknowledged messages      * that had been previously delivered. Redelivered messages do not have to      * be delivered in exactly their original delivery order.      *</UL>      *       * @throws JMSException      *             if the JMS provider fails to stop and restart message      *             delivery due to some internal error.      * @throws IllegalStateException      *             if the method is called by a transacted session.      */
specifier|public
name|void
name|recover
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|getTransacted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"This session is transacted"
argument_list|)
throw|;
block|}
for|for
control|(
name|Iterator
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|c
init|=
operator|(
name|ActiveMQMessageConsumer
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|c
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Returns the session's distinguished message listener (optional).      *       * @return the message listener associated with this session      * @throws JMSException      *             if the JMS provider fails to get the message listener due to      *             an internal error.      * @see javax.jms.Session#setMessageListener(javax.jms.MessageListener)      * @see javax.jms.ServerSessionPool      * @see javax.jms.ServerSession      */
specifier|public
name|MessageListener
name|getMessageListener
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|messageListener
return|;
block|}
comment|/**      * Sets the session's distinguished message listener (optional).      *<P>      * When the distinguished message listener is set, no other form of message      * receipt in the session can be used; however, all forms of sending      * messages are still supported.      *<P>      * This is an expert facility not used by regular JMS clients.      *       * @param listener      *            the message listener to associate with this session      * @throws JMSException      *             if the JMS provider fails to set the message listener due to      *             an internal error.      * @see javax.jms.Session#getMessageListener()      * @see javax.jms.ServerSessionPool      * @see javax.jms.ServerSession      */
specifier|public
name|void
name|setMessageListener
parameter_list|(
name|MessageListener
name|listener
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|this
operator|.
name|messageListener
operator|=
name|listener
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|executor
operator|.
name|setDispatchedBySessionPool
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Optional operation, intended to be used only by Application Servers, not      * by ordinary JMS clients.      *       * @see javax.jms.ServerSession      */
specifier|public
name|void
name|run
parameter_list|()
block|{
name|MessageDispatch
name|messageDispatch
decl_stmt|;
while|while
condition|(
operator|(
name|messageDispatch
operator|=
name|executor
operator|.
name|dequeueNoWait
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
specifier|final
name|MessageDispatch
name|md
init|=
name|messageDispatch
decl_stmt|;
name|ActiveMQMessage
name|message
init|=
operator|(
name|ActiveMQMessage
operator|)
name|md
operator|.
name|getMessage
argument_list|()
decl_stmt|;
if|if
condition|(
name|message
operator|.
name|isExpired
argument_list|()
condition|)
block|{
comment|//TODO: Ack it without delivery to client
continue|continue;
block|}
if|if
condition|(
name|isClientAcknowledge
argument_list|()
condition|)
block|{
name|message
operator|.
name|setAcknowledgeCallback
argument_list|(
operator|new
name|Callback
argument_list|()
block|{
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|Throwable
block|{                     }
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deliveryListener
operator|!=
literal|null
condition|)
block|{
name|deliveryListener
operator|.
name|beforeDelivery
argument_list|(
name|this
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
name|md
operator|.
name|setDeliverySequenceId
argument_list|(
name|getNextDeliveryId
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|messageListener
operator|.
name|onMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// TODO: figure out proper way to handle error.
name|log
operator|.
name|error
argument_list|(
literal|"error dispatching message: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|connection
operator|.
name|onAsyncException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|MessageAck
name|ack
init|=
operator|new
name|MessageAck
argument_list|(
name|md
argument_list|,
name|MessageAck
operator|.
name|STANDARD_ACK_TYPE
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|ack
operator|.
name|setFirstMessageId
argument_list|(
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|getMessageId
argument_list|()
argument_list|)
expr_stmt|;
name|doStartTransaction
argument_list|()
expr_stmt|;
name|ack
operator|.
name|setTransactionId
argument_list|(
name|getTransactionContext
argument_list|()
operator|.
name|getTransactionId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
operator|.
name|getTransactionId
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|getTransactionContext
argument_list|()
operator|.
name|addSynchronization
argument_list|(
operator|new
name|Synchronization
argument_list|()
block|{
specifier|public
name|void
name|afterRollback
parameter_list|()
throws|throws
name|Throwable
block|{
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|incrementRedeliveryCounter
argument_list|()
expr_stmt|;
name|RedeliveryPolicy
name|redeliveryPolicy
init|=
name|connection
operator|.
name|getRedeliveryPolicy
argument_list|()
decl_stmt|;
name|int
name|redeliveryCounter
init|=
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|getRedeliveryCounter
argument_list|()
decl_stmt|;
if|if
condition|(
name|redeliveryCounter
operator|>
name|redeliveryPolicy
operator|.
name|getMaximumRedeliveries
argument_list|()
condition|)
block|{
comment|// We need to NACK the messages so that they get sent to the
comment|// DLQ.
comment|// Acknowledge the last message.
name|MessageAck
name|ack
init|=
operator|new
name|MessageAck
argument_list|(
name|md
argument_list|,
name|MessageAck
operator|.
name|POSION_ACK_TYPE
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|ack
operator|.
name|setFirstMessageId
argument_list|(
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|getMessageId
argument_list|()
argument_list|)
expr_stmt|;
name|asyncSendPacket
argument_list|(
name|ack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Figure out how long we should wait to resend this message.
name|long
name|redeliveryDelay
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|redeliveryCounter
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|redeliveryDelay
operator|==
literal|0
condition|)
block|{
name|redeliveryDelay
operator|=
name|redeliveryPolicy
operator|.
name|getInitialRedeliveryDelay
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|redeliveryPolicy
operator|.
name|isUseExponentialBackOff
argument_list|()
condition|)
name|redeliveryDelay
operator|*=
name|redeliveryPolicy
operator|.
name|getBackOffMultiplier
argument_list|()
expr_stmt|;
block|}
block|}
name|Scheduler
operator|.
name|executeAfterDelay
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
operator|(
operator|(
name|ActiveMQDispatcher
operator|)
name|md
operator|.
name|getConsumer
argument_list|()
operator|)
operator|.
name|dispatch
argument_list|(
name|md
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
name|redeliveryDelay
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|asyncSendPacket
argument_list|(
name|ack
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|connection
operator|.
name|onAsyncException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deliveryListener
operator|!=
literal|null
condition|)
block|{
name|deliveryListener
operator|.
name|afterDelivery
argument_list|(
name|this
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Creates a<CODE>MessageProducer</CODE> to send messages to the      * specified destination.      *<P>      * A client uses a<CODE>MessageProducer</CODE> object to send messages to      * a destination. Since<CODE>Queue</CODE> and<CODE>Topic</CODE> both      * inherit from<CODE>Destination</CODE>, they can be used in the      * destination parameter to create a<CODE>MessageProducer</CODE> object.      *       * @param destination      *            the<CODE>Destination</CODE> to send to, or null if this is      *            a producer which does not have a specified destination.      * @return the MessageProducer      * @throws JMSException      *             if the session fails to create a MessageProducer due to some      *             internal error.      * @throws InvalidDestinationException      *             if an invalid destination is specified.      * @since 1.1      */
specifier|public
name|MessageProducer
name|createProducer
parameter_list|(
name|Destination
name|destination
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|new
name|ActiveMQMessageProducer
argument_list|(
name|this
argument_list|,
name|getNextProducerId
argument_list|()
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|destination
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>MessageConsumer</CODE> for the specified destination.      * Since<CODE>Queue</CODE> and<CODE> Topic</CODE> both inherit from      *<CODE>Destination</CODE>, they can be used in the destination      * parameter to create a<CODE>MessageConsumer</CODE>.      *       * @param destination      *            the<CODE>Destination</CODE> to access.      * @return the MessageConsumer      * @throws JMSException      *             if the session fails to create a consumer due to some      *             internal error.      * @throws InvalidDestinationException      *             if an invalid destination is specified.      * @since 1.1      */
specifier|public
name|MessageConsumer
name|createConsumer
parameter_list|(
name|Destination
name|destination
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|createConsumer
argument_list|(
name|destination
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>MessageConsumer</CODE> for the specified destination,      * using a message selector. Since<CODE> Queue</CODE> and<CODE>Topic</CODE>      * both inherit from<CODE>Destination</CODE>, they can be used in the      * destination parameter to create a<CODE>MessageConsumer</CODE>.      *<P>      * A client uses a<CODE>MessageConsumer</CODE> object to receive messages      * that have been sent to a destination.      *       * @param destination      *            the<CODE>Destination</CODE> to access      * @param messageSelector      *            only messages with properties matching the message selector      *            expression are delivered. A value of null or an empty string      *            indicates that there is no message selector for the message      *            consumer.      * @return the MessageConsumer      * @throws JMSException      *             if the session fails to create a MessageConsumer due to some      *             internal error.      * @throws InvalidDestinationException      *             if an invalid destination is specified.      * @throws InvalidSelectorException      *             if the message selector is invalid.      * @since 1.1      */
specifier|public
name|MessageConsumer
name|createConsumer
parameter_list|(
name|Destination
name|destination
parameter_list|,
name|String
name|messageSelector
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|int
name|prefetch
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|destination
operator|instanceof
name|Topic
condition|)
block|{
name|prefetch
operator|=
name|connection
operator|.
name|getPrefetchPolicy
argument_list|()
operator|.
name|getTopicPrefetch
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|prefetch
operator|=
name|connection
operator|.
name|getPrefetchPolicy
argument_list|()
operator|.
name|getQueuePrefetch
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|ActiveMQMessageConsumer
argument_list|(
name|this
argument_list|,
name|getNextConsumerId
argument_list|()
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|destination
argument_list|)
argument_list|,
literal|null
argument_list|,
name|messageSelector
argument_list|,
name|prefetch
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|asyncDispatch
argument_list|)
return|;
block|}
comment|/**      * @return      */
specifier|protected
name|ConsumerId
name|getNextConsumerId
parameter_list|()
block|{
return|return
operator|new
name|ConsumerId
argument_list|(
name|info
operator|.
name|getSessionId
argument_list|()
argument_list|,
name|consumerIdGenerator
operator|.
name|getNextSequenceId
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @return      */
specifier|protected
name|ProducerId
name|getNextProducerId
parameter_list|()
block|{
return|return
operator|new
name|ProducerId
argument_list|(
name|info
operator|.
name|getSessionId
argument_list|()
argument_list|,
name|producerIdGenerator
operator|.
name|getNextSequenceId
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates<CODE>MessageConsumer</CODE> for the specified destination,      * using a message selector. This method can specify whether messages      * published by its own connection should be delivered to it, if the      * destination is a topic.      *<P>      * Since<CODE>Queue</CODE> and<CODE>Topic</CODE> both inherit from      *<CODE>Destination</CODE>, they can be used in the destination      * parameter to create a<CODE>MessageConsumer</CODE>.      *<P>      * A client uses a<CODE>MessageConsumer</CODE> object to receive messages      * that have been published to a destination.      *<P>      * In some cases, a connection may both publish and subscribe to a topic.      * The consumer<CODE>NoLocal</CODE> attribute allows a consumer to      * inhibit the delivery of messages published by its own connection. The      * default value for this attribute is False. The<CODE>noLocal</CODE>      * value must be supported by destinations that are topics.      *       * @param destination      *            the<CODE>Destination</CODE> to access      * @param messageSelector      *            only messages with properties matching the message selector      *            expression are delivered. A value of null or an empty string      *            indicates that there is no message selector for the message      *            consumer.      * @param NoLocal -      *            if true, and the destination is a topic, inhibits the delivery      *            of messages published by its own connection. The behavior for      *<CODE>NoLocal</CODE> is not specified if the destination is      *            a queue.      * @return the MessageConsumer      * @throws JMSException      *             if the session fails to create a MessageConsumer due to some      *             internal error.      * @throws InvalidDestinationException      *             if an invalid destination is specified.      * @throws InvalidSelectorException      *             if the message selector is invalid.      * @since 1.1      */
specifier|public
name|MessageConsumer
name|createConsumer
parameter_list|(
name|Destination
name|destination
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|boolean
name|NoLocal
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|new
name|ActiveMQMessageConsumer
argument_list|(
name|this
argument_list|,
name|getNextConsumerId
argument_list|()
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|destination
argument_list|)
argument_list|,
literal|null
argument_list|,
name|messageSelector
argument_list|,
name|connection
operator|.
name|getPrefetchPolicy
argument_list|()
operator|.
name|getTopicPrefetch
argument_list|()
argument_list|,
name|NoLocal
argument_list|,
literal|false
argument_list|,
name|asyncDispatch
argument_list|)
return|;
block|}
comment|/**      * Creates a queue identity given a<CODE>Queue</CODE> name.      *<P>      * This facility is provided for the rare cases where clients need to      * dynamically manipulate queue identity. It allows the creation of a queue      * identity with a provider-specific name. Clients that depend on this      * ability are not portable.      *<P>      * Note that this method is not for creating the physical queue. The      * physical creation of queues is an administrative task and is not to be      * initiated by the JMS API. The one exception is the creation of temporary      * queues, which is accomplished with the<CODE>createTemporaryQueue</CODE>      * method.      *       * @param queueName      *            the name of this<CODE>Queue</CODE>      * @return a<CODE>Queue</CODE> with the given name      * @throws JMSException      *             if the session fails to create a queue due to some internal      *             error.      * @since 1.1      */
specifier|public
name|Queue
name|createQueue
parameter_list|(
name|String
name|queueName
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|new
name|ActiveMQQueue
argument_list|(
name|queueName
argument_list|)
return|;
block|}
comment|/**      * Creates a topic identity given a<CODE>Topic</CODE> name.      *<P>      * This facility is provided for the rare cases where clients need to      * dynamically manipulate topic identity. This allows the creation of a      * topic identity with a provider-specific name. Clients that depend on this      * ability are not portable.      *<P>      * Note that this method is not for creating the physical topic. The      * physical creation of topics is an administrative task and is not to be      * initiated by the JMS API. The one exception is the creation of temporary      * topics, which is accomplished with the<CODE>createTemporaryTopic</CODE>      * method.      *       * @param topicName      *            the name of this<CODE>Topic</CODE>      * @return a<CODE>Topic</CODE> with the given name      * @throws JMSException      *             if the session fails to create a topic due to some internal      *             error.      * @since 1.1      */
specifier|public
name|Topic
name|createTopic
parameter_list|(
name|String
name|topicName
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|new
name|ActiveMQTopic
argument_list|(
name|topicName
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>QueueBrowser</CODE> object to peek at the messages on      * the specified queue.      *       * @param queue      *            the<CODE>queue</CODE> to access      * @exception InvalidDestinationException      *                if an invalid destination is specified      * @since 1.1      */
comment|/**      * Creates a durable subscriber to the specified topic.      *<P>      * If a client needs to receive all the messages published on a topic,      * including the ones published while the subscriber is inactive, it uses a      * durable<CODE>TopicSubscriber</CODE>. The JMS provider retains a      * record of this durable subscription and insures that all messages from      * the topic's publishers are retained until they are acknowledged by this      * durable subscriber or they have expired.      *<P>      * Sessions with durable subscribers must always provide the same client      * identifier. In addition, each client must specify a name that uniquely      * identifies (within client identifier) each durable subscription it      * creates. Only one session at a time can have a<CODE>TopicSubscriber</CODE>      * for a particular durable subscription.      *<P>      * A client can change an existing durable subscription by creating a      * durable<CODE>TopicSubscriber</CODE> with the same name and a new topic      * and/or message selector. Changing a durable subscriber is equivalent to      * unsubscribing (deleting) the old one and creating a new one.      *<P>      * In some cases, a connection may both publish and subscribe to a topic.      * The subscriber<CODE>NoLocal</CODE> attribute allows a subscriber to      * inhibit the delivery of messages published by its own connection. The      * default value for this attribute is false.      *       * @param topic      *            the non-temporary<CODE>Topic</CODE> to subscribe to      * @param name      *            the name used to identify this subscription      * @return the TopicSubscriber      * @throws JMSException      *             if the session fails to create a subscriber due to some      *             internal error.      * @throws InvalidDestinationException      *             if an invalid topic is specified.      * @since 1.1      */
specifier|public
name|TopicSubscriber
name|createDurableSubscriber
parameter_list|(
name|Topic
name|topic
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|createDurableSubscriber
argument_list|(
name|topic
argument_list|,
name|name
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a durable subscriber to the specified topic, using a message      * selector and specifying whether messages published by its own connection      * should be delivered to it.      *<P>      * If a client needs to receive all the messages published on a topic,      * including the ones published while the subscriber is inactive, it uses a      * durable<CODE>TopicSubscriber</CODE>. The JMS provider retains a      * record of this durable subscription and insures that all messages from      * the topic's publishers are retained until they are acknowledged by this      * durable subscriber or they have expired.      *<P>      * Sessions with durable subscribers must always provide the same client      * identifier. In addition, each client must specify a name which uniquely      * identifies (within client identifier) each durable subscription it      * creates. Only one session at a time can have a<CODE>TopicSubscriber</CODE>      * for a particular durable subscription. An inactive durable subscriber is      * one that exists but does not currently have a message consumer associated      * with it.      *<P>      * A client can change an existing durable subscription by creating a      * durable<CODE>TopicSubscriber</CODE> with the same name and a new topic      * and/or message selector. Changing a durable subscriber is equivalent to      * unsubscribing (deleting) the old one and creating a new one.      *       * @param topic      *            the non-temporary<CODE>Topic</CODE> to subscribe to      * @param name      *            the name used to identify this subscription      * @param messageSelector      *            only messages with properties matching the message selector      *            expression are delivered. A value of null or an empty string      *            indicates that there is no message selector for the message      *            consumer.      * @param noLocal      *            if set, inhibits the delivery of messages published by its own      *            connection      * @return the Queue Browser      * @throws JMSException      *             if the session fails to create a subscriber due to some      *             internal error.      * @throws InvalidDestinationException      *             if an invalid topic is specified.      * @throws InvalidSelectorException      *             if the message selector is invalid.      * @since 1.1      */
specifier|public
name|TopicSubscriber
name|createDurableSubscriber
parameter_list|(
name|Topic
name|topic
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|boolean
name|noLocal
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|connection
operator|.
name|checkClientIDWasManuallySpecified
argument_list|()
expr_stmt|;
return|return
operator|new
name|ActiveMQTopicSubscriber
argument_list|(
name|this
argument_list|,
name|getNextConsumerId
argument_list|()
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|topic
argument_list|)
argument_list|,
name|name
argument_list|,
name|messageSelector
argument_list|,
name|this
operator|.
name|connection
operator|.
name|getPrefetchPolicy
argument_list|()
operator|.
name|getDurableTopicPrefetch
argument_list|()
argument_list|,
name|noLocal
argument_list|,
literal|false
argument_list|,
name|asyncDispatch
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>QueueBrowser</CODE> object to peek at the messages on      * the specified queue.      *       * @param queue      *            the<CODE>queue</CODE> to access      * @return the Queue Browser      * @throws JMSException      *             if the session fails to create a browser due to some internal      *             error.      * @throws InvalidDestinationException      *             if an invalid destination is specified      * @since 1.1      */
specifier|public
name|QueueBrowser
name|createBrowser
parameter_list|(
name|Queue
name|queue
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|createBrowser
argument_list|(
name|queue
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>QueueBrowser</CODE> object to peek at the messages on      * the specified queue using a message selector.      *       * @param queue      *            the<CODE>queue</CODE> to access      * @param messageSelector      *            only messages with properties matching the message selector      *            expression are delivered. A value of null or an empty string      *            indicates that there is no message selector for the message      *            consumer.      * @return the Queue Browser      * @throws JMSException      *             if the session fails to create a browser due to some internal      *             error.      * @throws InvalidDestinationException      *             if an invalid destination is specified      * @throws InvalidSelectorException      *             if the message selector is invalid.      * @since 1.1      */
specifier|public
name|QueueBrowser
name|createBrowser
parameter_list|(
name|Queue
name|queue
parameter_list|,
name|String
name|messageSelector
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|new
name|ActiveMQQueueBrowser
argument_list|(
name|this
argument_list|,
name|getNextConsumerId
argument_list|()
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|queue
argument_list|)
argument_list|,
name|messageSelector
argument_list|,
name|asyncDispatch
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>TemporaryQueue</CODE> object. Its lifetime will be that      * of the<CODE>Connection</CODE> unless it is deleted earlier.      *       * @return a temporary queue identity      * @throws JMSException      *             if the session fails to create a temporary queue due to some      *             internal error.      * @since 1.1      */
specifier|public
name|TemporaryQueue
name|createTemporaryQueue
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|(
name|TemporaryQueue
operator|)
name|connection
operator|.
name|createTempDestination
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>TemporaryTopic</CODE> object. Its lifetime will be that      * of the<CODE>Connection</CODE> unless it is deleted earlier.      *       * @return a temporary topic identity      * @throws JMSException      *             if the session fails to create a temporary topic due to some      *             internal error.      * @since 1.1      */
specifier|public
name|TemporaryTopic
name|createTemporaryTopic
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|(
name|TemporaryTopic
operator|)
name|connection
operator|.
name|createTempDestination
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>QueueReceiver</CODE> object to receive messages from      * the specified queue.      *       * @param queue      *            the<CODE>Queue</CODE> to access      * @return      * @throws JMSException      *             if the session fails to create a receiver due to some      *             internal error.      * @throws JMSException      * @throws InvalidDestinationException      *             if an invalid queue is specified.      */
specifier|public
name|QueueReceiver
name|createReceiver
parameter_list|(
name|Queue
name|queue
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|createReceiver
argument_list|(
name|queue
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>QueueReceiver</CODE> object to receive messages from      * the specified queue using a message selector.      *       * @param queue      *            the<CODE>Queue</CODE> to access      * @param messageSelector      *            only messages with properties matching the message selector      *            expression are delivered. A value of null or an empty string      *            indicates that there is no message selector for the message      *            consumer.      * @return QueueReceiver      * @throws JMSException      *             if the session fails to create a receiver due to some      *             internal error.      * @throws InvalidDestinationException      *             if an invalid queue is specified.      * @throws InvalidSelectorException      *             if the message selector is invalid.      */
specifier|public
name|QueueReceiver
name|createReceiver
parameter_list|(
name|Queue
name|queue
parameter_list|,
name|String
name|messageSelector
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|new
name|ActiveMQQueueReceiver
argument_list|(
name|this
argument_list|,
name|getNextConsumerId
argument_list|()
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|queue
argument_list|)
argument_list|,
name|messageSelector
argument_list|,
name|this
operator|.
name|connection
operator|.
name|getPrefetchPolicy
argument_list|()
operator|.
name|getQueuePrefetch
argument_list|()
argument_list|,
name|asyncDispatch
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>QueueSender</CODE> object to send messages to the      * specified queue.      *       * @param queue      *            the<CODE>Queue</CODE> to access, or null if this is an      *            unidentified producer      * @return QueueSender      * @throws JMSException      *             if the session fails to create a sender due to some internal      *             error.      * @throws InvalidDestinationException      *             if an invalid queue is specified.      */
specifier|public
name|QueueSender
name|createSender
parameter_list|(
name|Queue
name|queue
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|new
name|ActiveMQQueueSender
argument_list|(
name|this
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|queue
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Creates a nondurable subscriber to the specified topic.<p/>      *<P>      * A client uses a<CODE>TopicSubscriber</CODE> object to receive messages      * that have been published to a topic.<p/>      *<P>      * Regular<CODE>TopicSubscriber</CODE> objects are not durable. They      * receive only messages that are published while they are active.<p/>      *<P>      * In some cases, a connection may both publish and subscribe to a topic.      * The subscriber<CODE>NoLocal</CODE> attribute allows a subscriber to      * inhibit the delivery of messages published by its own connection. The      * default value for this attribute is false.      *       * @param topic      *            the<CODE>Topic</CODE> to subscribe to      * @return TopicSubscriber      * @throws JMSException      *             if the session fails to create a subscriber due to some      *             internal error.      * @throws InvalidDestinationException      *             if an invalid topic is specified.      */
specifier|public
name|TopicSubscriber
name|createSubscriber
parameter_list|(
name|Topic
name|topic
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|createSubscriber
argument_list|(
name|topic
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a nondurable subscriber to the specified topic, using a message      * selector or specifying whether messages published by its own connection      * should be delivered to it.<p/>      *<P>      * A client uses a<CODE>TopicSubscriber</CODE> object to receive messages      * that have been published to a topic.<p/>      *<P>      * Regular<CODE>TopicSubscriber</CODE> objects are not durable. They      * receive only messages that are published while they are active.<p/>      *<P>      * Messages filtered out by a subscriber's message selector will never be      * delivered to the subscriber. From the subscriber's perspective, they do      * not exist.<p/>      *<P>      * In some cases, a connection may both publish and subscribe to a topic.      * The subscriber<CODE>NoLocal</CODE> attribute allows a subscriber to      * inhibit the delivery of messages published by its own connection. The      * default value for this attribute is false.      *       * @param topic      *            the<CODE>Topic</CODE> to subscribe to      * @param messageSelector      *            only messages with properties matching the message selector      *            expression are delivered. A value of null or an empty string      *            indicates that there is no message selector for the message      *            consumer.      * @param noLocal      *            if set, inhibits the delivery of messages published by its own      *            connection      * @return TopicSubscriber      * @throws JMSException      *             if the session fails to create a subscriber due to some      *             internal error.      * @throws InvalidDestinationException      *             if an invalid topic is specified.      * @throws InvalidSelectorException      *             if the message selector is invalid.      */
specifier|public
name|TopicSubscriber
name|createSubscriber
parameter_list|(
name|Topic
name|topic
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|boolean
name|noLocal
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|new
name|ActiveMQTopicSubscriber
argument_list|(
name|this
argument_list|,
name|getNextConsumerId
argument_list|()
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|topic
argument_list|)
argument_list|,
literal|null
argument_list|,
name|messageSelector
argument_list|,
name|this
operator|.
name|connection
operator|.
name|getPrefetchPolicy
argument_list|()
operator|.
name|getTopicPrefetch
argument_list|()
argument_list|,
name|noLocal
argument_list|,
literal|false
argument_list|,
name|asyncDispatch
argument_list|)
return|;
block|}
comment|/**      * Creates a publisher for the specified topic.<p/>      *<P>      * A client uses a<CODE>TopicPublisher</CODE> object to publish messages      * on a topic. Each time a client creates a<CODE>TopicPublisher</CODE> on      * a topic, it defines a new sequence of messages that have no ordering      * relationship with the messages it has previously sent.      *       * @param topic      *            the<CODE>Topic</CODE> to publish to, or null if this is an      *            unidentified producer      * @return TopicPublisher      * @throws JMSException      *             if the session fails to create a publisher due to some      *             internal error.      * @throws InvalidDestinationException      *             if an invalid topic is specified.      */
specifier|public
name|TopicPublisher
name|createPublisher
parameter_list|(
name|Topic
name|topic
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|new
name|ActiveMQTopicPublisher
argument_list|(
name|this
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|topic
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Unsubscribes a durable subscription that has been created by a client.      *<P>      * This method deletes the state being maintained on behalf of the      * subscriber by its provider.      *<P>      * It is erroneous for a client to delete a durable subscription while there      * is an active<CODE>MessageConsumer</CODE> or<CODE>TopicSubscriber</CODE>      * for the subscription, or while a consumed message is part of a pending      * transaction or has not been acknowledged in the session.      *       * @param name      *            the name used to identify this subscription      * @throws JMSException      *             if the session fails to unsubscribe to the durable      *             subscription due to some internal error.      * @throws InvalidDestinationException      *             if an invalid subscription name is specified.      * @since 1.1      */
specifier|public
name|void
name|unsubscribe
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|connection
operator|.
name|unsubscribe
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|dispatch
parameter_list|(
name|MessageDispatch
name|messageDispatch
parameter_list|)
block|{
try|try
block|{
name|executor
operator|.
name|execute
argument_list|(
name|messageDispatch
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|connection
operator|.
name|onAsyncException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Acknowledges all consumed messages of the session of this consumed      * message.      *<P>      * All consumed JMS messages support the<CODE>acknowledge</CODE> method      * for use when a client has specified that its JMS session's consumed      * messages are to be explicitly acknowledged. By invoking<CODE>acknowledge</CODE>      * on a consumed message, a client acknowledges all messages consumed by the      * session that the message was delivered to.      *<P>      * Calls to<CODE>acknowledge</CODE> are ignored for both transacted      * sessions and sessions specified to use implicit acknowledgement modes.      *<P>      * A client may individually acknowledge each message as it is consumed, or      * it may choose to acknowledge messages as an application-defined group      * (which is done by calling acknowledge on the last received message of the      * group, thereby acknowledging all messages consumed by the session.)      *<P>      * Messages that have been received but not acknowledged may be redelivered.      *       * @param caller -      *            the message calling acknowledge on the session      *       * @throws JMSException      *             if the JMS provider fails to acknowledge the messages due to      *             some internal error.      * @throws javax.jms.IllegalStateException      *             if this method is called on a closed session.      * @see javax.jms.Session#CLIENT_ACKNOWLEDGE      */
specifier|public
name|void
name|acknowledge
parameter_list|()
throws|throws
name|JMSException
block|{
for|for
control|(
name|Iterator
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|c
init|=
operator|(
name|ActiveMQMessageConsumer
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|c
operator|.
name|acknowledge
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Add a message consumer.      * @param id       *       * @param consumer -      *            message consumer.      * @throws JMSException      */
specifier|protected
name|void
name|addConsumer
parameter_list|(
name|ActiveMQMessageConsumer
name|consumer
parameter_list|)
throws|throws
name|JMSException
block|{
name|this
operator|.
name|consumers
operator|.
name|add
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
if|if
condition|(
name|consumer
operator|.
name|isDurableSubscriber
argument_list|()
condition|)
block|{
name|stats
operator|.
name|onCreateDurableSubscriber
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|connection
operator|.
name|addDispatcher
argument_list|(
name|consumer
operator|.
name|getConsumerId
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove the message consumer.      *       * @param consumer -      *            consumer to be removed.      * @throws JMSException      */
specifier|protected
name|void
name|removeConsumer
parameter_list|(
name|ActiveMQMessageConsumer
name|consumer
parameter_list|)
block|{
name|this
operator|.
name|connection
operator|.
name|removeDispatcher
argument_list|(
name|consumer
operator|.
name|getConsumerId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|consumer
operator|.
name|isDurableSubscriber
argument_list|()
condition|)
block|{
name|stats
operator|.
name|onRemoveDurableSubscriber
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|consumers
operator|.
name|remove
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds a message producer.      *       * @param producer -      *            message producer to be added.      * @throws JMSException      */
specifier|protected
name|void
name|addProducer
parameter_list|(
name|ActiveMQMessageProducer
name|producer
parameter_list|)
throws|throws
name|JMSException
block|{
name|this
operator|.
name|producers
operator|.
name|add
argument_list|(
name|producer
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes a message producer.      *       * @param producer -      *            message producer to be removed.      * @throws JMSException      */
specifier|protected
name|void
name|removeProducer
parameter_list|(
name|ActiveMQMessageProducer
name|producer
parameter_list|)
block|{
name|this
operator|.
name|producers
operator|.
name|remove
argument_list|(
name|producer
argument_list|)
expr_stmt|;
block|}
comment|/**      * Start this Session.      *       * @throws JMSException      */
specifier|protected
name|void
name|start
parameter_list|()
throws|throws
name|JMSException
block|{
name|started
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|c
init|=
operator|(
name|ActiveMQMessageConsumer
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|c
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|executor
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**      * Stops this session.      * @throws JMSException       */
specifier|protected
name|void
name|stop
parameter_list|()
throws|throws
name|JMSException
block|{
for|for
control|(
name|Iterator
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|c
init|=
operator|(
name|ActiveMQMessageConsumer
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|c
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|started
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|executor
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns the session id.      *       * @return value - session id.      */
specifier|protected
name|SessionId
name|getSessionId
parameter_list|()
block|{
return|return
name|info
operator|.
name|getSessionId
argument_list|()
return|;
block|}
comment|/**      * Sends the message for dispatch by the broker.      *       * @param producer -      *            message producer.      * @param destination -      *            message destination.      * @param message -      *            message to be sent.      * @param deliveryMode -      *            JMS messsage delivery mode.      * @param priority -      *            message priority.      * @param timeToLive -      *            message expiration.      * @param reuseMessageId -      *            true if the message id will be reused.      * @throws JMSException      */
specifier|protected
name|void
name|send
parameter_list|(
name|ActiveMQMessageProducer
name|producer
parameter_list|,
name|ActiveMQDestination
name|destination
parameter_list|,
name|Message
name|message
parameter_list|,
name|int
name|deliveryMode
parameter_list|,
name|int
name|priority
parameter_list|,
name|long
name|timeToLive
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|destination
operator|.
name|isTemporary
argument_list|()
operator|&&
name|connection
operator|.
name|isDeleted
argument_list|(
name|destination
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|JMSException
argument_list|(
literal|"Cannot publish to a deleted Destination: "
operator|+
name|destination
argument_list|)
throw|;
block|}
comment|// tell the Broker we are about to start a new transaction
name|doStartTransaction
argument_list|()
expr_stmt|;
name|TransactionId
name|txid
init|=
name|transactionContext
operator|.
name|getTransactionId
argument_list|()
decl_stmt|;
name|message
operator|.
name|setJMSDestination
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|message
operator|.
name|setJMSDeliveryMode
argument_list|(
name|deliveryMode
argument_list|)
expr_stmt|;
name|long
name|expiration
init|=
literal|0L
decl_stmt|;
if|if
condition|(
operator|!
name|producer
operator|.
name|getDisableMessageTimestamp
argument_list|()
condition|)
block|{
name|long
name|timeStamp
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|message
operator|.
name|setJMSTimestamp
argument_list|(
name|timeStamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeToLive
operator|>
literal|0
condition|)
block|{
name|expiration
operator|=
name|timeToLive
operator|+
name|timeStamp
expr_stmt|;
block|}
block|}
name|message
operator|.
name|setJMSExpiration
argument_list|(
name|expiration
argument_list|)
expr_stmt|;
name|message
operator|.
name|setJMSPriority
argument_list|(
name|priority
argument_list|)
expr_stmt|;
name|long
name|sequenceNumber
init|=
name|producer
operator|.
name|getMessageSequence
argument_list|()
decl_stmt|;
name|message
operator|.
name|setJMSRedelivered
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// transform to our own message format here
name|ActiveMQMessage
name|msg
init|=
name|ActiveMQMessageTransformation
operator|.
name|transformMessage
argument_list|(
name|message
argument_list|,
name|connection
argument_list|)
decl_stmt|;
comment|// Set the message id.
if|if
condition|(
name|msg
operator|==
name|message
condition|)
block|{
name|msg
operator|.
name|setMessageId
argument_list|(
operator|new
name|MessageId
argument_list|(
name|producer
operator|.
name|getProducerInfo
argument_list|()
operator|.
name|getProducerId
argument_list|()
argument_list|,
name|sequenceNumber
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|.
name|setMessageId
argument_list|(
operator|new
name|MessageId
argument_list|(
name|producer
operator|.
name|getProducerInfo
argument_list|()
operator|.
name|getProducerId
argument_list|()
argument_list|,
name|sequenceNumber
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|setJMSMessageID
argument_list|(
name|msg
operator|.
name|getMessageId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|msg
operator|.
name|setTransactionId
argument_list|(
name|txid
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|.
name|isCopyMessageOnSend
argument_list|()
condition|)
block|{
name|msg
operator|=
operator|(
name|ActiveMQMessage
operator|)
name|msg
operator|.
name|copy
argument_list|()
expr_stmt|;
block|}
name|msg
operator|.
name|onSend
argument_list|()
expr_stmt|;
name|msg
operator|.
name|setProducerId
argument_list|(
name|msg
operator|.
name|getMessageId
argument_list|()
operator|.
name|getProducerId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Sending message: "
operator|+
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msg
operator|.
name|isPersistent
argument_list|()
operator|||
name|connection
operator|.
name|isUseAsyncSend
argument_list|()
operator|||
name|txid
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|connection
operator|.
name|asyncSendPacket
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|connection
operator|.
name|syncSendPacket
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Send TransactionInfo to indicate transaction has started      *       * @throws JMSException      *             if some internal error occurs      */
specifier|protected
name|void
name|doStartTransaction
parameter_list|()
throws|throws
name|JMSException
block|{
if|if
condition|(
name|getTransacted
argument_list|()
operator|&&
operator|!
name|transactionContext
operator|.
name|isInXATransaction
argument_list|()
condition|)
block|{
name|transactionContext
operator|.
name|begin
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Checks whether the session has unconsumed messages.      *       * @return true - if there are unconsumed messages.      */
specifier|public
name|boolean
name|hasUncomsumedMessages
parameter_list|()
block|{
return|return
operator|!
name|executor
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**      * Checks whether the session uses transactions.      *       * @return true - if the session uses transactions.      */
specifier|public
name|boolean
name|isTransacted
parameter_list|()
block|{
return|return
name|this
operator|.
name|acknowledgementMode
operator|==
name|Session
operator|.
name|SESSION_TRANSACTED
return|;
block|}
comment|/**      * Checks whether the session used client acknowledgment.      *       * @return true - if the session uses client acknowledgment.      */
specifier|protected
name|boolean
name|isClientAcknowledge
parameter_list|()
block|{
return|return
name|this
operator|.
name|acknowledgementMode
operator|==
name|Session
operator|.
name|CLIENT_ACKNOWLEDGE
return|;
block|}
comment|/**      * Checks whether the session used auto acknowledgment.      *       * @return true - if the session uses client acknowledgment.      */
specifier|public
name|boolean
name|isAutoAcknowledge
parameter_list|()
block|{
return|return
name|acknowledgementMode
operator|==
name|Session
operator|.
name|AUTO_ACKNOWLEDGE
return|;
block|}
comment|/**      * Checks whether the session used dup ok acknowledgment.      *       * @return true - if the session uses client acknowledgment.      */
specifier|public
name|boolean
name|isDupsOkAcknowledge
parameter_list|()
block|{
return|return
name|acknowledgementMode
operator|==
name|Session
operator|.
name|DUPS_OK_ACKNOWLEDGE
return|;
block|}
comment|/**      * Returns the message delivery listener.      *       * @return deliveryListener - message delivery listener.      */
specifier|public
name|DeliveryListener
name|getDeliveryListener
parameter_list|()
block|{
return|return
name|deliveryListener
return|;
block|}
comment|/**      * Sets the message delivery listener.      *       * @param deliveryListener -      *            message delivery listener.      */
specifier|public
name|void
name|setDeliveryListener
parameter_list|(
name|DeliveryListener
name|deliveryListener
parameter_list|)
block|{
name|this
operator|.
name|deliveryListener
operator|=
name|deliveryListener
expr_stmt|;
block|}
comment|/**      * Returns the SessionInfo bean.      *       * @return info - SessionInfo bean.      * @throws JMSException      */
specifier|protected
name|SessionInfo
name|getSessionInfo
parameter_list|()
throws|throws
name|JMSException
block|{
name|SessionInfo
name|info
init|=
operator|new
name|SessionInfo
argument_list|(
name|connection
operator|.
name|getConnectionInfo
argument_list|()
argument_list|,
name|getSessionId
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|info
return|;
block|}
comment|/**      * Send the asynchronus command.      *       * @param command -      *            command to be executed.      * @throws JMSException      */
specifier|public
name|void
name|asyncSendPacket
parameter_list|(
name|Command
name|command
parameter_list|)
throws|throws
name|JMSException
block|{
name|connection
operator|.
name|asyncSendPacket
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
comment|/**      * Send the synchronus command.      *       * @param command -      *            command to be executed.      * @return Response      * @throws JMSException      */
specifier|public
name|Response
name|syncSendPacket
parameter_list|(
name|Command
name|command
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
name|connection
operator|.
name|syncSendPacket
argument_list|(
name|command
argument_list|)
return|;
block|}
specifier|public
name|long
name|getNextDeliveryId
parameter_list|()
block|{
return|return
name|deliveryIdGenerator
operator|.
name|getNextSequenceId
argument_list|()
return|;
block|}
specifier|public
name|void
name|redispatch
parameter_list|(
name|MessageDispatchChannel
name|unconsumedMessages
parameter_list|)
throws|throws
name|JMSException
block|{
name|List
name|c
init|=
name|unconsumedMessages
operator|.
name|removeAll
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|reverse
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|iter
init|=
name|c
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|MessageDispatch
name|md
init|=
operator|(
name|MessageDispatch
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|executor
operator|.
name|executeFirst
argument_list|(
name|md
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|started
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isAsyncDispatch
parameter_list|()
block|{
return|return
name|asyncDispatch
return|;
block|}
specifier|public
name|void
name|setAsyncDispatch
parameter_list|(
name|boolean
name|asyncDispatch
parameter_list|)
block|{
name|this
operator|.
name|asyncDispatch
operator|=
name|asyncDispatch
expr_stmt|;
block|}
specifier|public
name|List
name|getUnconsumedMessages
parameter_list|()
block|{
return|return
name|executor
operator|.
name|getUnconsumedMessages
argument_list|()
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ActiveMQSession {id="
operator|+
name|info
operator|.
name|getSessionId
argument_list|()
operator|+
literal|",started="
operator|+
name|started
operator|.
name|get
argument_list|()
operator|+
literal|"}"
return|;
block|}
block|}
end_class

end_unit

