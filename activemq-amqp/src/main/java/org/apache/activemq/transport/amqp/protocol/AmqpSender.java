begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|amqp
operator|.
name|protocol
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|amqp
operator|.
name|AmqpSupport
operator|.
name|toLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|broker
operator|.
name|region
operator|.
name|AbstractSubscription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQDestination
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ConsumerControl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ConsumerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ConsumerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ExceptionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|LocalTransactionId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|MessageAck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|MessageDispatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|MessagePull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|RemoveInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|RemoveSubscriptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|Response
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|TransactionId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|amqp
operator|.
name|AmqpProtocolConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|amqp
operator|.
name|ResponseHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|amqp
operator|.
name|message
operator|.
name|AutoOutboundTransformer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|amqp
operator|.
name|message
operator|.
name|EncodedMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|amqp
operator|.
name|message
operator|.
name|OutboundTransformer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|amqp
operator|.
name|messaging
operator|.
name|Accepted
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|amqp
operator|.
name|messaging
operator|.
name|Modified
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|amqp
operator|.
name|messaging
operator|.
name|Outcome
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|amqp
operator|.
name|messaging
operator|.
name|Rejected
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|amqp
operator|.
name|messaging
operator|.
name|Released
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|amqp
operator|.
name|transaction
operator|.
name|TransactionalState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|amqp
operator|.
name|transport
operator|.
name|AmqpError
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|amqp
operator|.
name|transport
operator|.
name|DeliveryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|amqp
operator|.
name|transport
operator|.
name|ErrorCondition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|amqp
operator|.
name|transport
operator|.
name|ReceiverSettleMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|amqp
operator|.
name|transport
operator|.
name|SenderSettleMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|engine
operator|.
name|Delivery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|engine
operator|.
name|Link
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|engine
operator|.
name|Sender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|fusesource
operator|.
name|hawtbuf
operator|.
name|Buffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * An AmqpSender wraps the AMQP Sender end of a link from the remote peer  * which holds the corresponding Receiver which receives messages transfered  * across the link from the Broker.  *  * An AmqpSender is in turn a message consumer subscribed to some destination  * on the broker.  As messages are dispatched to this sender that are sent on  * to the remote Receiver end of the lin.  */
end_comment

begin_class
specifier|public
class|class
name|AmqpSender
extends|extends
name|AmqpAbstractLink
argument_list|<
name|Sender
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AmqpSender
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|EMPTY_BYTE_ARRAY
init|=
operator|new
name|byte
index|[]
block|{}
decl_stmt|;
specifier|private
specifier|final
name|OutboundTransformer
name|outboundTransformer
init|=
operator|new
name|AutoOutboundTransformer
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|AmqpTransferTagGenerator
name|tagCache
init|=
operator|new
name|AmqpTransferTagGenerator
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|MessageDispatch
argument_list|>
name|outbound
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|Delivery
argument_list|>
name|dispatchedInTx
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ConsumerInfo
name|consumerInfo
decl_stmt|;
specifier|private
name|AbstractSubscription
name|subscription
decl_stmt|;
specifier|private
name|AtomicInteger
name|prefetchExtension
decl_stmt|;
specifier|private
name|int
name|currentCreditRequest
decl_stmt|;
specifier|private
name|int
name|logicalDeliveryCount
decl_stmt|;
comment|// echoes prefetch extension but from protons perspective
specifier|private
specifier|final
name|boolean
name|presettle
decl_stmt|;
specifier|private
name|boolean
name|draining
decl_stmt|;
specifier|private
name|long
name|lastDeliveredSequenceId
decl_stmt|;
specifier|private
name|Buffer
name|currentBuffer
decl_stmt|;
specifier|private
name|Delivery
name|currentDelivery
decl_stmt|;
comment|/**      * Creates a new AmqpSender instance that manages the given Sender      *      * @param session      *        the AmqpSession object that is the parent of this instance.      * @param endpoint      *        the AMQP Sender instance that this class manages.      * @param consumerInfo      *        the ConsumerInfo instance that holds configuration for this sender.      */
specifier|public
name|AmqpSender
parameter_list|(
name|AmqpSession
name|session
parameter_list|,
name|Sender
name|endpoint
parameter_list|,
name|ConsumerInfo
name|consumerInfo
parameter_list|)
block|{
name|super
argument_list|(
name|session
argument_list|,
name|endpoint
argument_list|)
expr_stmt|;
comment|// We don't support second so enforce it as First and let remote decide what to do
name|this
operator|.
name|endpoint
operator|.
name|setReceiverSettleMode
argument_list|(
name|ReceiverSettleMode
operator|.
name|FIRST
argument_list|)
expr_stmt|;
comment|// Match what the sender mode is
name|this
operator|.
name|endpoint
operator|.
name|setSenderSettleMode
argument_list|(
name|endpoint
operator|.
name|getRemoteSenderSettleMode
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|consumerInfo
operator|=
name|consumerInfo
expr_stmt|;
name|this
operator|.
name|presettle
operator|=
name|getEndpoint
argument_list|()
operator|.
name|getSenderSettleMode
argument_list|()
operator|==
name|SenderSettleMode
operator|.
name|SETTLED
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|open
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isClosed
argument_list|()
condition|)
block|{
name|session
operator|.
name|registerSender
argument_list|(
name|getConsumerId
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|subscription
operator|=
operator|(
name|AbstractSubscription
operator|)
name|session
operator|.
name|getConnection
argument_list|()
operator|.
name|lookupPrefetchSubscription
argument_list|(
name|consumerInfo
argument_list|)
expr_stmt|;
name|prefetchExtension
operator|=
name|subscription
operator|.
name|getPrefetchExtension
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|detach
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isClosed
argument_list|()
operator|&&
name|isOpened
argument_list|()
condition|)
block|{
name|RemoveInfo
name|removeCommand
init|=
operator|new
name|RemoveInfo
argument_list|(
name|getConsumerId
argument_list|()
argument_list|)
decl_stmt|;
name|removeCommand
operator|.
name|setLastDeliveredSequenceId
argument_list|(
name|lastDeliveredSequenceId
argument_list|)
expr_stmt|;
name|sendToActiveMQ
argument_list|(
name|removeCommand
argument_list|,
operator|new
name|ResponseHandler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onResponse
parameter_list|(
name|AmqpProtocolConverter
name|converter
parameter_list|,
name|Response
name|response
parameter_list|)
throws|throws
name|IOException
block|{
name|session
operator|.
name|unregisterSender
argument_list|(
name|getConsumerId
argument_list|()
argument_list|)
expr_stmt|;
name|AmqpSender
operator|.
name|super
operator|.
name|detach
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|super
operator|.
name|detach
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isClosed
argument_list|()
operator|&&
name|isOpened
argument_list|()
condition|)
block|{
name|RemoveInfo
name|removeCommand
init|=
operator|new
name|RemoveInfo
argument_list|(
name|getConsumerId
argument_list|()
argument_list|)
decl_stmt|;
name|removeCommand
operator|.
name|setLastDeliveredSequenceId
argument_list|(
name|lastDeliveredSequenceId
argument_list|)
expr_stmt|;
name|sendToActiveMQ
argument_list|(
name|removeCommand
argument_list|,
operator|new
name|ResponseHandler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onResponse
parameter_list|(
name|AmqpProtocolConverter
name|converter
parameter_list|,
name|Response
name|response
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|consumerInfo
operator|.
name|isDurable
argument_list|()
condition|)
block|{
name|RemoveSubscriptionInfo
name|rsi
init|=
operator|new
name|RemoveSubscriptionInfo
argument_list|()
decl_stmt|;
name|rsi
operator|.
name|setConnectionId
argument_list|(
name|session
operator|.
name|getConnection
argument_list|()
operator|.
name|getConnectionId
argument_list|()
argument_list|)
expr_stmt|;
name|rsi
operator|.
name|setSubscriptionName
argument_list|(
name|getEndpoint
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|rsi
operator|.
name|setClientId
argument_list|(
name|session
operator|.
name|getConnection
argument_list|()
operator|.
name|getClientId
argument_list|()
argument_list|)
expr_stmt|;
name|sendToActiveMQ
argument_list|(
name|rsi
argument_list|)
expr_stmt|;
block|}
name|session
operator|.
name|unregisterSender
argument_list|(
name|getConsumerId
argument_list|()
argument_list|)
expr_stmt|;
name|AmqpSender
operator|.
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|flow
parameter_list|()
throws|throws
name|Exception
block|{
name|Link
name|endpoint
init|=
name|getEndpoint
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Flow: draining={}, drain={} credit={}, currentCredit={}, senderDeliveryCount={} - Sub={}"
argument_list|,
name|draining
argument_list|,
name|endpoint
operator|.
name|getDrain
argument_list|()
argument_list|,
name|endpoint
operator|.
name|getCredit
argument_list|()
argument_list|,
name|currentCreditRequest
argument_list|,
name|logicalDeliveryCount
argument_list|,
name|subscription
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|endpointCredit
init|=
name|endpoint
operator|.
name|getCredit
argument_list|()
decl_stmt|;
if|if
condition|(
name|endpoint
operator|.
name|getDrain
argument_list|()
operator|&&
operator|!
name|draining
condition|)
block|{
if|if
condition|(
name|endpointCredit
operator|>
literal|0
condition|)
block|{
name|draining
operator|=
literal|true
expr_stmt|;
comment|// Now request dispatch of the drain amount, we request immediate
comment|// timeout and an completion message regardless so that we can know
comment|// when we should marked the link as drained.
name|MessagePull
name|pullRequest
init|=
operator|new
name|MessagePull
argument_list|()
decl_stmt|;
name|pullRequest
operator|.
name|setConsumerId
argument_list|(
name|getConsumerId
argument_list|()
argument_list|)
expr_stmt|;
name|pullRequest
operator|.
name|setDestination
argument_list|(
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
name|pullRequest
operator|.
name|setTimeout
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pullRequest
operator|.
name|setAlwaysSignalDone
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|pullRequest
operator|.
name|setQuantity
argument_list|(
name|endpointCredit
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Pull case -> consumer pull request quantity = {}"
argument_list|,
name|endpointCredit
argument_list|)
expr_stmt|;
name|sendToActiveMQ
argument_list|(
name|pullRequest
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Pull case -> sending any Queued messages and marking drained"
argument_list|)
expr_stmt|;
name|pumpOutbound
argument_list|()
expr_stmt|;
name|getEndpoint
argument_list|()
operator|.
name|drained
argument_list|()
expr_stmt|;
name|session
operator|.
name|pumpProtonToSocket
argument_list|()
expr_stmt|;
name|currentCreditRequest
operator|=
literal|0
expr_stmt|;
name|logicalDeliveryCount
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|endpointCredit
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|endpointCredit
operator|==
literal|0
operator|&&
name|currentCreditRequest
operator|!=
literal|0
condition|)
block|{
name|prefetchExtension
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|currentCreditRequest
operator|=
literal|0
expr_stmt|;
name|logicalDeliveryCount
operator|=
literal|0
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Flow: credit 0 for sub:"
operator|+
name|subscription
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|deltaToAdd
init|=
name|endpointCredit
decl_stmt|;
name|int
name|logicalCredit
init|=
name|currentCreditRequest
operator|-
name|logicalDeliveryCount
decl_stmt|;
if|if
condition|(
name|logicalCredit
operator|>
literal|0
condition|)
block|{
name|deltaToAdd
operator|-=
name|logicalCredit
expr_stmt|;
block|}
else|else
block|{
comment|// reset delivery counter - dispatch from broker concurrent with credit=0
comment|// flow can go negative
name|logicalDeliveryCount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|deltaToAdd
operator|>
literal|0
condition|)
block|{
name|currentCreditRequest
operator|=
name|prefetchExtension
operator|.
name|addAndGet
argument_list|(
name|deltaToAdd
argument_list|)
expr_stmt|;
name|subscription
operator|.
name|wakeupDestinationsForDispatch
argument_list|()
expr_stmt|;
comment|// force dispatch of matched/pending for topics (pending messages accumulate
comment|// in the sub and are dispatched on update of prefetch)
name|subscription
operator|.
name|setPrefetchSize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Flow: credit addition of {} for sub {}"
argument_list|,
name|deltaToAdd
argument_list|,
name|subscription
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|delivery
parameter_list|(
name|Delivery
name|delivery
parameter_list|)
throws|throws
name|Exception
block|{
name|MessageDispatch
name|md
init|=
operator|(
name|MessageDispatch
operator|)
name|delivery
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|DeliveryState
name|state
init|=
name|delivery
operator|.
name|getRemoteState
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|instanceof
name|TransactionalState
condition|)
block|{
name|TransactionalState
name|txState
init|=
operator|(
name|TransactionalState
operator|)
name|state
decl_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"onDelivery: TX delivery state = {}"
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|txState
operator|.
name|getOutcome
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Outcome
name|outcome
init|=
name|txState
operator|.
name|getOutcome
argument_list|()
decl_stmt|;
if|if
condition|(
name|outcome
operator|instanceof
name|Accepted
condition|)
block|{
name|TransactionId
name|txId
init|=
operator|new
name|LocalTransactionId
argument_list|(
name|session
operator|.
name|getConnection
argument_list|()
operator|.
name|getConnectionId
argument_list|()
argument_list|,
name|toLong
argument_list|(
name|txState
operator|.
name|getTxnId
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// Store the message sent in this TX we might need to re-send on rollback
comment|// and we need to ACK it on commit.
name|session
operator|.
name|enlist
argument_list|(
name|txId
argument_list|)
expr_stmt|;
name|dispatchedInTx
operator|.
name|addFirst
argument_list|(
name|delivery
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delivery
operator|.
name|remotelySettled
argument_list|()
condition|)
block|{
name|TransactionalState
name|txAccepted
init|=
operator|new
name|TransactionalState
argument_list|()
decl_stmt|;
name|txAccepted
operator|.
name|setOutcome
argument_list|(
name|Accepted
operator|.
name|getInstance
argument_list|()
argument_list|)
expr_stmt|;
name|txAccepted
operator|.
name|setTxnId
argument_list|(
name|txState
operator|.
name|getTxnId
argument_list|()
argument_list|)
expr_stmt|;
name|delivery
operator|.
name|disposition
argument_list|(
name|txAccepted
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|state
operator|instanceof
name|Accepted
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"onDelivery: accepted state = {}"
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delivery
operator|.
name|remotelySettled
argument_list|()
condition|)
block|{
name|delivery
operator|.
name|disposition
argument_list|(
operator|new
name|Accepted
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|settle
argument_list|(
name|delivery
argument_list|,
name|MessageAck
operator|.
name|INDIVIDUAL_ACK_TYPE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|instanceof
name|Rejected
condition|)
block|{
comment|// Rejection is a terminal outcome, we poison the message for dispatch to
comment|// the DLQ.  If a custom redelivery policy is used on the broker the message
comment|// can still be redelivered based on the configation of that policy.
name|LOG
operator|.
name|trace
argument_list|(
literal|"onDelivery: Rejected state = {}, message poisoned."
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|settle
argument_list|(
name|delivery
argument_list|,
name|MessageAck
operator|.
name|POSION_ACK_TYPE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|instanceof
name|Released
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"onDelivery: Released state = {}"
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|// re-deliver&& don't increment the counter.
name|settle
argument_list|(
name|delivery
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|instanceof
name|Modified
condition|)
block|{
name|Modified
name|modified
init|=
operator|(
name|Modified
operator|)
name|state
decl_stmt|;
if|if
condition|(
name|Boolean
operator|.
name|TRUE
operator|.
name|equals
argument_list|(
name|modified
operator|.
name|getDeliveryFailed
argument_list|()
argument_list|)
condition|)
block|{
comment|// increment delivery counter..
name|md
operator|.
name|setRedeliveryCounter
argument_list|(
name|md
operator|.
name|getRedeliveryCounter
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"onDelivery: Modified state = {}, delivery count now {}"
argument_list|,
name|state
argument_list|,
name|md
operator|.
name|getRedeliveryCounter
argument_list|()
argument_list|)
expr_stmt|;
name|byte
name|ackType
init|=
operator|-
literal|1
decl_stmt|;
name|Boolean
name|undeliverableHere
init|=
name|modified
operator|.
name|getUndeliverableHere
argument_list|()
decl_stmt|;
if|if
condition|(
name|undeliverableHere
operator|!=
literal|null
operator|&&
name|undeliverableHere
condition|)
block|{
comment|// receiver does not want the message..
comment|// perhaps we should DLQ it?
name|ackType
operator|=
name|MessageAck
operator|.
name|POSION_ACK_TYPE
expr_stmt|;
block|}
name|settle
argument_list|(
name|delivery
argument_list|,
name|ackType
argument_list|)
expr_stmt|;
block|}
block|}
name|pumpOutbound
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|commit
parameter_list|(
name|LocalTransactionId
name|txnId
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|dispatchedInTx
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
specifier|final
name|Delivery
name|delivery
range|:
name|dispatchedInTx
control|)
block|{
name|MessageDispatch
name|dispatch
init|=
operator|(
name|MessageDispatch
operator|)
name|delivery
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|MessageAck
name|pendingTxAck
init|=
operator|new
name|MessageAck
argument_list|(
name|dispatch
argument_list|,
name|MessageAck
operator|.
name|INDIVIDUAL_ACK_TYPE
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|pendingTxAck
operator|.
name|setFirstMessageId
argument_list|(
name|dispatch
operator|.
name|getMessage
argument_list|()
operator|.
name|getMessageId
argument_list|()
argument_list|)
expr_stmt|;
name|pendingTxAck
operator|.
name|setTransactionId
argument_list|(
name|txnId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Sending commit Ack to ActiveMQ: {}"
argument_list|,
name|pendingTxAck
argument_list|)
expr_stmt|;
name|sendToActiveMQ
argument_list|(
name|pendingTxAck
argument_list|,
operator|new
name|ResponseHandler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onResponse
parameter_list|(
name|AmqpProtocolConverter
name|converter
parameter_list|,
name|Response
name|response
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|response
operator|.
name|isException
argument_list|()
condition|)
block|{
name|Throwable
name|exception
init|=
operator|(
operator|(
name|ExceptionResponse
operator|)
name|response
operator|)
operator|.
name|getException
argument_list|()
decl_stmt|;
name|exception
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|getEndpoint
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|delivery
operator|.
name|settle
argument_list|()
expr_stmt|;
block|}
name|session
operator|.
name|pumpProtonToSocket
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|dispatchedInTx
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|rollback
parameter_list|(
name|LocalTransactionId
name|txnId
parameter_list|)
throws|throws
name|Exception
block|{
synchronized|synchronized
init|(
name|outbound
init|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Rolling back {} messages for redelivery. "
argument_list|,
name|dispatchedInTx
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Delivery
name|delivery
range|:
name|dispatchedInTx
control|)
block|{
comment|// Only settled deliveries should be re-dispatched, unsettled deliveries
comment|// remain acquired on the remote end and can be accepted again in a new
comment|// TX or released or rejected etc.
name|MessageDispatch
name|dispatch
init|=
operator|(
name|MessageDispatch
operator|)
name|delivery
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|dispatch
operator|.
name|getMessage
argument_list|()
operator|.
name|setTransactionId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|delivery
operator|.
name|remotelySettled
argument_list|()
condition|)
block|{
name|dispatch
operator|.
name|setRedeliveryCounter
argument_list|(
name|dispatch
operator|.
name|getRedeliveryCounter
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outbound
operator|.
name|addFirst
argument_list|(
name|dispatch
argument_list|)
expr_stmt|;
block|}
block|}
name|dispatchedInTx
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Event point for incoming message from ActiveMQ on this Sender's      * corresponding subscription.      *      * @param dispatch      *        the MessageDispatch to process and send across the link.      *      * @throws Exception if an error occurs while encoding the message for send.      */
specifier|public
name|void
name|onMessageDispatch
parameter_list|(
name|MessageDispatch
name|dispatch
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|isClosed
argument_list|()
condition|)
block|{
comment|// Lock to prevent stepping on TX redelivery
synchronized|synchronized
init|(
name|outbound
init|)
block|{
name|outbound
operator|.
name|addLast
argument_list|(
name|dispatch
argument_list|)
expr_stmt|;
block|}
name|pumpOutbound
argument_list|()
expr_stmt|;
name|session
operator|.
name|pumpProtonToSocket
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Called when the Broker sends a ConsumerControl command to the Consumer that      * this sender creates to obtain messages to dispatch via the sender for this      * end of the open link.      *      * @param control      *        The ConsumerControl command to process.      */
specifier|public
name|void
name|onConsumerControl
parameter_list|(
name|ConsumerControl
name|control
parameter_list|)
block|{
if|if
condition|(
name|control
operator|.
name|isClose
argument_list|()
condition|)
block|{
name|close
argument_list|(
operator|new
name|ErrorCondition
argument_list|(
name|AmqpError
operator|.
name|INTERNAL_ERROR
argument_list|,
literal|"Receiver forcably closed"
argument_list|)
argument_list|)
expr_stmt|;
name|session
operator|.
name|pumpProtonToSocket
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"AmqpSender {"
operator|+
name|getConsumerId
argument_list|()
operator|+
literal|"}"
return|;
block|}
comment|//----- Property getters and setters -------------------------------------//
specifier|public
name|ConsumerId
name|getConsumerId
parameter_list|()
block|{
return|return
name|consumerInfo
operator|.
name|getConsumerId
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|ActiveMQDestination
name|getDestination
parameter_list|()
block|{
return|return
name|consumerInfo
operator|.
name|getDestination
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setDestination
parameter_list|(
name|ActiveMQDestination
name|destination
parameter_list|)
block|{
name|consumerInfo
operator|.
name|setDestination
argument_list|(
name|destination
argument_list|)
expr_stmt|;
block|}
comment|//----- Internal Implementation ------------------------------------------//
specifier|public
name|void
name|pumpOutbound
parameter_list|()
throws|throws
name|Exception
block|{
while|while
condition|(
operator|!
name|isClosed
argument_list|()
condition|)
block|{
while|while
condition|(
name|currentBuffer
operator|!=
literal|null
condition|)
block|{
name|int
name|sent
init|=
name|getEndpoint
argument_list|()
operator|.
name|send
argument_list|(
name|currentBuffer
operator|.
name|data
argument_list|,
name|currentBuffer
operator|.
name|offset
argument_list|,
name|currentBuffer
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|sent
operator|>
literal|0
condition|)
block|{
name|currentBuffer
operator|.
name|moveHead
argument_list|(
name|sent
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentBuffer
operator|.
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|presettle
condition|)
block|{
name|settle
argument_list|(
name|currentDelivery
argument_list|,
name|MessageAck
operator|.
name|INDIVIDUAL_ACK_TYPE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getEndpoint
argument_list|()
operator|.
name|advance
argument_list|()
expr_stmt|;
block|}
name|currentBuffer
operator|=
literal|null
expr_stmt|;
name|currentDelivery
operator|=
literal|null
expr_stmt|;
name|logicalDeliveryCount
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
return|return;
block|}
block|}
if|if
condition|(
name|outbound
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
specifier|final
name|MessageDispatch
name|md
init|=
name|outbound
operator|.
name|removeFirst
argument_list|()
decl_stmt|;
try|try
block|{
name|ActiveMQMessage
name|temp
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|md
operator|.
name|getMessage
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|temp
operator|=
operator|(
name|ActiveMQMessage
operator|)
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|copy
argument_list|()
expr_stmt|;
block|}
specifier|final
name|ActiveMQMessage
name|jms
init|=
name|temp
decl_stmt|;
if|if
condition|(
name|jms
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Sender:[{}] browse done."
argument_list|,
name|getEndpoint
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// It's the end of browse signal in response to a MessagePull
name|getEndpoint
argument_list|()
operator|.
name|drained
argument_list|()
expr_stmt|;
name|draining
operator|=
literal|false
expr_stmt|;
name|currentCreditRequest
operator|=
literal|0
expr_stmt|;
name|logicalDeliveryCount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Sender:[{}] msgId={} draining={}, drain={}, credit={}, remoteCredit={}, queued={}"
argument_list|,
name|getEndpoint
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|jms
operator|.
name|getJMSMessageID
argument_list|()
argument_list|,
name|draining
argument_list|,
name|getEndpoint
argument_list|()
operator|.
name|getDrain
argument_list|()
argument_list|,
name|getEndpoint
argument_list|()
operator|.
name|getCredit
argument_list|()
argument_list|,
name|getEndpoint
argument_list|()
operator|.
name|getRemoteCredit
argument_list|()
argument_list|,
name|getEndpoint
argument_list|()
operator|.
name|getQueued
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|draining
operator|&&
name|getEndpoint
argument_list|()
operator|.
name|getCredit
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Sender:[{}] browse complete."
argument_list|,
name|getEndpoint
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|getEndpoint
argument_list|()
operator|.
name|drained
argument_list|()
expr_stmt|;
name|draining
operator|=
literal|false
expr_stmt|;
name|currentCreditRequest
operator|=
literal|0
expr_stmt|;
name|logicalDeliveryCount
operator|=
literal|0
expr_stmt|;
block|}
name|jms
operator|.
name|setRedeliveryCounter
argument_list|(
name|md
operator|.
name|getRedeliveryCounter
argument_list|()
argument_list|)
expr_stmt|;
name|jms
operator|.
name|setReadOnlyBody
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|EncodedMessage
name|amqp
init|=
name|outboundTransformer
operator|.
name|transform
argument_list|(
name|jms
argument_list|)
decl_stmt|;
if|if
condition|(
name|amqp
operator|!=
literal|null
operator|&&
name|amqp
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|currentBuffer
operator|=
operator|new
name|Buffer
argument_list|(
name|amqp
operator|.
name|getArray
argument_list|()
argument_list|,
name|amqp
operator|.
name|getArrayOffset
argument_list|()
argument_list|,
name|amqp
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|presettle
condition|)
block|{
name|currentDelivery
operator|=
name|getEndpoint
argument_list|()
operator|.
name|delivery
argument_list|(
name|EMPTY_BYTE_ARRAY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|byte
index|[]
name|tag
init|=
name|tagCache
operator|.
name|getNextTag
argument_list|()
decl_stmt|;
name|currentDelivery
operator|=
name|getEndpoint
argument_list|()
operator|.
name|delivery
argument_list|(
name|tag
argument_list|,
literal|0
argument_list|,
name|tag
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|currentDelivery
operator|.
name|setContext
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|currentDelivery
operator|.
name|setMessageFormat
argument_list|(
operator|(
name|int
operator|)
name|amqp
operator|.
name|getMessageFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: message could not be generated what now?
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error detected while flushing outbound messages: {}"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|settle
parameter_list|(
specifier|final
name|Delivery
name|delivery
parameter_list|,
specifier|final
name|int
name|ackType
parameter_list|)
throws|throws
name|Exception
block|{
name|byte
index|[]
name|tag
init|=
name|delivery
operator|.
name|getTag
argument_list|()
decl_stmt|;
if|if
condition|(
name|tag
operator|!=
literal|null
operator|&&
name|tag
operator|.
name|length
operator|>
literal|0
operator|&&
name|delivery
operator|.
name|remotelySettled
argument_list|()
condition|)
block|{
name|tagCache
operator|.
name|returnTag
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ackType
operator|==
operator|-
literal|1
condition|)
block|{
comment|// we are going to settle, but redeliver.. we we won't yet ack to ActiveMQ
name|delivery
operator|.
name|settle
argument_list|()
expr_stmt|;
name|onMessageDispatch
argument_list|(
operator|(
name|MessageDispatch
operator|)
name|delivery
operator|.
name|getContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MessageDispatch
name|md
init|=
operator|(
name|MessageDispatch
operator|)
name|delivery
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|lastDeliveredSequenceId
operator|=
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|getMessageId
argument_list|()
operator|.
name|getBrokerSequenceId
argument_list|()
expr_stmt|;
name|MessageAck
name|ack
init|=
operator|new
name|MessageAck
argument_list|()
decl_stmt|;
name|ack
operator|.
name|setConsumerId
argument_list|(
name|getConsumerId
argument_list|()
argument_list|)
expr_stmt|;
name|ack
operator|.
name|setFirstMessageId
argument_list|(
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|getMessageId
argument_list|()
argument_list|)
expr_stmt|;
name|ack
operator|.
name|setLastMessageId
argument_list|(
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|getMessageId
argument_list|()
argument_list|)
expr_stmt|;
name|ack
operator|.
name|setMessageCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ack
operator|.
name|setAckType
argument_list|(
operator|(
name|byte
operator|)
name|ackType
argument_list|)
expr_stmt|;
name|ack
operator|.
name|setDestination
argument_list|(
name|md
operator|.
name|getDestination
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"Sending Ack to ActiveMQ: {}"
argument_list|,
name|ack
argument_list|)
expr_stmt|;
name|sendToActiveMQ
argument_list|(
name|ack
argument_list|,
operator|new
name|ResponseHandler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onResponse
parameter_list|(
name|AmqpProtocolConverter
name|converter
parameter_list|,
name|Response
name|response
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|response
operator|.
name|isException
argument_list|()
condition|)
block|{
if|if
condition|(
name|response
operator|.
name|isException
argument_list|()
condition|)
block|{
name|Throwable
name|exception
init|=
operator|(
operator|(
name|ExceptionResponse
operator|)
name|response
operator|)
operator|.
name|getException
argument_list|()
decl_stmt|;
name|exception
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|getEndpoint
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|delivery
operator|.
name|settle
argument_list|()
expr_stmt|;
block|}
name|session
operator|.
name|pumpProtonToSocket
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

