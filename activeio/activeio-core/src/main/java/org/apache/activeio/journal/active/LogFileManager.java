begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Copyright 2005-2006 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|activeio
operator|.
name|journal
operator|.
name|active
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activeio
operator|.
name|adapter
operator|.
name|PacketOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activeio
operator|.
name|adapter
operator|.
name|PacketToInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activeio
operator|.
name|journal
operator|.
name|InvalidRecordLocationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activeio
operator|.
name|packet
operator|.
name|ByteArrayPacket
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activeio
operator|.
name|packet
operator|.
name|ByteBufferPacket
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activeio
operator|.
name|packet
operator|.
name|Packet
import|;
end_import

begin_import
import|import
name|edu
operator|.
name|emory
operator|.
name|mathcs
operator|.
name|backport
operator|.
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_comment
comment|/**  * Provides a logical view of many separate files as one single long log file.  * The separate files that compose the LogFile are Segments of the LogFile.  *<p/>This class is not thread safe.  *   * @version $Revision: 1.1 $  */
end_comment

begin_class
specifier|final
specifier|public
class|class
name|LogFileManager
block|{
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_LOGFILE_COUNT
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"org.apache.activeio.journal.active.DefaultLogFileCount"
argument_list|,
literal|""
operator|+
operator|(
literal|2
operator|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_LOGFILE_SIZE
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"org.apache.activeio.journal.active.DefaultLogFileSize"
argument_list|,
literal|""
operator|+
operator|(
literal|1024
operator|*
literal|1024
operator|*
literal|20
operator|)
argument_list|)
argument_list|)
decl_stmt|;
specifier|static
specifier|final
specifier|public
name|int
name|SERIALIZED_SIZE
init|=
literal|6
operator|+
name|Location
operator|.
name|SERIALIZED_SIZE
decl_stmt|;
specifier|static
specifier|final
specifier|public
name|byte
name|DATA_RECORD_TYPE
init|=
literal|1
decl_stmt|;
specifier|static
specifier|final
specifier|public
name|byte
name|MARK_RECORD_TYPE
init|=
literal|2
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|NumberFormat
name|onlineLogNameFormat
init|=
name|NumberFormat
operator|.
name|getNumberInstance
argument_list|()
decl_stmt|;
static|static
block|{
name|onlineLogNameFormat
operator|.
name|setMinimumIntegerDigits
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|onlineLogNameFormat
operator|.
name|setMaximumIntegerDigits
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|onlineLogNameFormat
operator|.
name|setGroupingUsed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|onlineLogNameFormat
operator|.
name|setParseIntegerOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|onlineLogNameFormat
operator|.
name|setMaximumFractionDigits
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|final
specifier|private
name|NumberFormat
name|archiveLogNameFormat
init|=
name|NumberFormat
operator|.
name|getNumberInstance
argument_list|()
decl_stmt|;
static|static
block|{
name|archiveLogNameFormat
operator|.
name|setMinimumIntegerDigits
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|archiveLogNameFormat
operator|.
name|setMaximumIntegerDigits
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|archiveLogNameFormat
operator|.
name|setGroupingUsed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|archiveLogNameFormat
operator|.
name|setParseIntegerOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|archiveLogNameFormat
operator|.
name|setMaximumFractionDigits
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Config
specifier|private
specifier|final
name|File
name|logDirectory
decl_stmt|;
specifier|private
specifier|final
name|int
name|initialLogFileSize
decl_stmt|;
specifier|private
specifier|final
name|int
name|onlineLogFileCount
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|activeLogFileCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Keeps track of the online log file.
specifier|private
name|LogFileNode
name|firstNode
decl_stmt|;
specifier|private
name|LogFileNode
name|firstActiveNode
decl_stmt|;
specifier|private
name|LogFileNode
name|firstInactiveNode
decl_stmt|;
specifier|private
name|LogFileNode
name|appendNode
decl_stmt|;
specifier|private
name|ControlFile
name|controlFile
decl_stmt|;
specifier|private
name|int
name|lastLogFileId
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|Location
name|lastMark
decl_stmt|;
specifier|private
name|boolean
name|disposed
decl_stmt|;
specifier|private
name|boolean
name|loadedFromCleanShutDown
decl_stmt|;
specifier|private
name|File
name|archiveDirectory
decl_stmt|;
name|HashMap
name|openArchivedLogs
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
specifier|public
name|LogFileManager
parameter_list|(
name|File
name|logDirectory
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|logDirectory
argument_list|,
name|DEFAULT_LOGFILE_COUNT
argument_list|,
name|DEFAULT_LOGFILE_SIZE
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|LogFileManager
parameter_list|(
name|File
name|logDirectory
parameter_list|,
name|int
name|onlineLogFileCount
parameter_list|,
name|int
name|initialLogFileSize
parameter_list|,
name|File
name|archiveDirectory
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|logDirectory
operator|=
name|logDirectory
expr_stmt|;
name|this
operator|.
name|onlineLogFileCount
operator|=
name|onlineLogFileCount
expr_stmt|;
name|this
operator|.
name|initialLogFileSize
operator|=
name|initialLogFileSize
expr_stmt|;
name|initialize
argument_list|(
name|onlineLogFileCount
argument_list|)
expr_stmt|;
name|this
operator|.
name|archiveDirectory
operator|=
name|archiveDirectory
expr_stmt|;
block|}
name|void
name|initialize
parameter_list|(
name|int
name|onlineLogFileCount
parameter_list|)
throws|throws
name|IOException
block|{
name|LogFileNode
name|logFiles
index|[]
init|=
operator|new
name|LogFileNode
index|[
name|onlineLogFileCount
index|]
decl_stmt|;
comment|// Create the log directory if it does not exist.
if|if
condition|(
operator|!
name|logDirectory
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|logDirectory
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not create directory: "
operator|+
name|logDirectory
argument_list|)
throw|;
block|}
block|}
comment|// Open the control file.
name|int
name|controlDataSize
init|=
name|SERIALIZED_SIZE
operator|+
operator|(
name|LogFileNode
operator|.
name|SERIALIZED_SIZE
operator|*
name|onlineLogFileCount
operator|)
decl_stmt|;
name|controlFile
operator|=
operator|new
name|ControlFile
argument_list|(
operator|new
name|File
argument_list|(
name|logDirectory
argument_list|,
literal|"control.dat"
argument_list|)
argument_list|,
name|controlDataSize
argument_list|)
expr_stmt|;
comment|// Make sure we are the only process using the control file.
name|controlFile
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Initialize the nodes.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|onlineLogFileCount
condition|;
name|i
operator|++
control|)
block|{
name|LogFile
name|file
init|=
operator|new
name|LogFile
argument_list|(
operator|new
name|File
argument_list|(
name|logDirectory
argument_list|,
literal|"log-"
operator|+
name|onlineLogNameFormat
operator|.
name|format
argument_list|(
name|i
argument_list|)
operator|+
literal|".dat"
argument_list|)
argument_list|,
name|initialLogFileSize
argument_list|)
decl_stmt|;
name|logFiles
index|[
name|i
index|]
operator|=
operator|new
name|LogFileNode
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|// Link the nodes together.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|onlineLogFileCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|onlineLogFileCount
operator|-
literal|1
operator|)
condition|)
block|{
name|logFiles
index|[
name|i
index|]
operator|.
name|setNext
argument_list|(
name|logFiles
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logFiles
index|[
name|i
index|]
operator|.
name|setNext
argument_list|(
name|logFiles
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|firstNode
operator|=
name|logFiles
index|[
literal|0
index|]
expr_stmt|;
name|loadState
argument_list|()
expr_stmt|;
comment|// Find the first active node
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|onlineLogFileCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|logFiles
index|[
name|i
index|]
operator|.
name|isActive
argument_list|()
condition|)
block|{
if|if
condition|(
name|firstActiveNode
operator|==
literal|null
operator|||
name|logFiles
index|[
name|i
index|]
operator|.
name|getId
argument_list|()
operator|<
name|firstActiveNode
operator|.
name|getId
argument_list|()
condition|)
block|{
name|firstActiveNode
operator|=
name|logFiles
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
comment|// None was active? activate one.
if|if
condition|(
name|firstActiveNode
operator|==
literal|null
condition|)
block|{
name|firstInactiveNode
operator|=
name|logFiles
index|[
literal|0
index|]
expr_stmt|;
name|activateNextLogFile
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Find the append log and the first inactive node
name|firstInactiveNode
operator|=
literal|null
expr_stmt|;
name|LogFileNode
name|log
init|=
name|firstActiveNode
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|log
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|firstInactiveNode
operator|=
name|log
expr_stmt|;
break|break;
block|}
else|else
block|{
name|appendNode
operator|=
name|log
expr_stmt|;
block|}
name|log
operator|=
name|log
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|log
operator|!=
name|firstActiveNode
condition|)
do|;
block|}
comment|// If we did not have a clean shut down then we have to check the state
comment|// of the append log.
if|if
condition|(
operator|!
name|this
operator|.
name|loadedFromCleanShutDown
condition|)
block|{
name|checkAppendLog
argument_list|()
expr_stmt|;
block|}
name|loadedFromCleanShutDown
operator|=
literal|false
expr_stmt|;
name|storeState
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|checkAppendLog
parameter_list|()
throws|throws
name|IOException
block|{
comment|// We are trying to get the true append offset and the last Mark that was written in
comment|// the append log.
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|Record
name|record
init|=
operator|new
name|Record
argument_list|()
decl_stmt|;
name|LogFile
name|logFile
init|=
name|appendNode
operator|.
name|getLogFile
argument_list|()
decl_stmt|;
name|Location
name|markLocation
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|logFile
operator|.
name|loadAndCheckRecord
argument_list|(
name|offset
argument_list|,
name|record
argument_list|)
condition|)
block|{
if|if
condition|(
name|record
operator|.
name|getLocation
argument_list|()
operator|.
name|getLogFileId
argument_list|()
operator|!=
name|appendNode
operator|.
name|getId
argument_list|()
operator|||
name|record
operator|.
name|getLocation
argument_list|()
operator|.
name|getLogFileOffset
argument_list|()
operator|!=
name|offset
condition|)
block|{
comment|// We must have run past the end of the append location.
break|break;
block|}
if|if
condition|(
name|record
operator|.
name|getRecordType
argument_list|()
operator|==
name|LogFileManager
operator|.
name|MARK_RECORD_TYPE
condition|)
block|{
name|markLocation
operator|=
name|record
operator|.
name|getLocation
argument_list|()
expr_stmt|;
block|}
name|offset
operator|+=
name|record
operator|.
name|getRecordLength
argument_list|()
expr_stmt|;
block|}
name|appendNode
operator|.
name|setAppendOffset
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|markLocation
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|Packet
name|packet
init|=
name|readPacket
argument_list|(
name|markLocation
argument_list|)
decl_stmt|;
name|markLocation
operator|=
name|Location
operator|.
name|readFromPacket
argument_list|(
name|packet
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidRecordLocationException
name|e
parameter_list|)
block|{
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|updateMark
argument_list|(
name|markLocation
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|storeState
parameter_list|()
throws|throws
name|IOException
block|{
name|Packet
name|controlData
init|=
name|controlFile
operator|.
name|getControlData
argument_list|()
decl_stmt|;
if|if
condition|(
name|controlData
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|DataOutput
name|data
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|PacketOutputStream
argument_list|(
name|controlData
argument_list|)
argument_list|)
decl_stmt|;
name|data
operator|.
name|writeInt
argument_list|(
name|lastLogFileId
argument_list|)
expr_stmt|;
name|data
operator|.
name|writeBoolean
argument_list|(
name|lastMark
operator|!=
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastMark
operator|!=
literal|null
condition|)
name|lastMark
operator|.
name|writeToDataOutput
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|.
name|writeBoolean
argument_list|(
name|loadedFromCleanShutDown
argument_list|)
expr_stmt|;
comment|// Load each node's state
name|LogFileNode
name|log
init|=
name|firstNode
decl_stmt|;
do|do
block|{
name|log
operator|.
name|writeExternal
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|log
operator|=
name|log
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|log
operator|!=
name|firstNode
condition|)
do|;
name|controlFile
operator|.
name|store
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|loadState
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|controlFile
operator|.
name|load
argument_list|()
condition|)
block|{
name|Packet
name|controlData
init|=
name|controlFile
operator|.
name|getControlData
argument_list|()
decl_stmt|;
if|if
condition|(
name|controlData
operator|.
name|remaining
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|DataInput
name|data
init|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|PacketToInputStream
argument_list|(
name|controlData
argument_list|)
argument_list|)
decl_stmt|;
name|lastLogFileId
operator|=
name|data
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|readBoolean
argument_list|()
condition|)
name|lastMark
operator|=
name|Location
operator|.
name|readFromDataInput
argument_list|(
name|data
argument_list|)
expr_stmt|;
else|else
name|lastMark
operator|=
literal|null
expr_stmt|;
name|loadedFromCleanShutDown
operator|=
name|data
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
comment|// Load each node's state
name|LogFileNode
name|log
init|=
name|firstNode
decl_stmt|;
do|do
block|{
name|log
operator|.
name|readExternal
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|log
operator|=
name|log
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|log
operator|!=
name|firstNode
condition|)
do|;
block|}
block|}
specifier|public
name|void
name|dispose
parameter_list|()
block|{
if|if
condition|(
name|disposed
condition|)
return|return;
name|this
operator|.
name|disposed
operator|=
literal|true
expr_stmt|;
try|try
block|{
comment|// Close all the opened log files.
name|LogFileNode
name|log
init|=
name|firstNode
decl_stmt|;
do|do
block|{
name|log
operator|.
name|getLogFile
argument_list|()
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|log
operator|=
name|log
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|log
operator|!=
name|firstNode
condition|)
do|;
name|loadedFromCleanShutDown
operator|=
literal|true
expr_stmt|;
name|storeState
argument_list|()
expr_stmt|;
name|controlFile
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{        	         }
block|}
specifier|private
name|int
name|getNextLogFileId
parameter_list|()
block|{
return|return
operator|++
name|lastLogFileId
return|;
block|}
comment|/**      * @param write      * @throws IOException      */
specifier|public
name|void
name|append
parameter_list|(
name|BatchedWrite
name|write
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|appendNode
operator|.
name|isActive
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Log file is not active.  Writes are not allowed"
argument_list|)
throw|;
if|if
condition|(
name|appendNode
operator|.
name|isReadOnly
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Log file has been marked Read Only.  Writes are not allowed"
argument_list|)
throw|;
comment|// Write and force the data to disk.
name|LogFile
name|logFile
init|=
name|appendNode
operator|.
name|getLogFile
argument_list|()
decl_stmt|;
name|ByteBuffer
name|buffer
init|=
operator|(
operator|(
name|ByteBufferPacket
operator|)
name|write
operator|.
name|getPacket
argument_list|()
operator|.
name|getAdapter
argument_list|(
name|ByteBufferPacket
operator|.
name|class
argument_list|)
operator|)
operator|.
name|getByteBuffer
argument_list|()
decl_stmt|;
name|int
name|size
init|=
name|buffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|logFile
operator|.
name|write
argument_list|(
name|appendNode
operator|.
name|getAppendOffset
argument_list|()
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
operator|.
name|getForce
argument_list|()
condition|)
name|logFile
operator|.
name|force
argument_list|()
expr_stmt|;
comment|// Update state
name|appendNode
operator|.
name|appended
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
operator|.
name|getMark
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|updateMark
argument_list|(
name|write
operator|.
name|getMark
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @param write      * @throws IOException      */
specifier|synchronized
specifier|private
name|void
name|updateMark
parameter_list|(
name|Location
name|mark
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If we wrote a mark we may need to deactivate some log files.
name|this
operator|.
name|lastMark
operator|=
name|mark
expr_stmt|;
while|while
condition|(
name|firstActiveNode
operator|!=
name|appendNode
condition|)
block|{
if|if
condition|(
name|firstActiveNode
operator|.
name|getId
argument_list|()
operator|<
name|lastMark
operator|.
name|getLogFileId
argument_list|()
condition|)
block|{
if|if
condition|(
name|archiveDirectory
operator|!=
literal|null
condition|)
block|{
name|File
name|file
init|=
name|getArchiveFile
argument_list|(
name|firstActiveNode
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|firstActiveNode
operator|.
name|getLogFile
argument_list|()
operator|.
name|copyTo
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|firstActiveNode
operator|.
name|deactivate
argument_list|()
expr_stmt|;
name|activeLogFileCount
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
if|if
condition|(
name|firstInactiveNode
operator|==
literal|null
condition|)
name|firstInactiveNode
operator|=
name|firstActiveNode
expr_stmt|;
name|firstActiveNode
operator|=
name|firstActiveNode
operator|.
name|getNextActive
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
specifier|private
name|File
name|getArchiveFile
parameter_list|(
name|int
name|logId
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|archiveDirectory
argument_list|,
literal|""
operator|+
name|archiveLogNameFormat
operator|.
name|format
argument_list|(
name|logId
argument_list|)
operator|+
literal|".log"
argument_list|)
return|;
block|}
name|RecordInfo
name|readRecordInfo
parameter_list|(
name|Location
name|location
parameter_list|)
throws|throws
name|IOException
throws|,
name|InvalidRecordLocationException
block|{
name|LogFile
name|logFile
decl_stmt|;
name|LogFileNode
name|logFileState
init|=
name|getLogFileWithId
argument_list|(
name|location
operator|.
name|getLogFileId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|logFileState
operator|!=
literal|null
condition|)
block|{
comment|// There can be no record at the append offset.
if|if
condition|(
name|logFileState
operator|.
name|getAppendOffset
argument_list|()
operator|==
name|location
operator|.
name|getLogFileOffset
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|InvalidRecordLocationException
argument_list|(
literal|"No record at ("
operator|+
name|location
operator|+
literal|") found.  Location past end of logged data."
argument_list|)
throw|;
block|}
name|logFile
operator|=
name|logFileState
operator|.
name|getLogFile
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|archiveDirectory
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|InvalidRecordLocationException
argument_list|(
literal|"Log file: "
operator|+
name|location
operator|.
name|getLogFileId
argument_list|()
operator|+
literal|" is not active."
argument_list|)
throw|;
block|}
else|else
block|{
name|logFile
operator|=
name|getArchivedLogFile
argument_list|(
name|location
operator|.
name|getLogFileId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Is there a record header at the seeked location?
try|try
block|{
name|Record
name|header
init|=
operator|new
name|Record
argument_list|()
decl_stmt|;
name|logFile
operator|.
name|readRecordHeader
argument_list|(
name|location
operator|.
name|getLogFileOffset
argument_list|()
argument_list|,
name|header
argument_list|)
expr_stmt|;
return|return
operator|new
name|RecordInfo
argument_list|(
name|location
argument_list|,
name|header
argument_list|,
name|logFileState
argument_list|,
name|logFile
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InvalidRecordLocationException
argument_list|(
literal|"No record at ("
operator|+
name|location
operator|+
literal|") found."
argument_list|)
throw|;
block|}
block|}
specifier|private
name|LogFile
name|getArchivedLogFile
parameter_list|(
name|int
name|logFileId
parameter_list|)
throws|throws
name|InvalidRecordLocationException
throws|,
name|IOException
block|{
name|Integer
name|key
init|=
operator|new
name|Integer
argument_list|(
name|logFileId
argument_list|)
decl_stmt|;
name|LogFile
name|rc
init|=
operator|(
name|LogFile
operator|)
name|openArchivedLogs
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|==
literal|null
condition|)
block|{
name|File
name|archiveFile
init|=
name|getArchiveFile
argument_list|(
name|logFileId
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|archiveFile
operator|.
name|canRead
argument_list|()
condition|)
throw|throw
operator|new
name|InvalidRecordLocationException
argument_list|(
literal|"Log file: "
operator|+
name|logFileId
operator|+
literal|" does not exist."
argument_list|)
throw|;
name|rc
operator|=
operator|new
name|LogFile
argument_list|(
name|archiveFile
argument_list|,
name|getInitialLogFileSize
argument_list|()
argument_list|)
expr_stmt|;
name|openArchivedLogs
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|rc
argument_list|)
expr_stmt|;
comment|// TODO: turn openArchivedLogs into LRU cache and close old log files.
block|}
return|return
name|rc
return|;
block|}
name|LogFileNode
name|getLogFileWithId
parameter_list|(
name|int
name|logFileId
parameter_list|)
throws|throws
name|InvalidRecordLocationException
block|{
for|for
control|(
name|LogFileNode
name|lf
init|=
name|firstActiveNode
init|;
name|lf
operator|!=
literal|null
condition|;
name|lf
operator|=
name|lf
operator|.
name|getNextActive
argument_list|()
control|)
block|{
if|if
condition|(
name|lf
operator|.
name|getId
argument_list|()
operator|==
name|logFileId
condition|)
block|{
return|return
name|lf
return|;
block|}
comment|// Short cut since id's will only increment
if|if
condition|(
name|logFileId
operator|<
name|lf
operator|.
name|getId
argument_list|()
condition|)
break|break;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * @param lastLocation      * @return      */
specifier|public
name|Location
name|getNextDataRecordLocation
parameter_list|(
name|Location
name|lastLocation
parameter_list|)
throws|throws
name|IOException
throws|,
name|InvalidRecordLocationException
block|{
name|RecordInfo
name|ri
init|=
name|readRecordInfo
argument_list|(
name|lastLocation
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|logFileId
init|=
name|ri
operator|.
name|getLocation
argument_list|()
operator|.
name|getLogFileId
argument_list|()
decl_stmt|;
name|int
name|offset
init|=
name|ri
operator|.
name|getNextLocation
argument_list|()
decl_stmt|;
comment|// Are we overflowing into next logFile?
if|if
condition|(
name|offset
operator|>=
name|ri
operator|.
name|getLogFileState
argument_list|()
operator|.
name|getAppendOffset
argument_list|()
condition|)
block|{
name|LogFileNode
name|nextActive
init|=
name|ri
operator|.
name|getLogFileState
argument_list|()
operator|.
name|getNextActive
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextActive
operator|==
literal|null
operator|||
name|nextActive
operator|.
name|getId
argument_list|()
operator|<=
name|ri
operator|.
name|getLogFileState
argument_list|()
operator|.
name|getId
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|logFileId
operator|=
name|nextActive
operator|.
name|getId
argument_list|()
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
try|try
block|{
name|ri
operator|=
name|readRecordInfo
argument_list|(
operator|new
name|Location
argument_list|(
name|logFileId
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidRecordLocationException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
comment|// Is the next record the right record type?
if|if
condition|(
name|ri
operator|.
name|getHeader
argument_list|()
operator|.
name|getRecordType
argument_list|()
operator|==
name|DATA_RECORD_TYPE
condition|)
block|{
return|return
name|ri
operator|.
name|getLocation
argument_list|()
return|;
block|}
comment|// No? go onto the next record.
block|}
block|}
comment|/**      * @param logFileIndex      * @param logFileOffset      * @return      * @throws IOException      * @throws InvalidRecordLocationException      */
specifier|public
name|Packet
name|readPacket
parameter_list|(
name|Location
name|location
parameter_list|)
throws|throws
name|IOException
throws|,
name|InvalidRecordLocationException
block|{
comment|// Is there a record header at the seeked location?
name|RecordInfo
name|recordInfo
init|=
name|readRecordInfo
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|byte
name|data
index|[]
init|=
operator|new
name|byte
index|[
name|recordInfo
operator|.
name|getHeader
argument_list|()
operator|.
name|getPayloadLength
argument_list|()
index|]
decl_stmt|;
name|LogFile
name|logFile
init|=
name|recordInfo
operator|.
name|getLogFile
argument_list|()
decl_stmt|;
name|logFile
operator|.
name|read
argument_list|(
name|recordInfo
operator|.
name|getDataOffset
argument_list|()
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|new
name|ByteArrayPacket
argument_list|(
name|data
argument_list|)
return|;
block|}
specifier|public
name|int
name|getInitialLogFileSize
parameter_list|()
block|{
return|return
name|initialLogFileSize
return|;
block|}
specifier|public
name|Location
name|getFirstActiveLogLocation
parameter_list|()
block|{
if|if
condition|(
name|firstActiveNode
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|firstActiveNode
operator|.
name|getAppendOffset
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|Location
argument_list|(
name|firstActiveNode
operator|.
name|getId
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|void
name|activateNextLogFile
parameter_list|()
throws|throws
name|IOException
block|{
comment|// The current append logFile becomes readonly
if|if
condition|(
name|appendNode
operator|!=
literal|null
condition|)
block|{
name|appendNode
operator|.
name|setReadOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|LogFileNode
name|next
init|=
name|firstInactiveNode
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|firstInactiveNode
operator|=
name|firstInactiveNode
operator|.
name|getNextInactive
argument_list|()
expr_stmt|;
name|next
operator|.
name|activate
argument_list|(
name|getNextLogFileId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstActiveNode
operator|==
literal|null
condition|)
block|{
name|firstActiveNode
operator|=
name|next
expr_stmt|;
block|}
block|}
name|activeLogFileCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|appendNode
operator|=
name|next
expr_stmt|;
name|storeState
argument_list|()
expr_stmt|;
block|}
comment|/**      * @return Returns the logDirectory.      */
specifier|public
name|File
name|getLogDirectory
parameter_list|()
block|{
return|return
name|logDirectory
return|;
block|}
comment|/**      * @return Returns the lastMark.      */
specifier|public
name|Location
name|getLastMarkedRecordLocation
parameter_list|()
block|{
return|return
name|lastMark
return|;
block|}
specifier|public
name|Location
name|getNextAppendLocation
parameter_list|()
block|{
return|return
operator|new
name|Location
argument_list|(
name|appendNode
operator|.
name|getId
argument_list|()
argument_list|,
name|appendNode
operator|.
name|getAppendOffset
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @return Returns the onlineLogFileCount.      */
specifier|public
name|int
name|getOnlineLogFileCount
parameter_list|()
block|{
return|return
name|onlineLogFileCount
return|;
block|}
specifier|public
name|boolean
name|isPastHalfActive
parameter_list|()
block|{
return|return
operator|(
name|onlineLogFileCount
operator|/
literal|2.f
operator|)
operator|<
name|activeLogFileCount
operator|.
name|get
argument_list|()
return|;
block|}
specifier|synchronized
specifier|public
name|Location
name|getFirstRecordLocationOfSecondActiveLogFile
parameter_list|()
block|{
return|return
name|firstActiveNode
operator|.
name|getNextActive
argument_list|()
operator|.
name|getFirstRecordLocation
argument_list|()
return|;
block|}
specifier|synchronized
specifier|public
name|boolean
name|canActivateNextLogFile
parameter_list|()
block|{
return|return
name|firstInactiveNode
operator|!=
literal|null
return|;
block|}
block|}
end_class

end_unit

