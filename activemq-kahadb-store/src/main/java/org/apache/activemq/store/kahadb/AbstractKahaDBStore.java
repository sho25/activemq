begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|store
operator|.
name|kahadb
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|broker
operator|.
name|LockableServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|broker
operator|.
name|Locker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|store
operator|.
name|SharedFileLocker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|store
operator|.
name|kahadb
operator|.
name|data
operator|.
name|KahaEntryType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|store
operator|.
name|kahadb
operator|.
name|data
operator|.
name|KahaTraceCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|store
operator|.
name|kahadb
operator|.
name|disk
operator|.
name|journal
operator|.
name|Journal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|store
operator|.
name|kahadb
operator|.
name|disk
operator|.
name|journal
operator|.
name|Location
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|store
operator|.
name|kahadb
operator|.
name|disk
operator|.
name|page
operator|.
name|PageFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|store
operator|.
name|kahadb
operator|.
name|disk
operator|.
name|page
operator|.
name|Transaction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|ByteSequence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|DataByteArrayInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|DataByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|IOHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|ServiceStopper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
specifier|abstract
class|class
name|AbstractKahaDBStore
extends|extends
name|LockableServiceSupport
block|{
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AbstractKahaDBStore
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|PROPERTY_LOG_SLOW_ACCESS_TIME
init|=
literal|"org.apache.activemq.store.kahadb.LOG_SLOW_ACCESS_TIME"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|LOG_SLOW_ACCESS_TIME
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
name|PROPERTY_LOG_SLOW_ACCESS_TIME
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|protected
name|File
name|directory
decl_stmt|;
specifier|protected
name|PageFile
name|pageFile
decl_stmt|;
specifier|protected
name|Journal
name|journal
decl_stmt|;
specifier|protected
name|AtomicLong
name|journalSize
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|protected
name|boolean
name|failIfDatabaseIsLocked
decl_stmt|;
specifier|protected
name|long
name|checkpointInterval
init|=
literal|5
operator|*
literal|1000
decl_stmt|;
specifier|protected
name|long
name|cleanupInterval
init|=
literal|30
operator|*
literal|1000
decl_stmt|;
specifier|protected
name|boolean
name|checkForCorruptJournalFiles
init|=
literal|false
decl_stmt|;
specifier|protected
name|boolean
name|checksumJournalFiles
init|=
literal|true
decl_stmt|;
specifier|protected
name|boolean
name|forceRecoverIndex
init|=
literal|false
decl_stmt|;
specifier|protected
name|int
name|journalMaxFileLength
init|=
name|Journal
operator|.
name|DEFAULT_MAX_FILE_LENGTH
decl_stmt|;
specifier|protected
name|int
name|journalMaxWriteBatchSize
init|=
name|Journal
operator|.
name|DEFAULT_MAX_WRITE_BATCH_SIZE
decl_stmt|;
specifier|protected
name|boolean
name|archiveCorruptedIndex
init|=
literal|false
decl_stmt|;
specifier|protected
name|boolean
name|enableIndexWriteAsync
init|=
literal|false
decl_stmt|;
specifier|protected
name|boolean
name|enableJournalDiskSyncs
init|=
literal|false
decl_stmt|;
specifier|protected
name|boolean
name|deleteAllJobs
init|=
literal|false
decl_stmt|;
specifier|protected
name|int
name|indexWriteBatchSize
init|=
name|PageFile
operator|.
name|DEFAULT_WRITE_BATCH_SIZE
decl_stmt|;
specifier|protected
name|boolean
name|useIndexLFRUEviction
init|=
literal|false
decl_stmt|;
specifier|protected
name|float
name|indexLFUEvictionFactor
init|=
literal|0.2f
decl_stmt|;
specifier|protected
name|boolean
name|ignoreMissingJournalfiles
init|=
literal|false
decl_stmt|;
specifier|protected
name|int
name|indexCacheSize
init|=
literal|1000
decl_stmt|;
specifier|protected
name|boolean
name|enableIndexDiskSyncs
init|=
literal|true
decl_stmt|;
specifier|protected
name|boolean
name|enableIndexRecoveryFile
init|=
literal|true
decl_stmt|;
specifier|protected
name|boolean
name|enableIndexPageCaching
init|=
literal|true
decl_stmt|;
specifier|protected
name|boolean
name|archiveDataLogs
decl_stmt|;
specifier|protected
name|boolean
name|purgeStoreOnStartup
decl_stmt|;
specifier|protected
name|File
name|directoryArchive
decl_stmt|;
specifier|protected
name|AtomicBoolean
name|opened
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
specifier|protected
name|Thread
name|checkpointThread
decl_stmt|;
specifier|protected
specifier|final
name|Object
name|checkpointThreadLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|protected
name|ReentrantReadWriteLock
name|checkpointLock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
specifier|protected
name|ReentrantReadWriteLock
name|indexLock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
comment|/**      * @return the name to give this store's PageFile instance.      */
specifier|protected
specifier|abstract
name|String
name|getPageFileName
parameter_list|()
function_decl|;
comment|/**      * @return the location of the data directory if no set by configuration.      */
specifier|protected
specifier|abstract
name|File
name|getDefaultDataDirectory
parameter_list|()
function_decl|;
comment|/**      * Loads the store from disk.      *      * Based on configuration this method can either load an existing store or it can purge      * an existing store and start in a clean state.      *      * @throws IOException if an error occurs during the load.      */
specifier|public
specifier|abstract
name|void
name|load
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**      * Unload the state of the Store to disk and shuts down all resources assigned to this      * KahaDB store implementation.      *      * @throws IOException if an error occurs during the store unload.      */
specifier|public
specifier|abstract
name|void
name|unload
parameter_list|()
throws|throws
name|IOException
function_decl|;
annotation|@
name|Override
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|Exception
block|{
name|this
operator|.
name|indexLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|getDirectory
argument_list|()
operator|==
literal|null
condition|)
block|{
name|setDirectory
argument_list|(
name|getDefaultDataDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|IOHelper
operator|.
name|mkdirs
argument_list|(
name|getDirectory
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|isPurgeStoreOnStartup
argument_list|()
condition|)
block|{
name|getJournal
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
name|getJournal
argument_list|()
operator|.
name|delete
argument_list|()
expr_stmt|;
name|getJournal
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|journal
operator|=
literal|null
expr_stmt|;
name|getPageFile
argument_list|()
operator|.
name|delete
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{} Persistence store purged."
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|setPurgeStoreOnStartup
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|load
argument_list|()
expr_stmt|;
name|store
argument_list|(
operator|new
name|KahaTraceCommand
argument_list|()
operator|.
name|setMessage
argument_list|(
literal|"LOADED "
operator|+
operator|new
name|Date
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|indexLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doStop
parameter_list|(
name|ServiceStopper
name|stopper
parameter_list|)
throws|throws
name|Exception
block|{
name|unload
argument_list|()
expr_stmt|;
block|}
specifier|public
name|PageFile
name|getPageFile
parameter_list|()
block|{
if|if
condition|(
name|pageFile
operator|==
literal|null
condition|)
block|{
name|pageFile
operator|=
name|createPageFile
argument_list|()
expr_stmt|;
block|}
return|return
name|pageFile
return|;
block|}
specifier|public
name|Journal
name|getJournal
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|journal
operator|==
literal|null
condition|)
block|{
name|journal
operator|=
name|createJournal
argument_list|()
expr_stmt|;
block|}
return|return
name|journal
return|;
block|}
specifier|public
name|File
name|getDirectory
parameter_list|()
block|{
return|return
name|directory
return|;
block|}
specifier|public
name|void
name|setDirectory
parameter_list|(
name|File
name|directory
parameter_list|)
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
block|}
specifier|public
name|boolean
name|isArchiveCorruptedIndex
parameter_list|()
block|{
return|return
name|archiveCorruptedIndex
return|;
block|}
specifier|public
name|void
name|setArchiveCorruptedIndex
parameter_list|(
name|boolean
name|archiveCorruptedIndex
parameter_list|)
block|{
name|this
operator|.
name|archiveCorruptedIndex
operator|=
name|archiveCorruptedIndex
expr_stmt|;
block|}
specifier|public
name|boolean
name|isFailIfDatabaseIsLocked
parameter_list|()
block|{
return|return
name|failIfDatabaseIsLocked
return|;
block|}
specifier|public
name|void
name|setFailIfDatabaseIsLocked
parameter_list|(
name|boolean
name|failIfDatabaseIsLocked
parameter_list|)
block|{
name|this
operator|.
name|failIfDatabaseIsLocked
operator|=
name|failIfDatabaseIsLocked
expr_stmt|;
block|}
specifier|public
name|boolean
name|isCheckForCorruptJournalFiles
parameter_list|()
block|{
return|return
name|checkForCorruptJournalFiles
return|;
block|}
specifier|public
name|void
name|setCheckForCorruptJournalFiles
parameter_list|(
name|boolean
name|checkForCorruptJournalFiles
parameter_list|)
block|{
name|this
operator|.
name|checkForCorruptJournalFiles
operator|=
name|checkForCorruptJournalFiles
expr_stmt|;
block|}
specifier|public
name|long
name|getCheckpointInterval
parameter_list|()
block|{
return|return
name|checkpointInterval
return|;
block|}
specifier|public
name|void
name|setCheckpointInterval
parameter_list|(
name|long
name|checkpointInterval
parameter_list|)
block|{
name|this
operator|.
name|checkpointInterval
operator|=
name|checkpointInterval
expr_stmt|;
block|}
specifier|public
name|long
name|getCleanupInterval
parameter_list|()
block|{
return|return
name|cleanupInterval
return|;
block|}
specifier|public
name|void
name|setCleanupInterval
parameter_list|(
name|long
name|cleanupInterval
parameter_list|)
block|{
name|this
operator|.
name|cleanupInterval
operator|=
name|cleanupInterval
expr_stmt|;
block|}
specifier|public
name|boolean
name|isChecksumJournalFiles
parameter_list|()
block|{
return|return
name|checksumJournalFiles
return|;
block|}
specifier|public
name|void
name|setChecksumJournalFiles
parameter_list|(
name|boolean
name|checksumJournalFiles
parameter_list|)
block|{
name|this
operator|.
name|checksumJournalFiles
operator|=
name|checksumJournalFiles
expr_stmt|;
block|}
specifier|public
name|boolean
name|isForceRecoverIndex
parameter_list|()
block|{
return|return
name|forceRecoverIndex
return|;
block|}
specifier|public
name|void
name|setForceRecoverIndex
parameter_list|(
name|boolean
name|forceRecoverIndex
parameter_list|)
block|{
name|this
operator|.
name|forceRecoverIndex
operator|=
name|forceRecoverIndex
expr_stmt|;
block|}
specifier|public
name|int
name|getJournalMaxFileLength
parameter_list|()
block|{
return|return
name|journalMaxFileLength
return|;
block|}
specifier|public
name|void
name|setJournalMaxFileLength
parameter_list|(
name|int
name|journalMaxFileLength
parameter_list|)
block|{
name|this
operator|.
name|journalMaxFileLength
operator|=
name|journalMaxFileLength
expr_stmt|;
block|}
specifier|public
name|int
name|getJournalMaxWriteBatchSize
parameter_list|()
block|{
return|return
name|journalMaxWriteBatchSize
return|;
block|}
specifier|public
name|void
name|setJournalMaxWriteBatchSize
parameter_list|(
name|int
name|journalMaxWriteBatchSize
parameter_list|)
block|{
name|this
operator|.
name|journalMaxWriteBatchSize
operator|=
name|journalMaxWriteBatchSize
expr_stmt|;
block|}
specifier|public
name|boolean
name|isEnableIndexWriteAsync
parameter_list|()
block|{
return|return
name|enableIndexWriteAsync
return|;
block|}
specifier|public
name|void
name|setEnableIndexWriteAsync
parameter_list|(
name|boolean
name|enableIndexWriteAsync
parameter_list|)
block|{
name|this
operator|.
name|enableIndexWriteAsync
operator|=
name|enableIndexWriteAsync
expr_stmt|;
block|}
specifier|public
name|boolean
name|isEnableJournalDiskSyncs
parameter_list|()
block|{
return|return
name|enableJournalDiskSyncs
return|;
block|}
specifier|public
name|void
name|setEnableJournalDiskSyncs
parameter_list|(
name|boolean
name|syncWrites
parameter_list|)
block|{
name|this
operator|.
name|enableJournalDiskSyncs
operator|=
name|syncWrites
expr_stmt|;
block|}
specifier|public
name|boolean
name|isDeleteAllJobs
parameter_list|()
block|{
return|return
name|deleteAllJobs
return|;
block|}
specifier|public
name|void
name|setDeleteAllJobs
parameter_list|(
name|boolean
name|deleteAllJobs
parameter_list|)
block|{
name|this
operator|.
name|deleteAllJobs
operator|=
name|deleteAllJobs
expr_stmt|;
block|}
comment|/**      * @return the archiveDataLogs      */
specifier|public
name|boolean
name|isArchiveDataLogs
parameter_list|()
block|{
return|return
name|this
operator|.
name|archiveDataLogs
return|;
block|}
comment|/**      * @param archiveDataLogs the archiveDataLogs to set      */
specifier|public
name|void
name|setArchiveDataLogs
parameter_list|(
name|boolean
name|archiveDataLogs
parameter_list|)
block|{
name|this
operator|.
name|archiveDataLogs
operator|=
name|archiveDataLogs
expr_stmt|;
block|}
comment|/**      * @return the directoryArchive      */
specifier|public
name|File
name|getDirectoryArchive
parameter_list|()
block|{
return|return
name|this
operator|.
name|directoryArchive
return|;
block|}
comment|/**      * @param directoryArchive the directoryArchive to set      */
specifier|public
name|void
name|setDirectoryArchive
parameter_list|(
name|File
name|directoryArchive
parameter_list|)
block|{
name|this
operator|.
name|directoryArchive
operator|=
name|directoryArchive
expr_stmt|;
block|}
specifier|public
name|int
name|getIndexCacheSize
parameter_list|()
block|{
return|return
name|indexCacheSize
return|;
block|}
specifier|public
name|void
name|setIndexCacheSize
parameter_list|(
name|int
name|indexCacheSize
parameter_list|)
block|{
name|this
operator|.
name|indexCacheSize
operator|=
name|indexCacheSize
expr_stmt|;
block|}
specifier|public
name|int
name|getIndexWriteBatchSize
parameter_list|()
block|{
return|return
name|indexWriteBatchSize
return|;
block|}
specifier|public
name|void
name|setIndexWriteBatchSize
parameter_list|(
name|int
name|indexWriteBatchSize
parameter_list|)
block|{
name|this
operator|.
name|indexWriteBatchSize
operator|=
name|indexWriteBatchSize
expr_stmt|;
block|}
specifier|public
name|boolean
name|isUseIndexLFRUEviction
parameter_list|()
block|{
return|return
name|useIndexLFRUEviction
return|;
block|}
specifier|public
name|void
name|setUseIndexLFRUEviction
parameter_list|(
name|boolean
name|useIndexLFRUEviction
parameter_list|)
block|{
name|this
operator|.
name|useIndexLFRUEviction
operator|=
name|useIndexLFRUEviction
expr_stmt|;
block|}
specifier|public
name|float
name|getIndexLFUEvictionFactor
parameter_list|()
block|{
return|return
name|indexLFUEvictionFactor
return|;
block|}
specifier|public
name|void
name|setIndexLFUEvictionFactor
parameter_list|(
name|float
name|indexLFUEvictionFactor
parameter_list|)
block|{
name|this
operator|.
name|indexLFUEvictionFactor
operator|=
name|indexLFUEvictionFactor
expr_stmt|;
block|}
specifier|public
name|boolean
name|isEnableIndexDiskSyncs
parameter_list|()
block|{
return|return
name|enableIndexDiskSyncs
return|;
block|}
specifier|public
name|void
name|setEnableIndexDiskSyncs
parameter_list|(
name|boolean
name|enableIndexDiskSyncs
parameter_list|)
block|{
name|this
operator|.
name|enableIndexDiskSyncs
operator|=
name|enableIndexDiskSyncs
expr_stmt|;
block|}
specifier|public
name|boolean
name|isEnableIndexRecoveryFile
parameter_list|()
block|{
return|return
name|enableIndexRecoveryFile
return|;
block|}
specifier|public
name|void
name|setEnableIndexRecoveryFile
parameter_list|(
name|boolean
name|enableIndexRecoveryFile
parameter_list|)
block|{
name|this
operator|.
name|enableIndexRecoveryFile
operator|=
name|enableIndexRecoveryFile
expr_stmt|;
block|}
specifier|public
name|boolean
name|isEnableIndexPageCaching
parameter_list|()
block|{
return|return
name|enableIndexPageCaching
return|;
block|}
specifier|public
name|void
name|setEnableIndexPageCaching
parameter_list|(
name|boolean
name|enableIndexPageCaching
parameter_list|)
block|{
name|this
operator|.
name|enableIndexPageCaching
operator|=
name|enableIndexPageCaching
expr_stmt|;
block|}
specifier|public
name|boolean
name|isPurgeStoreOnStartup
parameter_list|()
block|{
return|return
name|this
operator|.
name|purgeStoreOnStartup
return|;
block|}
specifier|public
name|void
name|setPurgeStoreOnStartup
parameter_list|(
name|boolean
name|purge
parameter_list|)
block|{
name|this
operator|.
name|purgeStoreOnStartup
operator|=
name|purge
expr_stmt|;
block|}
specifier|public
name|boolean
name|isIgnoreMissingJournalfiles
parameter_list|()
block|{
return|return
name|ignoreMissingJournalfiles
return|;
block|}
specifier|public
name|void
name|setIgnoreMissingJournalfiles
parameter_list|(
name|boolean
name|ignoreMissingJournalfiles
parameter_list|)
block|{
name|this
operator|.
name|ignoreMissingJournalfiles
operator|=
name|ignoreMissingJournalfiles
expr_stmt|;
block|}
specifier|public
name|long
name|size
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isStarted
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
try|try
block|{
return|return
name|journalSize
operator|.
name|get
argument_list|()
operator|+
name|pageFile
operator|.
name|getDiskSize
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|Locker
name|createDefaultLocker
parameter_list|()
throws|throws
name|IOException
block|{
name|SharedFileLocker
name|locker
init|=
operator|new
name|SharedFileLocker
argument_list|()
decl_stmt|;
name|locker
operator|.
name|setDirectory
argument_list|(
name|this
operator|.
name|getDirectory
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|locker
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|()
throws|throws
name|Exception
block|{     }
comment|/**      * Store a command in the Journal and process to update the Store index.      *      * @param command      *      The specific JournalCommand to store and process.      *      * @returns the Location where the data was written in the Journal.      *      * @throws IOException if an error occurs storing or processing the command.      */
specifier|public
name|Location
name|store
parameter_list|(
name|JournalCommand
argument_list|<
name|?
argument_list|>
name|command
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|store
argument_list|(
name|command
argument_list|,
name|isEnableIndexDiskSyncs
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Store a command in the Journal and process to update the Store index.      *      * @param command      *      The specific JournalCommand to store and process.      * @param sync      *      Should the store operation be done synchronously. (ignored if completion passed).      *      * @returns the Location where the data was written in the Journal.      *      * @throws IOException if an error occurs storing or processing the command.      */
specifier|public
name|Location
name|store
parameter_list|(
name|JournalCommand
argument_list|<
name|?
argument_list|>
name|command
parameter_list|,
name|boolean
name|sync
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|store
argument_list|(
name|command
argument_list|,
name|sync
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Store a command in the Journal and process to update the Store index.      *      * @param command      *      The specific JournalCommand to store and process.      * @param onJournalStoreComplete      *      The Runnable to call when the Journal write operation completes.      *      * @returns the Location where the data was written in the Journal.      *      * @throws IOException if an error occurs storing or processing the command.      */
specifier|public
name|Location
name|store
parameter_list|(
name|JournalCommand
argument_list|<
name|?
argument_list|>
name|command
parameter_list|,
name|Runnable
name|onJournalStoreComplete
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|store
argument_list|(
name|command
argument_list|,
name|isEnableIndexDiskSyncs
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|onJournalStoreComplete
argument_list|)
return|;
block|}
comment|/**      * Store a command in the Journal and process to update the Store index.      *      * @param command      *      The specific JournalCommand to store and process.      * @param sync      *      Should the store operation be done synchronously. (ignored if completion passed).      * @param before      *      The Runnable instance to execute before performing the store and process operation.      * @param after      *      The Runnable instance to execute after performing the store and process operation.      *      * @returns the Location where the data was written in the Journal.      *      * @throws IOException if an error occurs storing or processing the command.      */
specifier|public
name|Location
name|store
parameter_list|(
name|JournalCommand
argument_list|<
name|?
argument_list|>
name|command
parameter_list|,
name|boolean
name|sync
parameter_list|,
name|Runnable
name|before
parameter_list|,
name|Runnable
name|after
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|store
argument_list|(
name|command
argument_list|,
name|sync
argument_list|,
name|before
argument_list|,
name|after
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * All updated are are funneled through this method. The updates are converted to a      * JournalMessage which is logged to the journal and then the data from the JournalMessage      * is used to update the index just like it would be done during a recovery process.      *      * @param command      *      The specific JournalCommand to store and process.      * @param sync      *      Should the store operation be done synchronously. (ignored if completion passed).      * @param before      *      The Runnable instance to execute before performing the store and process operation.      * @param after      *      The Runnable instance to execute after performing the store and process operation.      * @param onJournalStoreComplete      *      Callback to be run when the journal write operation is complete.      *      * @returns the Location where the data was written in the Journal.      *      * @throws IOException if an error occurs storing or processing the command.      */
specifier|public
name|Location
name|store
parameter_list|(
name|JournalCommand
argument_list|<
name|?
argument_list|>
name|command
parameter_list|,
name|boolean
name|sync
parameter_list|,
name|Runnable
name|before
parameter_list|,
name|Runnable
name|after
parameter_list|,
name|Runnable
name|onJournalStoreComplete
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|before
operator|!=
literal|null
condition|)
block|{
name|before
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
name|ByteSequence
name|sequence
init|=
name|toByteSequence
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|Location
name|location
decl_stmt|;
name|checkpointLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|location
operator|=
name|onJournalStoreComplete
operator|==
literal|null
condition|?
name|journal
operator|.
name|write
argument_list|(
name|sequence
argument_list|,
name|sync
argument_list|)
else|:
name|journal
operator|.
name|write
argument_list|(
name|sequence
argument_list|,
name|onJournalStoreComplete
argument_list|)
expr_stmt|;
name|long
name|start2
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|process
argument_list|(
name|command
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|long
name|end
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG_SLOW_ACCESS_TIME
operator|>
literal|0
operator|&&
name|end
operator|-
name|start
operator|>
name|LOG_SLOW_ACCESS_TIME
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Slow KahaDB access: Journal append took: {} ms, Index update took {} ms"
argument_list|,
operator|(
name|start2
operator|-
name|start
operator|)
argument_list|,
operator|(
name|end
operator|-
name|start2
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|checkpointLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|after
operator|!=
literal|null
condition|)
block|{
name|after
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|checkpointThread
operator|!=
literal|null
operator|&&
operator|!
name|checkpointThread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|startCheckpoint
argument_list|()
expr_stmt|;
block|}
return|return
name|location
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"KahaDB failed to store to Journal"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|brokerService
operator|!=
literal|null
condition|)
block|{
name|brokerService
operator|.
name|handleIOException
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
throw|throw
name|ioe
throw|;
block|}
block|}
comment|/**      * Loads a previously stored JournalMessage      *      * @param location      *      The location of the journal command to read.      *      * @return a new un-marshaled JournalCommand instance.      *      * @throws IOException if an error occurs reading the stored command.      */
specifier|protected
name|JournalCommand
argument_list|<
name|?
argument_list|>
name|load
parameter_list|(
name|Location
name|location
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteSequence
name|data
init|=
name|journal
operator|.
name|read
argument_list|(
name|location
argument_list|)
decl_stmt|;
name|DataByteArrayInputStream
name|is
init|=
operator|new
name|DataByteArrayInputStream
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|byte
name|readByte
init|=
name|is
operator|.
name|readByte
argument_list|()
decl_stmt|;
name|KahaEntryType
name|type
init|=
name|KahaEntryType
operator|.
name|valueOf
argument_list|(
name|readByte
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{             }
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not load journal record. Invalid location: "
operator|+
name|location
argument_list|)
throw|;
block|}
name|JournalCommand
argument_list|<
name|?
argument_list|>
name|message
init|=
operator|(
name|JournalCommand
argument_list|<
name|?
argument_list|>
operator|)
name|type
operator|.
name|createMessage
argument_list|()
decl_stmt|;
name|message
operator|.
name|mergeFramed
argument_list|(
name|is
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Process a stored or recovered JournalCommand instance and update the DB Index with the      * state changes that this command produces.  This can be called either as a new DB operation      * or as a replay during recovery operations.      *      * @param command      *      The JournalCommand to process.      * @param location      *      The location in the Journal where the command was written or read from.      */
specifier|protected
specifier|abstract
name|void
name|process
parameter_list|(
name|JournalCommand
argument_list|<
name|?
argument_list|>
name|command
parameter_list|,
name|Location
name|location
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Perform a checkpoint operation with optional cleanup.      *      * Called by the checkpoint background thread periodically to initiate a checkpoint operation      * and if the cleanup flag is set a cleanup sweep should be done to allow for release of no      * longer needed journal log files etc.      *      * @param cleanup      *      Should the method do a simple checkpoint or also perform a journal cleanup.      *      * @throws IOException if an error occurs during the checkpoint operation.      */
specifier|protected
name|void
name|checkpointUpdate
parameter_list|(
specifier|final
name|boolean
name|cleanup
parameter_list|)
throws|throws
name|IOException
block|{
name|checkpointLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|indexLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|pageFile
operator|.
name|tx
argument_list|()
operator|.
name|execute
argument_list|(
operator|new
name|Transaction
operator|.
name|Closure
argument_list|<
name|IOException
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|execute
parameter_list|(
name|Transaction
name|tx
parameter_list|)
throws|throws
name|IOException
block|{
name|checkpointUpdate
argument_list|(
name|tx
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|indexLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|checkpointLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Perform the checkpoint update operation.  If the cleanup flag is true then the      * operation should also purge any unused Journal log files.      *      * This method must always be called with the checkpoint and index write locks held.      *      * @param tx      *      The TX under which to perform the checkpoint update.      * @param cleanup      *      Should the checkpoint also do unused Journal file cleanup.      *      * @throws IOException if an error occurs while performing the checkpoint.      */
specifier|protected
specifier|abstract
name|void
name|checkpointUpdate
parameter_list|(
name|Transaction
name|tx
parameter_list|,
name|boolean
name|cleanup
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Creates a new ByteSequence that represents the marshaled form of the given Journal Command.      *      * @param command      *      The Journal Command that should be marshaled to bytes for writing.      *      * @return the byte representation of the given journal command.      *      * @throws IOException if an error occurs while serializing the command.      */
specifier|protected
name|ByteSequence
name|toByteSequence
parameter_list|(
name|JournalCommand
argument_list|<
name|?
argument_list|>
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|size
init|=
name|data
operator|.
name|serializedSizeFramed
argument_list|()
decl_stmt|;
name|DataByteArrayOutputStream
name|os
init|=
operator|new
name|DataByteArrayOutputStream
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|os
operator|.
name|writeByte
argument_list|(
name|data
operator|.
name|type
argument_list|()
operator|.
name|getNumber
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|.
name|writeFramed
argument_list|(
name|os
argument_list|)
expr_stmt|;
return|return
name|os
operator|.
name|toByteSequence
argument_list|()
return|;
block|}
comment|/**      * Create the PageFile instance and configure it using the configuration options      * currently set.      *      * @return the newly created and configured PageFile instance.      */
specifier|protected
name|PageFile
name|createPageFile
parameter_list|()
block|{
name|PageFile
name|index
init|=
operator|new
name|PageFile
argument_list|(
name|getDirectory
argument_list|()
argument_list|,
name|getPageFileName
argument_list|()
argument_list|)
decl_stmt|;
name|index
operator|.
name|setEnableWriteThread
argument_list|(
name|isEnableIndexWriteAsync
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|.
name|setWriteBatchSize
argument_list|(
name|getIndexWriteBatchSize
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|.
name|setPageCacheSize
argument_list|(
name|getIndexCacheSize
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|.
name|setUseLFRUEviction
argument_list|(
name|isUseIndexLFRUEviction
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|.
name|setLFUEvictionFactor
argument_list|(
name|getIndexLFUEvictionFactor
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|.
name|setEnableDiskSyncs
argument_list|(
name|isEnableIndexDiskSyncs
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|.
name|setEnableRecoveryFile
argument_list|(
name|isEnableIndexRecoveryFile
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|.
name|setEnablePageCaching
argument_list|(
name|isEnableIndexPageCaching
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
comment|/**      * Create a new Journal instance and configure it using the currently set configuration      * options.  If an archive directory is configured than this method will attempt to create      * that directory if it does not already exist.      *      * @return the newly created an configured Journal instance.      *      * @throws IOException if an error occurs while creating the Journal object.      */
specifier|protected
name|Journal
name|createJournal
parameter_list|()
throws|throws
name|IOException
block|{
name|Journal
name|manager
init|=
operator|new
name|Journal
argument_list|()
decl_stmt|;
name|manager
operator|.
name|setDirectory
argument_list|(
name|getDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|setMaxFileLength
argument_list|(
name|getJournalMaxFileLength
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|setCheckForCorruptionOnStartup
argument_list|(
name|isCheckForCorruptJournalFiles
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|setChecksum
argument_list|(
name|isChecksumJournalFiles
argument_list|()
operator|||
name|isCheckForCorruptJournalFiles
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|setWriteBatchSize
argument_list|(
name|getJournalMaxWriteBatchSize
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|setArchiveDataLogs
argument_list|(
name|isArchiveDataLogs
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|setSizeAccumulator
argument_list|(
name|journalSize
argument_list|)
expr_stmt|;
name|manager
operator|.
name|setEnableAsyncDiskSync
argument_list|(
name|isEnableJournalDiskSyncs
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getDirectoryArchive
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|IOHelper
operator|.
name|mkdirs
argument_list|(
name|getDirectoryArchive
argument_list|()
argument_list|)
expr_stmt|;
name|manager
operator|.
name|setDirectoryArchive
argument_list|(
name|getDirectoryArchive
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|manager
return|;
block|}
comment|/**      * Starts the checkpoint Thread instance if not already running and not disabled      * by configuration.      */
specifier|protected
name|void
name|startCheckpoint
parameter_list|()
block|{
if|if
condition|(
name|checkpointInterval
operator|==
literal|0
operator|&&
name|cleanupInterval
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"periodic checkpoint/cleanup disabled, will ocurr on clean shutdown/restart"
argument_list|)
expr_stmt|;
return|return;
block|}
synchronized|synchronized
init|(
name|checkpointThreadLock
init|)
block|{
name|boolean
name|start
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|checkpointThread
operator|==
literal|null
condition|)
block|{
name|start
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|checkpointThread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|start
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"KahaDB: Recovering checkpoint thread after death"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|start
condition|)
block|{
name|checkpointThread
operator|=
operator|new
name|Thread
argument_list|(
literal|"ActiveMQ Journal Checkpoint Worker"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|long
name|lastCleanup
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|lastCheckpoint
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// Sleep for a short time so we can periodically check
comment|// to see if we need to exit this thread.
name|long
name|sleepTime
init|=
name|Math
operator|.
name|min
argument_list|(
name|checkpointInterval
operator|>
literal|0
condition|?
name|checkpointInterval
else|:
name|cleanupInterval
argument_list|,
literal|500
argument_list|)
decl_stmt|;
while|while
condition|(
name|opened
operator|.
name|get
argument_list|()
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|cleanupInterval
operator|>
literal|0
operator|&&
operator|(
name|now
operator|-
name|lastCleanup
operator|>=
name|cleanupInterval
operator|)
condition|)
block|{
name|checkpointCleanup
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|lastCleanup
operator|=
name|now
expr_stmt|;
name|lastCheckpoint
operator|=
name|now
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|checkpointInterval
operator|>
literal|0
operator|&&
operator|(
name|now
operator|-
name|lastCheckpoint
operator|>=
name|checkpointInterval
operator|)
condition|)
block|{
name|checkpointCleanup
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|lastCheckpoint
operator|=
name|now
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Looks like someone really wants us to exit this thread...
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Checkpoint failed"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|brokerService
operator|.
name|handleIOException
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
expr_stmt|;
name|checkpointThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|checkpointThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Called from the worker thread to start a checkpoint.      *      * This method ensure that the store is in an opened state and optionaly logs information      * related to slow store access times.      *      * @param cleanup      *      Should a cleanup of the journal occur during the checkpoint operation.      *      * @throws IOException if an error occurs during the checkpoint operation.      */
specifier|protected
name|void
name|checkpointCleanup
parameter_list|(
specifier|final
name|boolean
name|cleanup
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|start
decl_stmt|;
name|this
operator|.
name|indexLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|start
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|opened
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|indexLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|checkpointUpdate
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|long
name|end
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG_SLOW_ACCESS_TIME
operator|>
literal|0
operator|&&
name|end
operator|-
name|start
operator|>
name|LOG_SLOW_ACCESS_TIME
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Slow KahaDB access: cleanup took {}"
argument_list|,
operator|(
name|end
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

