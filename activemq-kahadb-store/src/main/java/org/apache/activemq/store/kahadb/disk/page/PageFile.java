begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|store
operator|.
name|kahadb
operator|.
name|disk
operator|.
name|page
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Adler32
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Checksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|store
operator|.
name|kahadb
operator|.
name|disk
operator|.
name|util
operator|.
name|Sequence
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|store
operator|.
name|kahadb
operator|.
name|disk
operator|.
name|util
operator|.
name|SequenceSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|DataByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|IOExceptionSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|IOHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|IntrospectionSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|LFUCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|LRUCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|RecoverableRandomAccessFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A PageFile provides you random access to fixed sized disk pages. This object is not thread safe and therefore access to it should  * be externally synchronized.  *<p/>  * The file has 3 parts:  * Metadata Space: 4k : Reserved metadata area. Used to store persistent config about the file.  * Recovery Buffer Space: Page Size * 1000 : This is a redo log used to prevent partial page writes from making the file inconsistent  * Page Space: The pages in the page file.  */
end_comment

begin_class
specifier|public
class|class
name|PageFile
block|{
specifier|private
specifier|static
specifier|final
name|String
name|PAGEFILE_SUFFIX
init|=
literal|".data"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|RECOVERY_FILE_SUFFIX
init|=
literal|".redo"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|FREE_FILE_SUFFIX
init|=
literal|".free"
decl_stmt|;
comment|// 4k Default page size.
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_PAGE_SIZE
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"defaultPageSize"
argument_list|,
literal|1024
operator|*
literal|4
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_WRITE_BATCH_SIZE
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"defaultWriteBatchSize"
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_PAGE_CACHE_SIZE
init|=
name|Integer
operator|.
name|getInteger
argument_list|(
literal|"defaultPageCacheSize"
argument_list|,
literal|100
argument_list|)
decl_stmt|;
empty_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|RECOVERY_FILE_HEADER_SIZE
init|=
literal|1024
operator|*
literal|4
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|PAGE_FILE_HEADER_SIZE
init|=
literal|1024
operator|*
literal|4
decl_stmt|;
comment|// Recovery header is (long offset)
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|PageFile
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// A PageFile will use a couple of files in this directory
specifier|private
specifier|final
name|File
name|directory
decl_stmt|;
comment|// And the file names in that directory will be based on this name.
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
comment|// File handle used for reading pages..
specifier|private
name|RecoverableRandomAccessFile
name|readFile
decl_stmt|;
comment|// File handle used for writing pages..
specifier|private
name|RecoverableRandomAccessFile
name|writeFile
decl_stmt|;
comment|// File handle used for writing pages..
specifier|private
name|RecoverableRandomAccessFile
name|recoveryFile
decl_stmt|;
comment|// The size of pages
specifier|private
name|int
name|pageSize
init|=
name|DEFAULT_PAGE_SIZE
decl_stmt|;
comment|// The minimum number of space allocated to the recovery file in number of pages.
specifier|private
name|int
name|recoveryFileMinPageCount
init|=
literal|1000
decl_stmt|;
comment|// The max size that we let the recovery file grow to.. ma exceed the max, but the file will get resize
comment|// to this max size as soon as  possible.
specifier|private
name|int
name|recoveryFileMaxPageCount
init|=
literal|10000
decl_stmt|;
comment|// The number of pages in the current recovery buffer
specifier|private
name|int
name|recoveryPageCount
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|loaded
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
comment|// The number of pages we are aiming to write every time we
comment|// write to disk.
name|int
name|writeBatchSize
init|=
name|DEFAULT_WRITE_BATCH_SIZE
decl_stmt|;
comment|// We keep a cache of pages recently used?
specifier|private
name|Map
argument_list|<
name|Long
argument_list|,
name|Page
argument_list|>
name|pageCache
decl_stmt|;
comment|// The cache of recently used pages.
specifier|private
name|boolean
name|enablePageCaching
init|=
literal|true
decl_stmt|;
comment|// How many pages will we keep in the cache?
specifier|private
name|int
name|pageCacheSize
init|=
name|DEFAULT_PAGE_CACHE_SIZE
decl_stmt|;
comment|// Should first log the page write to the recovery buffer? Avoids partial
comment|// page write failures..
specifier|private
name|boolean
name|enableRecoveryFile
init|=
literal|true
decl_stmt|;
comment|// Will we sync writes to disk. Ensures that data will not be lost after a checkpoint()
specifier|private
name|boolean
name|enableDiskSyncs
init|=
literal|true
decl_stmt|;
comment|// Will writes be done in an async thread?
specifier|private
name|boolean
name|enabledWriteThread
init|=
literal|false
decl_stmt|;
comment|// These are used if enableAsyncWrites==true
specifier|private
specifier|final
name|AtomicBoolean
name|stopWriter
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
specifier|private
name|Thread
name|writerThread
decl_stmt|;
specifier|private
name|CountDownLatch
name|checkpointLatch
decl_stmt|;
comment|// Keeps track of writes that are being written to disk.
specifier|private
specifier|final
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|PageWrite
argument_list|>
name|writes
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|PageWrite
argument_list|>
argument_list|()
decl_stmt|;
comment|// Keeps track of free pages.
specifier|private
specifier|final
name|AtomicLong
name|nextFreePageId
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
specifier|private
name|SequenceSet
name|freeList
init|=
operator|new
name|SequenceSet
argument_list|()
decl_stmt|;
specifier|private
name|AtomicReference
argument_list|<
name|SequenceSet
argument_list|>
name|recoveredFreeList
init|=
operator|new
name|AtomicReference
argument_list|<
name|SequenceSet
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|AtomicReference
argument_list|<
name|SequenceSet
argument_list|>
name|trackingFreeDuringRecovery
init|=
operator|new
name|AtomicReference
argument_list|<
name|SequenceSet
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|AtomicLong
name|nextTxid
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|// Persistent settings stored in the page file.
specifier|private
name|MetaData
name|metaData
decl_stmt|;
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|File
argument_list|>
name|tmpFilesForRemoval
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|useLFRUEviction
init|=
literal|false
decl_stmt|;
specifier|private
name|float
name|LFUEvictionFactor
init|=
literal|0.2f
decl_stmt|;
comment|/**      * Use to keep track of updated pages which have not yet been committed.      */
specifier|static
class|class
name|PageWrite
block|{
name|Page
name|page
decl_stmt|;
name|byte
index|[]
name|current
decl_stmt|;
name|byte
index|[]
name|diskBound
decl_stmt|;
name|long
name|currentLocation
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|diskBoundLocation
init|=
operator|-
literal|1
decl_stmt|;
name|File
name|tmpFile
decl_stmt|;
name|int
name|length
decl_stmt|;
specifier|public
name|PageWrite
parameter_list|(
name|Page
name|page
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
name|this
operator|.
name|page
operator|=
name|page
expr_stmt|;
name|current
operator|=
name|data
expr_stmt|;
block|}
specifier|public
name|PageWrite
parameter_list|(
name|Page
name|page
parameter_list|,
name|long
name|currentLocation
parameter_list|,
name|int
name|length
parameter_list|,
name|File
name|tmpFile
parameter_list|)
block|{
name|this
operator|.
name|page
operator|=
name|page
expr_stmt|;
name|this
operator|.
name|currentLocation
operator|=
name|currentLocation
expr_stmt|;
name|this
operator|.
name|tmpFile
operator|=
name|tmpFile
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
block|}
specifier|public
name|void
name|setCurrent
parameter_list|(
name|Page
name|page
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
name|this
operator|.
name|page
operator|=
name|page
expr_stmt|;
name|current
operator|=
name|data
expr_stmt|;
name|currentLocation
operator|=
operator|-
literal|1
expr_stmt|;
name|diskBoundLocation
operator|=
operator|-
literal|1
expr_stmt|;
block|}
specifier|public
name|void
name|setCurrentLocation
parameter_list|(
name|Page
name|page
parameter_list|,
name|long
name|location
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|this
operator|.
name|page
operator|=
name|page
expr_stmt|;
name|this
operator|.
name|currentLocation
operator|=
name|location
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|this
operator|.
name|current
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"[PageWrite:"
operator|+
name|page
operator|.
name|getPageId
argument_list|()
operator|+
literal|"-"
operator|+
name|page
operator|.
name|getType
argument_list|()
operator|+
literal|"]"
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Page
name|getPage
parameter_list|()
block|{
return|return
name|page
return|;
block|}
specifier|public
name|byte
index|[]
name|getDiskBound
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|diskBound
operator|==
literal|null
operator|&&
name|diskBoundLocation
operator|!=
operator|-
literal|1
condition|)
block|{
name|diskBound
operator|=
operator|new
name|byte
index|[
name|length
index|]
expr_stmt|;
try|try
init|(
name|RandomAccessFile
name|file
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|tmpFile
argument_list|,
literal|"r"
argument_list|)
init|)
block|{
name|file
operator|.
name|seek
argument_list|(
name|diskBoundLocation
argument_list|)
expr_stmt|;
name|file
operator|.
name|read
argument_list|(
name|diskBound
argument_list|)
expr_stmt|;
block|}
name|diskBoundLocation
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|diskBound
return|;
block|}
name|void
name|begin
parameter_list|()
block|{
if|if
condition|(
name|currentLocation
operator|!=
operator|-
literal|1
condition|)
block|{
name|diskBoundLocation
operator|=
name|currentLocation
expr_stmt|;
block|}
else|else
block|{
name|diskBound
operator|=
name|current
expr_stmt|;
block|}
name|current
operator|=
literal|null
expr_stmt|;
name|currentLocation
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/**          * @return true if there is no pending writes to do.          */
name|boolean
name|done
parameter_list|()
block|{
name|diskBoundLocation
operator|=
operator|-
literal|1
expr_stmt|;
name|diskBound
operator|=
literal|null
expr_stmt|;
return|return
name|current
operator|==
literal|null
operator|||
name|currentLocation
operator|==
operator|-
literal|1
return|;
block|}
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|diskBound
operator|==
literal|null
operator|&&
name|diskBoundLocation
operator|==
operator|-
literal|1
operator|&&
name|current
operator|==
literal|null
operator|&&
name|currentLocation
operator|==
operator|-
literal|1
return|;
block|}
block|}
comment|/**      * The MetaData object hold the persistent data associated with a PageFile object.      */
specifier|public
specifier|static
class|class
name|MetaData
block|{
name|String
name|fileType
decl_stmt|;
name|String
name|fileTypeVersion
decl_stmt|;
name|long
name|metaDataTxId
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|pageSize
decl_stmt|;
name|boolean
name|cleanShutdown
decl_stmt|;
name|long
name|lastTxId
decl_stmt|;
name|long
name|freePages
decl_stmt|;
specifier|public
name|String
name|getFileType
parameter_list|()
block|{
return|return
name|fileType
return|;
block|}
specifier|public
name|void
name|setFileType
parameter_list|(
name|String
name|fileType
parameter_list|)
block|{
name|this
operator|.
name|fileType
operator|=
name|fileType
expr_stmt|;
block|}
specifier|public
name|String
name|getFileTypeVersion
parameter_list|()
block|{
return|return
name|fileTypeVersion
return|;
block|}
specifier|public
name|void
name|setFileTypeVersion
parameter_list|(
name|String
name|version
parameter_list|)
block|{
name|this
operator|.
name|fileTypeVersion
operator|=
name|version
expr_stmt|;
block|}
specifier|public
name|long
name|getMetaDataTxId
parameter_list|()
block|{
return|return
name|metaDataTxId
return|;
block|}
specifier|public
name|void
name|setMetaDataTxId
parameter_list|(
name|long
name|metaDataTxId
parameter_list|)
block|{
name|this
operator|.
name|metaDataTxId
operator|=
name|metaDataTxId
expr_stmt|;
block|}
specifier|public
name|int
name|getPageSize
parameter_list|()
block|{
return|return
name|pageSize
return|;
block|}
specifier|public
name|void
name|setPageSize
parameter_list|(
name|int
name|pageSize
parameter_list|)
block|{
name|this
operator|.
name|pageSize
operator|=
name|pageSize
expr_stmt|;
block|}
specifier|public
name|boolean
name|isCleanShutdown
parameter_list|()
block|{
return|return
name|cleanShutdown
return|;
block|}
specifier|public
name|void
name|setCleanShutdown
parameter_list|(
name|boolean
name|cleanShutdown
parameter_list|)
block|{
name|this
operator|.
name|cleanShutdown
operator|=
name|cleanShutdown
expr_stmt|;
block|}
specifier|public
name|long
name|getLastTxId
parameter_list|()
block|{
return|return
name|lastTxId
return|;
block|}
specifier|public
name|void
name|setLastTxId
parameter_list|(
name|long
name|lastTxId
parameter_list|)
block|{
name|this
operator|.
name|lastTxId
operator|=
name|lastTxId
expr_stmt|;
block|}
specifier|public
name|long
name|getFreePages
parameter_list|()
block|{
return|return
name|freePages
return|;
block|}
specifier|public
name|void
name|setFreePages
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|this
operator|.
name|freePages
operator|=
name|value
expr_stmt|;
block|}
block|}
specifier|public
name|Transaction
name|tx
parameter_list|()
block|{
name|assertLoaded
argument_list|()
expr_stmt|;
return|return
operator|new
name|Transaction
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Creates a PageFile in the specified directory who's data files are named by name.      */
specifier|public
name|PageFile
parameter_list|(
name|File
name|directory
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|directory
operator|=
name|directory
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
comment|/**      * Deletes the files used by the PageFile object.  This method can only be used when this object is not loaded.      *      * @throws IOException           if the files cannot be deleted.      * @throws IllegalStateException if this PageFile is loaded      */
specifier|public
name|void
name|delete
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|loaded
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot delete page file data when the page file is loaded"
argument_list|)
throw|;
block|}
name|delete
argument_list|(
name|getMainPageFile
argument_list|()
argument_list|)
expr_stmt|;
name|delete
argument_list|(
name|getFreeFile
argument_list|()
argument_list|)
expr_stmt|;
name|delete
argument_list|(
name|getRecoveryFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|archive
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|loaded
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot delete page file data when the page file is loaded"
argument_list|)
throw|;
block|}
name|long
name|timestamp
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|archive
argument_list|(
name|getMainPageFile
argument_list|()
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|timestamp
argument_list|)
argument_list|)
expr_stmt|;
name|archive
argument_list|(
name|getFreeFile
argument_list|()
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|timestamp
argument_list|)
argument_list|)
expr_stmt|;
name|archive
argument_list|(
name|getRecoveryFile
argument_list|()
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|timestamp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param file      * @throws IOException      */
specifier|private
name|void
name|delete
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|file
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not delete: "
operator|+
name|file
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|archive
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|suffix
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|File
name|archive
init|=
operator|new
name|File
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
operator|+
literal|"-"
operator|+
name|suffix
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|renameTo
argument_list|(
name|archive
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not archive: "
operator|+
name|file
operator|.
name|getPath
argument_list|()
operator|+
literal|" to "
operator|+
name|file
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Loads the page file so that it can be accessed for read/write purposes.  This allocates OS resources.  If this is the      * first time the page file is loaded, then this creates the page file in the file system.      *      * @throws IOException           If the page file cannot be loaded. This could be cause the existing page file is corrupt is a bad version or if      *                               there was a disk error.      * @throws IllegalStateException If the page file was already loaded.      */
specifier|public
name|void
name|load
parameter_list|()
throws|throws
name|IOException
throws|,
name|IllegalStateException
block|{
if|if
condition|(
name|loaded
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
if|if
condition|(
name|enablePageCaching
condition|)
block|{
if|if
condition|(
name|isUseLFRUEviction
argument_list|()
condition|)
block|{
name|pageCache
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|LFUCache
argument_list|<
name|Long
argument_list|,
name|Page
argument_list|>
argument_list|(
name|pageCacheSize
argument_list|,
name|getLFUEvictionFactor
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pageCache
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|LRUCache
argument_list|<
name|Long
argument_list|,
name|Page
argument_list|>
argument_list|(
name|pageCacheSize
argument_list|,
name|pageCacheSize
argument_list|,
literal|0.75f
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|File
name|file
init|=
name|getMainPageFile
argument_list|()
decl_stmt|;
name|IOHelper
operator|.
name|mkdirs
argument_list|(
name|file
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
name|writeFile
operator|=
operator|new
name|RecoverableRandomAccessFile
argument_list|(
name|file
argument_list|,
literal|"rw"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|readFile
operator|=
operator|new
name|RecoverableRandomAccessFile
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|readFile
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Load the page size setting cause that can't change once the file is created.
name|loadMetaData
argument_list|()
expr_stmt|;
name|pageSize
operator|=
name|metaData
operator|.
name|getPageSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Store the page size setting cause that can't change once the file is created.
name|metaData
operator|=
operator|new
name|MetaData
argument_list|()
expr_stmt|;
name|metaData
operator|.
name|setFileType
argument_list|(
name|PageFile
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|setFileTypeVersion
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|setPageSize
argument_list|(
name|getPageSize
argument_list|()
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|setCleanShutdown
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|setFreePages
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|setLastTxId
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|storeMetaData
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|enableRecoveryFile
condition|)
block|{
name|recoveryFile
operator|=
operator|new
name|RecoverableRandomAccessFile
argument_list|(
name|getRecoveryFile
argument_list|()
argument_list|,
literal|"rw"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metaData
operator|.
name|isCleanShutdown
argument_list|()
condition|)
block|{
name|nextTxid
operator|.
name|set
argument_list|(
name|metaData
operator|.
name|getLastTxId
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|metaData
operator|.
name|getFreePages
argument_list|()
operator|>
literal|0
condition|)
block|{
name|loadFreeList
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|toString
argument_list|()
operator|+
literal|", Recovering page file..."
argument_list|)
expr_stmt|;
name|nextTxid
operator|.
name|set
argument_list|(
name|redoRecoveryUpdates
argument_list|()
argument_list|)
expr_stmt|;
name|trackingFreeDuringRecovery
operator|.
name|set
argument_list|(
operator|new
name|SequenceSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writeFile
operator|.
name|length
argument_list|()
operator|<
name|PAGE_FILE_HEADER_SIZE
condition|)
block|{
name|writeFile
operator|.
name|setLength
argument_list|(
name|PAGE_FILE_HEADER_SIZE
argument_list|)
expr_stmt|;
block|}
name|nextFreePageId
operator|.
name|set
argument_list|(
operator|(
name|writeFile
operator|.
name|length
argument_list|()
operator|-
name|PAGE_FILE_HEADER_SIZE
operator|)
operator|/
name|pageSize
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|setCleanShutdown
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|storeMetaData
argument_list|()
expr_stmt|;
name|getFreeFile
argument_list|()
operator|.
name|delete
argument_list|()
expr_stmt|;
name|startWriter
argument_list|()
expr_stmt|;
if|if
condition|(
name|trackingFreeDuringRecovery
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|asyncFreePageRecovery
argument_list|(
name|nextFreePageId
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot load the page file when it is already loaded."
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|asyncFreePageRecovery
parameter_list|(
specifier|final
name|long
name|lastRecoveryPage
parameter_list|)
block|{
name|Thread
name|thread
init|=
operator|new
name|Thread
argument_list|(
literal|"KahaDB Index Free Page Recovery"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|recoverFreePages
argument_list|(
name|lastRecoveryPage
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|loaded
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error recovering index free page list"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
decl_stmt|;
name|thread
operator|.
name|setPriority
argument_list|(
name|Thread
operator|.
name|NORM_PRIORITY
argument_list|)
expr_stmt|;
name|thread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|recoverFreePages
parameter_list|(
specifier|final
name|long
name|lastRecoveryPage
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
name|toString
argument_list|()
operator|+
literal|". Recovering pageFile free list due to prior unclean shutdown.."
argument_list|)
expr_stmt|;
name|SequenceSet
name|newFreePages
init|=
operator|new
name|SequenceSet
argument_list|()
decl_stmt|;
comment|// need new pageFile instance to get unshared readFile
name|PageFile
name|recoveryPageFile
init|=
operator|new
name|PageFile
argument_list|(
name|directory
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|recoveryPageFile
operator|.
name|loadForRecovery
argument_list|(
name|nextFreePageId
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Page
argument_list|>
name|i
init|=
operator|new
name|Transaction
argument_list|(
name|recoveryPageFile
argument_list|)
operator|.
name|iterator
argument_list|(
literal|true
argument_list|)
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Page
name|page
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|page
operator|.
name|getPageId
argument_list|()
operator|>=
name|lastRecoveryPage
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|page
operator|.
name|getType
argument_list|()
operator|==
name|Page
operator|.
name|PAGE_FREE_TYPE
condition|)
block|{
name|newFreePages
operator|.
name|add
argument_list|(
name|page
operator|.
name|getPageId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|recoveryPageFile
operator|.
name|readFile
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|toString
argument_list|()
operator|+
literal|". Recovered pageFile free list of size: "
operator|+
name|newFreePages
operator|.
name|rangeSize
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newFreePages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// allow flush (with index lock held) to merge eventually
name|recoveredFreeList
operator|.
name|lazySet
argument_list|(
name|newFreePages
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|loadForRecovery
parameter_list|(
name|long
name|nextFreePageIdSnap
parameter_list|)
throws|throws
name|Exception
block|{
name|loaded
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|enablePageCaching
operator|=
literal|false
expr_stmt|;
name|File
name|file
init|=
name|getMainPageFile
argument_list|()
decl_stmt|;
name|readFile
operator|=
operator|new
name|RecoverableRandomAccessFile
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|loadMetaData
argument_list|()
expr_stmt|;
name|pageSize
operator|=
name|metaData
operator|.
name|getPageSize
argument_list|()
expr_stmt|;
name|enableRecoveryFile
operator|=
literal|false
expr_stmt|;
name|nextFreePageId
operator|.
name|set
argument_list|(
name|nextFreePageIdSnap
argument_list|)
expr_stmt|;
block|}
comment|/**      * Unloads a previously loaded PageFile.  This deallocates OS related resources like file handles.      * once unloaded, you can no longer use the page file to read or write Pages.      *      * @throws IOException           if there was a disk error occurred while closing the down the page file.      * @throws IllegalStateException if the PageFile is not loaded      */
specifier|public
name|void
name|unload
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|loaded
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|flush
argument_list|()
expr_stmt|;
try|try
block|{
name|stopWriter
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|()
throw|;
block|}
if|if
condition|(
name|freeList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|metaData
operator|.
name|setFreePages
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|storeFreeList
argument_list|()
expr_stmt|;
name|metaData
operator|.
name|setFreePages
argument_list|(
name|freeList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|metaData
operator|.
name|setLastTxId
argument_list|(
name|nextTxid
operator|.
name|get
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|trackingFreeDuringRecovery
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// async recovery incomplete, will have to try again
name|metaData
operator|.
name|setCleanShutdown
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metaData
operator|.
name|setCleanShutdown
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|storeMetaData
argument_list|()
expr_stmt|;
if|if
condition|(
name|readFile
operator|!=
literal|null
condition|)
block|{
name|readFile
operator|.
name|close
argument_list|()
expr_stmt|;
name|readFile
operator|=
literal|null
expr_stmt|;
name|writeFile
operator|.
name|close
argument_list|()
expr_stmt|;
name|writeFile
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|enableRecoveryFile
condition|)
block|{
name|recoveryFile
operator|.
name|close
argument_list|()
expr_stmt|;
name|recoveryFile
operator|=
literal|null
expr_stmt|;
block|}
name|freeList
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|pageCache
operator|!=
literal|null
condition|)
block|{
name|pageCache
operator|=
literal|null
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|writes
init|)
block|{
name|writes
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot unload the page file when it is not loaded"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|boolean
name|isLoaded
parameter_list|()
block|{
return|return
name|loaded
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|void
name|allowIOResumption
parameter_list|()
block|{
name|loaded
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Flush and sync all write buffers to disk.      *      * @throws IOException If an disk error occurred.      */
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|enabledWriteThread
operator|&&
name|stopWriter
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Page file already stopped: checkpointing is not allowed"
argument_list|)
throw|;
block|}
name|SequenceSet
name|recovered
init|=
name|recoveredFreeList
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|recovered
operator|!=
literal|null
condition|)
block|{
name|recoveredFreeList
operator|.
name|lazySet
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|SequenceSet
name|inUse
init|=
name|trackingFreeDuringRecovery
operator|.
name|get
argument_list|()
decl_stmt|;
name|recovered
operator|.
name|remove
argument_list|(
name|inUse
argument_list|)
expr_stmt|;
name|freeList
operator|.
name|merge
argument_list|(
name|recovered
argument_list|)
expr_stmt|;
comment|// all set for clean shutdown
name|trackingFreeDuringRecovery
operator|.
name|set
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|inUse
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// Setup a latch that gets notified when all buffered writes hits the disk.
name|CountDownLatch
name|checkpointLatch
decl_stmt|;
synchronized|synchronized
init|(
name|writes
init|)
block|{
if|if
condition|(
name|writes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|enabledWriteThread
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|checkpointLatch
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|checkpointLatch
operator|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|checkpointLatch
operator|=
name|this
operator|.
name|checkpointLatch
expr_stmt|;
name|writes
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|writeBatch
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
try|try
block|{
name|checkpointLatch
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|InterruptedIOException
name|ioe
init|=
operator|new
name|InterruptedIOException
argument_list|()
decl_stmt|;
name|ioe
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Page File: "
operator|+
name|getMainPageFile
argument_list|()
return|;
block|}
comment|///////////////////////////////////////////////////////////////////
comment|// Private Implementation Methods
comment|///////////////////////////////////////////////////////////////////
specifier|private
name|File
name|getMainPageFile
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|directory
argument_list|,
name|IOHelper
operator|.
name|toFileSystemSafeName
argument_list|(
name|name
argument_list|)
operator|+
name|PAGEFILE_SUFFIX
argument_list|)
return|;
block|}
specifier|public
name|File
name|getFreeFile
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|directory
argument_list|,
name|IOHelper
operator|.
name|toFileSystemSafeName
argument_list|(
name|name
argument_list|)
operator|+
name|FREE_FILE_SUFFIX
argument_list|)
return|;
block|}
specifier|public
name|File
name|getRecoveryFile
parameter_list|()
block|{
return|return
operator|new
name|File
argument_list|(
name|directory
argument_list|,
name|IOHelper
operator|.
name|toFileSystemSafeName
argument_list|(
name|name
argument_list|)
operator|+
name|RECOVERY_FILE_SUFFIX
argument_list|)
return|;
block|}
specifier|public
name|long
name|toOffset
parameter_list|(
name|long
name|pageId
parameter_list|)
block|{
return|return
name|PAGE_FILE_HEADER_SIZE
operator|+
operator|(
name|pageId
operator|*
name|pageSize
operator|)
return|;
block|}
specifier|private
name|void
name|loadMetaData
parameter_list|()
throws|throws
name|IOException
block|{
name|ByteArrayInputStream
name|is
decl_stmt|;
name|MetaData
name|v1
init|=
operator|new
name|MetaData
argument_list|()
decl_stmt|;
name|MetaData
name|v2
init|=
operator|new
name|MetaData
argument_list|()
decl_stmt|;
try|try
block|{
name|Properties
name|p
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
name|PAGE_FILE_HEADER_SIZE
operator|/
literal|2
index|]
decl_stmt|;
name|readFile
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|readFile
operator|.
name|readFully
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|is
operator|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|p
operator|.
name|load
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|IntrospectionSupport
operator|.
name|setProperties
argument_list|(
name|v1
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|v1
operator|=
literal|null
expr_stmt|;
block|}
try|try
block|{
name|Properties
name|p
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|byte
index|[]
name|d
init|=
operator|new
name|byte
index|[
name|PAGE_FILE_HEADER_SIZE
operator|/
literal|2
index|]
decl_stmt|;
name|readFile
operator|.
name|seek
argument_list|(
name|PAGE_FILE_HEADER_SIZE
operator|/
literal|2
argument_list|)
expr_stmt|;
name|readFile
operator|.
name|readFully
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|is
operator|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|p
operator|.
name|load
argument_list|(
name|is
argument_list|)
expr_stmt|;
name|IntrospectionSupport
operator|.
name|setProperties
argument_list|(
name|v2
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|v2
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|v1
operator|==
literal|null
operator|&&
name|v2
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not load page file meta data"
argument_list|)
throw|;
block|}
if|if
condition|(
name|v1
operator|==
literal|null
operator|||
name|v1
operator|.
name|metaDataTxId
operator|<
literal|0
condition|)
block|{
name|metaData
operator|=
name|v2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v2
operator|==
literal|null
operator|||
name|v1
operator|.
name|metaDataTxId
operator|<
literal|0
condition|)
block|{
name|metaData
operator|=
name|v1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v1
operator|.
name|metaDataTxId
operator|==
name|v2
operator|.
name|metaDataTxId
condition|)
block|{
name|metaData
operator|=
name|v1
expr_stmt|;
comment|// use the first since the 2nd could be a partial..
block|}
else|else
block|{
name|metaData
operator|=
name|v2
expr_stmt|;
comment|// use the second cause the first is probably a partial.
block|}
block|}
specifier|private
name|void
name|storeMetaData
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Convert the metadata into a property format
name|metaData
operator|.
name|metaDataTxId
operator|++
expr_stmt|;
name|Properties
name|p
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|IntrospectionSupport
operator|.
name|getProperties
argument_list|(
name|metaData
argument_list|,
name|p
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|PAGE_FILE_HEADER_SIZE
argument_list|)
decl_stmt|;
name|p
operator|.
name|store
argument_list|(
name|os
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|.
name|size
argument_list|()
operator|>
name|PAGE_FILE_HEADER_SIZE
operator|/
literal|2
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Configuation is larger than: "
operator|+
name|PAGE_FILE_HEADER_SIZE
operator|/
literal|2
argument_list|)
throw|;
block|}
comment|// Fill the rest with space...
name|byte
index|[]
name|filler
init|=
operator|new
name|byte
index|[
operator|(
name|PAGE_FILE_HEADER_SIZE
operator|/
literal|2
operator|)
operator|-
name|os
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|filler
argument_list|,
operator|(
name|byte
operator|)
literal|' '
argument_list|)
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|filler
argument_list|)
expr_stmt|;
name|os
operator|.
name|flush
argument_list|()
expr_stmt|;
name|byte
index|[]
name|d
init|=
name|os
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
comment|// So we don't loose it.. write it 2 times...
name|writeFile
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|writeFile
operator|.
name|write
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|writeFile
operator|.
name|sync
argument_list|()
expr_stmt|;
name|writeFile
operator|.
name|seek
argument_list|(
name|PAGE_FILE_HEADER_SIZE
operator|/
literal|2
argument_list|)
expr_stmt|;
name|writeFile
operator|.
name|write
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|writeFile
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|storeFreeList
parameter_list|()
throws|throws
name|IOException
block|{
name|FileOutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|getFreeFile
argument_list|()
argument_list|)
decl_stmt|;
name|DataOutputStream
name|dos
init|=
operator|new
name|DataOutputStream
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|SequenceSet
operator|.
name|Marshaller
operator|.
name|INSTANCE
operator|.
name|writePayload
argument_list|(
name|freeList
argument_list|,
name|dos
argument_list|)
expr_stmt|;
name|dos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|loadFreeList
parameter_list|()
throws|throws
name|IOException
block|{
name|freeList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|FileInputStream
name|is
init|=
operator|new
name|FileInputStream
argument_list|(
name|getFreeFile
argument_list|()
argument_list|)
decl_stmt|;
name|DataInputStream
name|dis
init|=
operator|new
name|DataInputStream
argument_list|(
name|is
argument_list|)
decl_stmt|;
name|freeList
operator|=
name|SequenceSet
operator|.
name|Marshaller
operator|.
name|INSTANCE
operator|.
name|readPayload
argument_list|(
name|dis
argument_list|)
expr_stmt|;
name|dis
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|///////////////////////////////////////////////////////////////////
comment|// Property Accessors
comment|///////////////////////////////////////////////////////////////////
comment|/**      * Is the recovery buffer used to double buffer page writes.  Enabled by default.      *      * @return is the recovery buffer enabled.      */
specifier|public
name|boolean
name|isEnableRecoveryFile
parameter_list|()
block|{
return|return
name|enableRecoveryFile
return|;
block|}
comment|/**      * Sets if the recovery buffer uses to double buffer page writes.  Enabled by default.  Disabling this      * may potentially cause partial page writes which can lead to page file corruption.      */
specifier|public
name|void
name|setEnableRecoveryFile
parameter_list|(
name|boolean
name|doubleBuffer
parameter_list|)
block|{
name|assertNotLoaded
argument_list|()
expr_stmt|;
name|this
operator|.
name|enableRecoveryFile
operator|=
name|doubleBuffer
expr_stmt|;
block|}
comment|/**      * @return Are page writes synced to disk?      */
specifier|public
name|boolean
name|isEnableDiskSyncs
parameter_list|()
block|{
return|return
name|enableDiskSyncs
return|;
block|}
comment|/**      * Allows you enable syncing writes to disk.      */
specifier|public
name|void
name|setEnableDiskSyncs
parameter_list|(
name|boolean
name|syncWrites
parameter_list|)
block|{
name|assertNotLoaded
argument_list|()
expr_stmt|;
name|this
operator|.
name|enableDiskSyncs
operator|=
name|syncWrites
expr_stmt|;
block|}
comment|/**      * @return the page size      */
specifier|public
name|int
name|getPageSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|pageSize
return|;
block|}
comment|/**      * @return the amount of content data that a page can hold.      */
specifier|public
name|int
name|getPageContentSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|pageSize
operator|-
name|Page
operator|.
name|PAGE_HEADER_SIZE
return|;
block|}
comment|/**      * Configures the page size used by the page file.  By default it is 4k.  Once a page file is created on disk,      * subsequent loads of that file will use the original pageSize.  Once the PageFile is loaded, this setting      * can no longer be changed.      *      * @param pageSize the pageSize to set      * @throws IllegalStateException once the page file is loaded.      */
specifier|public
name|void
name|setPageSize
parameter_list|(
name|int
name|pageSize
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|assertNotLoaded
argument_list|()
expr_stmt|;
name|this
operator|.
name|pageSize
operator|=
name|pageSize
expr_stmt|;
block|}
comment|/**      * @return true if read page caching is enabled      */
specifier|public
name|boolean
name|isEnablePageCaching
parameter_list|()
block|{
return|return
name|this
operator|.
name|enablePageCaching
return|;
block|}
comment|/**      * @param enablePageCaching allows you to enable read page caching      */
specifier|public
name|void
name|setEnablePageCaching
parameter_list|(
name|boolean
name|enablePageCaching
parameter_list|)
block|{
name|assertNotLoaded
argument_list|()
expr_stmt|;
name|this
operator|.
name|enablePageCaching
operator|=
name|enablePageCaching
expr_stmt|;
block|}
comment|/**      * @return the maximum number of pages that will get stored in the read page cache.      */
specifier|public
name|int
name|getPageCacheSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|pageCacheSize
return|;
block|}
comment|/**      * @param pageCacheSize Sets the maximum number of pages that will get stored in the read page cache.      */
specifier|public
name|void
name|setPageCacheSize
parameter_list|(
name|int
name|pageCacheSize
parameter_list|)
block|{
name|assertNotLoaded
argument_list|()
expr_stmt|;
name|this
operator|.
name|pageCacheSize
operator|=
name|pageCacheSize
expr_stmt|;
block|}
specifier|public
name|boolean
name|isEnabledWriteThread
parameter_list|()
block|{
return|return
name|enabledWriteThread
return|;
block|}
specifier|public
name|void
name|setEnableWriteThread
parameter_list|(
name|boolean
name|enableAsyncWrites
parameter_list|)
block|{
name|assertNotLoaded
argument_list|()
expr_stmt|;
name|this
operator|.
name|enabledWriteThread
operator|=
name|enableAsyncWrites
expr_stmt|;
block|}
specifier|public
name|long
name|getDiskSize
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|toOffset
argument_list|(
name|nextFreePageId
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isFreePage
parameter_list|(
name|long
name|pageId
parameter_list|)
block|{
return|return
name|freeList
operator|.
name|contains
argument_list|(
name|pageId
argument_list|)
return|;
block|}
comment|/**      * @return the number of pages allocated in the PageFile      */
specifier|public
name|long
name|getPageCount
parameter_list|()
block|{
return|return
name|nextFreePageId
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|int
name|getRecoveryFileMinPageCount
parameter_list|()
block|{
return|return
name|recoveryFileMinPageCount
return|;
block|}
specifier|public
name|long
name|getFreePageCount
parameter_list|()
block|{
name|assertLoaded
argument_list|()
expr_stmt|;
return|return
name|freeList
operator|.
name|rangeSize
argument_list|()
return|;
block|}
specifier|public
name|void
name|setRecoveryFileMinPageCount
parameter_list|(
name|int
name|recoveryFileMinPageCount
parameter_list|)
block|{
name|assertNotLoaded
argument_list|()
expr_stmt|;
name|this
operator|.
name|recoveryFileMinPageCount
operator|=
name|recoveryFileMinPageCount
expr_stmt|;
block|}
specifier|public
name|int
name|getRecoveryFileMaxPageCount
parameter_list|()
block|{
return|return
name|recoveryFileMaxPageCount
return|;
block|}
specifier|public
name|void
name|setRecoveryFileMaxPageCount
parameter_list|(
name|int
name|recoveryFileMaxPageCount
parameter_list|)
block|{
name|assertNotLoaded
argument_list|()
expr_stmt|;
name|this
operator|.
name|recoveryFileMaxPageCount
operator|=
name|recoveryFileMaxPageCount
expr_stmt|;
block|}
specifier|public
name|int
name|getWriteBatchSize
parameter_list|()
block|{
return|return
name|writeBatchSize
return|;
block|}
specifier|public
name|void
name|setWriteBatchSize
parameter_list|(
name|int
name|writeBatchSize
parameter_list|)
block|{
name|this
operator|.
name|writeBatchSize
operator|=
name|writeBatchSize
expr_stmt|;
block|}
specifier|public
name|float
name|getLFUEvictionFactor
parameter_list|()
block|{
return|return
name|LFUEvictionFactor
return|;
block|}
specifier|public
name|void
name|setLFUEvictionFactor
parameter_list|(
name|float
name|LFUEvictionFactor
parameter_list|)
block|{
name|this
operator|.
name|LFUEvictionFactor
operator|=
name|LFUEvictionFactor
expr_stmt|;
block|}
specifier|public
name|boolean
name|isUseLFRUEviction
parameter_list|()
block|{
return|return
name|useLFRUEviction
return|;
block|}
specifier|public
name|void
name|setUseLFRUEviction
parameter_list|(
name|boolean
name|useLFRUEviction
parameter_list|)
block|{
name|this
operator|.
name|useLFRUEviction
operator|=
name|useLFRUEviction
expr_stmt|;
block|}
comment|///////////////////////////////////////////////////////////////////
comment|// Package Protected Methods exposed to Transaction
comment|///////////////////////////////////////////////////////////////////
comment|/**      * @throws IllegalStateException if the page file is not loaded.      */
name|void
name|assertLoaded
parameter_list|()
throws|throws
name|IllegalStateException
block|{
if|if
condition|(
operator|!
name|loaded
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"PageFile is not loaded"
argument_list|)
throw|;
block|}
block|}
name|void
name|assertNotLoaded
parameter_list|()
throws|throws
name|IllegalStateException
block|{
if|if
condition|(
name|loaded
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"PageFile is loaded"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Allocates a block of free pages that you can write data to.      *      * @param count the number of sequential pages to allocate      * @return the first page of the sequential set.      * @throws IOException           If an disk error occurred.      * @throws IllegalStateException if the PageFile is not loaded      */
parameter_list|<
name|T
parameter_list|>
name|Page
argument_list|<
name|T
argument_list|>
name|allocate
parameter_list|(
name|int
name|count
parameter_list|)
throws|throws
name|IOException
block|{
name|assertLoaded
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The allocation count must be larger than zero"
argument_list|)
throw|;
block|}
name|Sequence
name|seq
init|=
name|freeList
operator|.
name|removeFirstSequence
argument_list|(
name|count
argument_list|)
decl_stmt|;
comment|// We may need to create new free pages...
if|if
condition|(
name|seq
operator|==
literal|null
condition|)
block|{
name|Page
argument_list|<
name|T
argument_list|>
name|first
init|=
literal|null
decl_stmt|;
name|int
name|c
init|=
name|count
decl_stmt|;
comment|// Perform the id's only once....
name|long
name|pageId
init|=
name|nextFreePageId
operator|.
name|getAndAdd
argument_list|(
name|count
argument_list|)
decl_stmt|;
name|long
name|writeTxnId
init|=
name|nextTxid
operator|.
name|getAndAdd
argument_list|(
name|count
argument_list|)
decl_stmt|;
while|while
condition|(
name|c
operator|--
operator|>
literal|0
condition|)
block|{
name|Page
argument_list|<
name|T
argument_list|>
name|page
init|=
operator|new
name|Page
argument_list|<
name|T
argument_list|>
argument_list|(
name|pageId
operator|++
argument_list|)
decl_stmt|;
name|page
operator|.
name|makeFree
argument_list|(
name|writeTxnId
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
name|first
operator|=
name|page
expr_stmt|;
block|}
name|addToCache
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|DataByteArrayOutputStream
name|out
init|=
operator|new
name|DataByteArrayOutputStream
argument_list|(
name|pageSize
argument_list|)
decl_stmt|;
name|page
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|page
argument_list|,
name|out
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
comment|// LOG.debug("allocate writing: "+page.getPageId());
block|}
return|return
name|first
return|;
block|}
name|Page
argument_list|<
name|T
argument_list|>
name|page
init|=
operator|new
name|Page
argument_list|<
name|T
argument_list|>
argument_list|(
name|seq
operator|.
name|getFirst
argument_list|()
argument_list|)
decl_stmt|;
name|page
operator|.
name|makeFree
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// LOG.debug("allocated: "+page.getPageId());
return|return
name|page
return|;
block|}
name|long
name|getNextWriteTransactionId
parameter_list|()
block|{
return|return
name|nextTxid
operator|.
name|incrementAndGet
argument_list|()
return|;
block|}
specifier|synchronized
name|void
name|readPage
parameter_list|(
name|long
name|pageId
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|readFile
operator|.
name|seek
argument_list|(
name|toOffset
argument_list|(
name|pageId
argument_list|)
argument_list|)
expr_stmt|;
name|readFile
operator|.
name|readFully
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|freePage
parameter_list|(
name|long
name|pageId
parameter_list|)
block|{
name|freeList
operator|.
name|add
argument_list|(
name|pageId
argument_list|)
expr_stmt|;
name|removeFromCache
argument_list|(
name|pageId
argument_list|)
expr_stmt|;
name|SequenceSet
name|trackFreeDuringRecovery
init|=
name|trackingFreeDuringRecovery
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|trackFreeDuringRecovery
operator|!=
literal|null
condition|)
block|{
name|trackFreeDuringRecovery
operator|.
name|add
argument_list|(
name|pageId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|void
name|write
parameter_list|(
name|Page
argument_list|<
name|T
argument_list|>
name|page
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|PageWrite
name|write
init|=
operator|new
name|PageWrite
argument_list|(
name|page
argument_list|,
name|data
argument_list|)
decl_stmt|;
name|Entry
argument_list|<
name|Long
argument_list|,
name|PageWrite
argument_list|>
name|entry
init|=
operator|new
name|Entry
argument_list|<
name|Long
argument_list|,
name|PageWrite
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Long
name|getKey
parameter_list|()
block|{
return|return
name|write
operator|.
name|getPage
argument_list|()
operator|.
name|getPageId
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|PageWrite
name|getValue
parameter_list|()
block|{
return|return
name|write
return|;
block|}
annotation|@
name|Override
specifier|public
name|PageWrite
name|setValue
parameter_list|(
name|PageWrite
name|value
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
name|Entry
argument_list|<
name|Long
argument_list|,
name|PageWrite
argument_list|>
index|[]
name|entries
init|=
operator|new
name|Map
operator|.
name|Entry
index|[]
block|{
name|entry
block|}
decl_stmt|;
name|write
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|entries
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|write
parameter_list|(
name|Collection
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|PageWrite
argument_list|>
argument_list|>
name|updates
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|writes
init|)
block|{
if|if
condition|(
name|enabledWriteThread
condition|)
block|{
while|while
condition|(
name|writes
operator|.
name|size
argument_list|()
operator|>=
name|writeBatchSize
operator|&&
operator|!
name|stopWriter
operator|.
name|get
argument_list|()
condition|)
block|{
try|try
block|{
name|writes
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|InterruptedIOException
argument_list|()
throw|;
block|}
block|}
block|}
name|boolean
name|longTx
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|PageWrite
argument_list|>
name|entry
range|:
name|updates
control|)
block|{
name|Long
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|PageWrite
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|PageWrite
name|write
init|=
name|writes
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|write
operator|==
literal|null
condition|)
block|{
name|writes
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|.
name|currentLocation
operator|!=
operator|-
literal|1
condition|)
block|{
name|write
operator|.
name|setCurrentLocation
argument_list|(
name|value
operator|.
name|page
argument_list|,
name|value
operator|.
name|currentLocation
argument_list|,
name|value
operator|.
name|length
argument_list|)
expr_stmt|;
name|write
operator|.
name|tmpFile
operator|=
name|value
operator|.
name|tmpFile
expr_stmt|;
name|longTx
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|write
operator|.
name|setCurrent
argument_list|(
name|value
operator|.
name|page
argument_list|,
name|value
operator|.
name|current
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Once we start approaching capacity, notify the writer to start writing
comment|// sync immediately for long txs
if|if
condition|(
name|longTx
operator|||
name|canStartWriteBatch
argument_list|()
condition|)
block|{
if|if
condition|(
name|enabledWriteThread
condition|)
block|{
name|writes
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|writeBatch
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|boolean
name|canStartWriteBatch
parameter_list|()
block|{
name|int
name|capacityUsed
init|=
operator|(
operator|(
name|writes
operator|.
name|size
argument_list|()
operator|*
literal|100
operator|)
operator|/
name|writeBatchSize
operator|)
decl_stmt|;
if|if
condition|(
name|enabledWriteThread
condition|)
block|{
comment|// The constant 10 here controls how soon write batches start going to disk..
comment|// would be nice to figure out how to auto tune that value.  Make to small and
comment|// we reduce through put because we are locking the write mutex too often doing writes
return|return
name|capacityUsed
operator|>=
literal|10
operator|||
name|checkpointLatch
operator|!=
literal|null
return|;
block|}
else|else
block|{
return|return
name|capacityUsed
operator|>=
literal|80
operator|||
name|checkpointLatch
operator|!=
literal|null
return|;
block|}
block|}
comment|///////////////////////////////////////////////////////////////////
comment|// Cache Related operations
comment|///////////////////////////////////////////////////////////////////
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
parameter_list|<
name|T
parameter_list|>
name|Page
argument_list|<
name|T
argument_list|>
name|getFromCache
parameter_list|(
name|long
name|pageId
parameter_list|)
block|{
synchronized|synchronized
init|(
name|writes
init|)
block|{
name|PageWrite
name|pageWrite
init|=
name|writes
operator|.
name|get
argument_list|(
name|pageId
argument_list|)
decl_stmt|;
if|if
condition|(
name|pageWrite
operator|!=
literal|null
condition|)
block|{
return|return
name|pageWrite
operator|.
name|page
return|;
block|}
block|}
name|Page
argument_list|<
name|T
argument_list|>
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|enablePageCaching
condition|)
block|{
name|result
operator|=
name|pageCache
operator|.
name|get
argument_list|(
name|pageId
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
name|void
name|addToCache
parameter_list|(
name|Page
name|page
parameter_list|)
block|{
if|if
condition|(
name|enablePageCaching
condition|)
block|{
name|pageCache
operator|.
name|put
argument_list|(
name|page
operator|.
name|getPageId
argument_list|()
argument_list|,
name|page
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|removeFromCache
parameter_list|(
name|long
name|pageId
parameter_list|)
block|{
if|if
condition|(
name|enablePageCaching
condition|)
block|{
name|pageCache
operator|.
name|remove
argument_list|(
name|pageId
argument_list|)
expr_stmt|;
block|}
block|}
comment|///////////////////////////////////////////////////////////////////
comment|// Internal Double write implementation follows...
comment|///////////////////////////////////////////////////////////////////
specifier|private
name|void
name|pollWrites
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
operator|!
name|stopWriter
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// Wait for a notification...
synchronized|synchronized
init|(
name|writes
init|)
block|{
name|writes
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
comment|// If there is not enough to write, wait for a notification...
while|while
condition|(
name|writes
operator|.
name|isEmpty
argument_list|()
operator|&&
name|checkpointLatch
operator|==
literal|null
operator|&&
operator|!
name|stopWriter
operator|.
name|get
argument_list|()
condition|)
block|{
name|writes
operator|.
name|wait
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|writes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|releaseCheckpointWaiter
argument_list|()
expr_stmt|;
block|}
block|}
name|writeBatch
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"An exception was raised while performing poll writes"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|releaseCheckpointWaiter
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|writeBatch
parameter_list|()
throws|throws
name|IOException
block|{
name|CountDownLatch
name|checkpointLatch
decl_stmt|;
name|ArrayList
argument_list|<
name|PageWrite
argument_list|>
name|batch
decl_stmt|;
synchronized|synchronized
init|(
name|writes
init|)
block|{
comment|// If there is not enough to write, wait for a notification...
name|batch
operator|=
operator|new
name|ArrayList
argument_list|<
name|PageWrite
argument_list|>
argument_list|(
name|writes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// build a write batch from the current write cache.
for|for
control|(
name|PageWrite
name|write
range|:
name|writes
operator|.
name|values
argument_list|()
control|)
block|{
name|batch
operator|.
name|add
argument_list|(
name|write
argument_list|)
expr_stmt|;
comment|// Move the current write to the diskBound write, this lets folks update the
comment|// page again without blocking for this write.
name|write
operator|.
name|begin
argument_list|()
expr_stmt|;
if|if
condition|(
name|write
operator|.
name|diskBound
operator|==
literal|null
operator|&&
name|write
operator|.
name|diskBoundLocation
operator|==
operator|-
literal|1
condition|)
block|{
name|batch
operator|.
name|remove
argument_list|(
name|write
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Grab on to the existing checkpoint latch cause once we do this write we can
comment|// release the folks that were waiting for those writes to hit disk.
name|checkpointLatch
operator|=
name|this
operator|.
name|checkpointLatch
expr_stmt|;
name|this
operator|.
name|checkpointLatch
operator|=
literal|null
expr_stmt|;
block|}
try|try
block|{
comment|// First land the writes in the recovery file
if|if
condition|(
name|enableRecoveryFile
condition|)
block|{
name|Checksum
name|checksum
init|=
operator|new
name|Adler32
argument_list|()
decl_stmt|;
name|recoveryFile
operator|.
name|seek
argument_list|(
name|RECOVERY_FILE_HEADER_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|PageWrite
name|w
range|:
name|batch
control|)
block|{
try|try
block|{
name|checksum
operator|.
name|update
argument_list|(
name|w
operator|.
name|getDiskBound
argument_list|()
argument_list|,
literal|0
argument_list|,
name|pageSize
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|IOExceptionSupport
operator|.
name|create
argument_list|(
literal|"Cannot create recovery file. Reason: "
operator|+
name|t
argument_list|,
name|t
argument_list|)
throw|;
block|}
name|recoveryFile
operator|.
name|writeLong
argument_list|(
name|w
operator|.
name|page
operator|.
name|getPageId
argument_list|()
argument_list|)
expr_stmt|;
name|recoveryFile
operator|.
name|write
argument_list|(
name|w
operator|.
name|getDiskBound
argument_list|()
argument_list|,
literal|0
argument_list|,
name|pageSize
argument_list|)
expr_stmt|;
block|}
comment|// Can we shrink the recovery buffer??
if|if
condition|(
name|recoveryPageCount
operator|>
name|recoveryFileMaxPageCount
condition|)
block|{
name|int
name|t
init|=
name|Math
operator|.
name|max
argument_list|(
name|recoveryFileMinPageCount
argument_list|,
name|batch
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|recoveryFile
operator|.
name|setLength
argument_list|(
name|recoveryFileSizeForPages
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Record the page writes in the recovery buffer.
name|recoveryFile
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Store the next tx id...
name|recoveryFile
operator|.
name|writeLong
argument_list|(
name|nextTxid
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
comment|// Store the checksum for thw write batch so that on recovery we
comment|// know if we have a consistent
comment|// write batch on disk.
name|recoveryFile
operator|.
name|writeLong
argument_list|(
name|checksum
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// Write the # of pages that will follow
name|recoveryFile
operator|.
name|writeInt
argument_list|(
name|batch
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|enableDiskSyncs
condition|)
block|{
name|recoveryFile
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|PageWrite
name|w
range|:
name|batch
control|)
block|{
name|writeFile
operator|.
name|seek
argument_list|(
name|toOffset
argument_list|(
name|w
operator|.
name|page
operator|.
name|getPageId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeFile
operator|.
name|write
argument_list|(
name|w
operator|.
name|getDiskBound
argument_list|()
argument_list|,
literal|0
argument_list|,
name|pageSize
argument_list|)
expr_stmt|;
name|w
operator|.
name|done
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|enableDiskSyncs
condition|)
block|{
name|writeFile
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioError
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unexpected io error on pagefile write of "
operator|+
name|batch
operator|.
name|size
argument_list|()
operator|+
literal|" pages."
argument_list|,
name|ioError
argument_list|)
expr_stmt|;
comment|// any subsequent write needs to be prefaced with a considered call to redoRecoveryUpdates
comment|// to ensure disk image is self consistent
name|loaded
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
throw|throw
name|ioError
throw|;
block|}
finally|finally
block|{
synchronized|synchronized
init|(
name|writes
init|)
block|{
for|for
control|(
name|PageWrite
name|w
range|:
name|batch
control|)
block|{
comment|// If there are no more pending writes, then remove it from
comment|// the write cache.
if|if
condition|(
name|w
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|writes
operator|.
name|remove
argument_list|(
name|w
operator|.
name|page
operator|.
name|getPageId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|tmpFile
operator|!=
literal|null
operator|&&
name|tmpFilesForRemoval
operator|.
name|contains
argument_list|(
name|w
operator|.
name|tmpFile
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|w
operator|.
name|tmpFile
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't delete temporary KahaDB transaction file:"
operator|+
name|w
operator|.
name|tmpFile
argument_list|)
throw|;
block|}
name|tmpFilesForRemoval
operator|.
name|remove
argument_list|(
name|w
operator|.
name|tmpFile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|checkpointLatch
operator|!=
literal|null
condition|)
block|{
name|checkpointLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|removeTmpFile
parameter_list|(
name|File
name|file
parameter_list|)
block|{
name|tmpFilesForRemoval
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
specifier|private
name|long
name|recoveryFileSizeForPages
parameter_list|(
name|int
name|pageCount
parameter_list|)
block|{
return|return
name|RECOVERY_FILE_HEADER_SIZE
operator|+
operator|(
operator|(
name|pageSize
operator|+
literal|8
operator|)
operator|*
name|pageCount
operator|)
return|;
block|}
specifier|private
name|void
name|releaseCheckpointWaiter
parameter_list|()
block|{
if|if
condition|(
name|checkpointLatch
operator|!=
literal|null
condition|)
block|{
name|checkpointLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
name|checkpointLatch
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**      * Inspects the recovery buffer and re-applies any      * partially applied page writes.      *      * @return the next transaction id that can be used.      */
specifier|private
name|long
name|redoRecoveryUpdates
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|enableRecoveryFile
condition|)
block|{
return|return
literal|0
return|;
block|}
name|recoveryPageCount
operator|=
literal|0
expr_stmt|;
comment|// Are we initializing the recovery file?
if|if
condition|(
name|recoveryFile
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Write an empty header..
name|recoveryFile
operator|.
name|write
argument_list|(
operator|new
name|byte
index|[
name|RECOVERY_FILE_HEADER_SIZE
index|]
argument_list|)
expr_stmt|;
comment|// Preallocate the minium size for better performance.
name|recoveryFile
operator|.
name|setLength
argument_list|(
name|recoveryFileSizeForPages
argument_list|(
name|recoveryFileMinPageCount
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|// How many recovery pages do we have in the recovery buffer?
name|recoveryFile
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|long
name|nextTxId
init|=
name|recoveryFile
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|long
name|expectedChecksum
init|=
name|recoveryFile
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|int
name|pageCounter
init|=
name|recoveryFile
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|recoveryFile
operator|.
name|seek
argument_list|(
name|RECOVERY_FILE_HEADER_SIZE
argument_list|)
expr_stmt|;
name|Checksum
name|checksum
init|=
operator|new
name|Adler32
argument_list|()
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
name|batch
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pageCounter
condition|;
name|i
operator|++
control|)
block|{
name|long
name|offset
init|=
name|recoveryFile
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|pageSize
index|]
decl_stmt|;
if|if
condition|(
name|recoveryFile
operator|.
name|read
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|pageSize
argument_list|)
operator|!=
name|pageSize
condition|)
block|{
comment|// Invalid recovery record, Could not fully read the data". Probably due to a partial write to the recovery buffer
return|return
name|nextTxId
return|;
block|}
name|checksum
operator|.
name|update
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|pageSize
argument_list|)
expr_stmt|;
name|batch
operator|.
name|put
argument_list|(
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// If an error occurred it was cause the redo buffer was not full written out correctly.. so don't redo it.
comment|// as the pages should still be consistent.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Redo buffer was not fully intact: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|nextTxId
return|;
block|}
name|recoveryPageCount
operator|=
name|pageCounter
expr_stmt|;
comment|// If the checksum is not valid then the recovery buffer was partially written to disk.
if|if
condition|(
name|checksum
operator|.
name|getValue
argument_list|()
operator|!=
name|expectedChecksum
condition|)
block|{
return|return
name|nextTxId
return|;
block|}
comment|// Re-apply all the writes in the recovery buffer.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|byte
index|[]
argument_list|>
name|e
range|:
name|batch
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|writeFile
operator|.
name|seek
argument_list|(
name|toOffset
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|writeFile
operator|.
name|write
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// And sync it to disk
name|writeFile
operator|.
name|sync
argument_list|()
expr_stmt|;
return|return
name|nextTxId
return|;
block|}
specifier|private
name|void
name|startWriter
parameter_list|()
block|{
synchronized|synchronized
init|(
name|writes
init|)
block|{
if|if
condition|(
name|enabledWriteThread
condition|)
block|{
name|stopWriter
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|writerThread
operator|=
operator|new
name|Thread
argument_list|(
literal|"KahaDB Page Writer"
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|pollWrites
argument_list|()
expr_stmt|;
block|}
block|}
expr_stmt|;
name|writerThread
operator|.
name|setPriority
argument_list|(
name|Thread
operator|.
name|MAX_PRIORITY
argument_list|)
expr_stmt|;
name|writerThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writerThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|stopWriter
parameter_list|()
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|enabledWriteThread
condition|)
block|{
name|stopWriter
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|writerThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|File
name|getFile
parameter_list|()
block|{
return|return
name|getMainPageFile
argument_list|()
return|;
block|}
specifier|public
name|File
name|getDirectory
parameter_list|()
block|{
return|return
name|directory
return|;
block|}
block|}
end_class

end_unit

