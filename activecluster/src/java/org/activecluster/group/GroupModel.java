begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  *  * Copyright 2004 The Apache Software Foundation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|activecluster
operator|.
name|group
package|;
end_package

begin_import
import|import
name|org
operator|.
name|activecluster
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Represents a collection of zero or more groups in a cluster.  * The default implementation will create groups as nodes are added to the cluster; filling  * the groups with its required number of buddies / slaves until a new group can be created.  *<p/>  * Nodes which are not allowed to be master nodes will be kept around in a pool ready to be added  * as slaves when a new master arrives and forces the creation of a group.  *  * @version $Revision: 1.2 $  * @see Group  */
end_comment

begin_class
specifier|public
class|class
name|GroupModel
block|{
specifier|private
name|int
name|maximumGroups
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|int
name|minimumMemberCount
init|=
literal|2
decl_stmt|;
specifier|private
name|int
name|maximumMemberCount
init|=
literal|3
decl_stmt|;
specifier|private
name|List
name|groups
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
specifier|private
name|LinkedList
name|incompleteGroups
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
specifier|private
name|LinkedList
name|completeGroups
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
specifier|private
name|LinkedList
name|fullGroups
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
specifier|private
name|LinkedList
name|unusedNodes
init|=
operator|new
name|LinkedList
argument_list|()
decl_stmt|;
specifier|private
name|NodeFilter
name|masterFilter
decl_stmt|;
specifier|private
name|Map
name|nodeMemberships
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|// allow a node to be a master and 2 buddies
specifier|private
name|int
name|maximumWeighting
init|=
literal|10
decl_stmt|;
comment|/**      * Adds the new node to this group model; we assume the node has not been added before.      *      * @param node      */
specifier|public
specifier|synchronized
name|void
name|addNode
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|addToExistingGroup
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|Group
name|group
init|=
name|makeNewGroup
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|group
operator|==
literal|null
condition|)
block|{
name|addToUnusedNodes
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addGroup
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Removes the node from the group model      *      * @param node      */
specifier|public
specifier|synchronized
name|void
name|removeNode
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|unusedNodes
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// lets remove the node from each group
for|for
control|(
name|Iterator
name|iter
init|=
name|groups
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Group
name|group
init|=
operator|(
name|Group
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|boolean
name|wasFull
init|=
name|group
operator|.
name|isFull
argument_list|()
decl_stmt|;
name|boolean
name|wasUsable
init|=
name|group
operator|.
name|isUsable
argument_list|()
decl_stmt|;
if|if
condition|(
name|removeNodeFromGroup
argument_list|(
name|group
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|updateGroupCollections
argument_list|(
name|group
argument_list|,
name|wasFull
argument_list|,
name|wasUsable
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Properties
comment|//-------------------------------------------------------------------------
comment|/**      * Returns a snapshot of the groups currently available      */
specifier|public
specifier|synchronized
name|List
name|getGroups
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|(
name|groups
argument_list|)
return|;
block|}
specifier|public
name|NodeFilter
name|getMasterFilter
parameter_list|()
block|{
return|return
name|masterFilter
return|;
block|}
specifier|public
name|void
name|setMasterFilter
parameter_list|(
name|NodeFilter
name|masterFilter
parameter_list|)
block|{
name|this
operator|.
name|masterFilter
operator|=
name|masterFilter
expr_stmt|;
block|}
specifier|public
name|int
name|getMaximumGroups
parameter_list|()
block|{
return|return
name|maximumGroups
return|;
block|}
specifier|public
name|void
name|setMaximumGroups
parameter_list|(
name|int
name|maximumGroups
parameter_list|)
block|{
name|this
operator|.
name|maximumGroups
operator|=
name|maximumGroups
expr_stmt|;
block|}
specifier|public
name|int
name|getMaximumMemberCount
parameter_list|()
block|{
return|return
name|maximumMemberCount
return|;
block|}
specifier|public
name|void
name|setMaximumMemberCount
parameter_list|(
name|int
name|maximumMemberCount
parameter_list|)
block|{
name|this
operator|.
name|maximumMemberCount
operator|=
name|maximumMemberCount
expr_stmt|;
block|}
specifier|public
name|int
name|getMinimumMemberCount
parameter_list|()
block|{
return|return
name|minimumMemberCount
return|;
block|}
specifier|public
name|void
name|setMinimumMemberCount
parameter_list|(
name|int
name|minimumMemberCount
parameter_list|)
block|{
name|this
operator|.
name|minimumMemberCount
operator|=
name|minimumMemberCount
expr_stmt|;
block|}
specifier|public
name|int
name|getMaximumWeighting
parameter_list|()
block|{
return|return
name|maximumWeighting
return|;
block|}
specifier|public
name|void
name|setMaximumWeighting
parameter_list|(
name|int
name|maximumWeighting
parameter_list|)
block|{
name|this
operator|.
name|maximumWeighting
operator|=
name|maximumWeighting
expr_stmt|;
block|}
comment|// Implementation methods
comment|//-------------------------------------------------------------------------
comment|/**      * Attempt to make a new group with the current node as the master      * or if the node cannot be a master node      *      * @return the newly created group or false if none was created.      */
specifier|protected
name|Group
name|makeNewGroup
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
comment|// no pending groups available so lets try and create a new group
if|if
condition|(
name|canCreateGroup
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|Group
name|group
init|=
name|createGroup
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|addNodeToGroup
argument_list|(
name|group
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|group
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|protected
name|void
name|tryToFillGroupWithBuddies
parameter_list|(
name|Group
name|group
parameter_list|)
block|{
name|boolean
name|continueFillingGroups
init|=
literal|true
decl_stmt|;
while|while
condition|(
operator|!
name|group
operator|.
name|isUsable
argument_list|()
operator|&&
name|continueFillingGroups
condition|)
block|{
name|continueFillingGroups
operator|=
name|tryToAddBuddy
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|continueFillingGroups
condition|)
block|{
comment|// lets try fill more unfilled nodes
for|for
control|(
name|Iterator
name|iter
init|=
operator|new
name|ArrayList
argument_list|(
name|incompleteGroups
argument_list|)
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
operator|&&
name|continueFillingGroups
condition|;
control|)
block|{
name|group
operator|=
operator|(
name|Group
operator|)
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|boolean
name|wasFull
init|=
name|group
operator|.
name|isFull
argument_list|()
decl_stmt|;
name|boolean
name|wasUsable
init|=
name|group
operator|.
name|isUsable
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|group
operator|.
name|isUsable
argument_list|()
operator|&&
name|continueFillingGroups
condition|)
block|{
name|continueFillingGroups
operator|=
name|tryToAddBuddy
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|group
operator|.
name|isUsable
argument_list|()
condition|)
block|{
name|updateGroupCollections
argument_list|(
name|group
argument_list|,
name|wasFull
argument_list|,
name|wasUsable
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|protected
name|boolean
name|tryToAddBuddy
parameter_list|(
name|Group
name|group
parameter_list|)
block|{
name|boolean
name|continueFillingGroups
init|=
literal|true
decl_stmt|;
comment|// TODO we could make this much faster using a weighting-sorted collection
name|NodeMemberships
name|lowest
init|=
literal|null
decl_stmt|;
name|int
name|lowestWeight
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
name|iter
init|=
name|nodeMemberships
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|NodeMemberships
name|memberships
init|=
operator|(
name|NodeMemberships
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|memberships
operator|.
name|isMember
argument_list|(
name|group
argument_list|)
condition|)
block|{
name|int
name|weighting
init|=
name|memberships
operator|.
name|getWeighting
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|lowest
operator|==
literal|null
operator|||
name|weighting
operator|<
name|lowestWeight
operator|)
operator|&&
name|weighting
operator|<
name|maximumWeighting
condition|)
block|{
name|lowest
operator|=
name|memberships
expr_stmt|;
name|lowestWeight
operator|=
name|weighting
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lowest
operator|==
literal|null
condition|)
block|{
name|continueFillingGroups
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|addNodeToGroup
argument_list|(
name|group
argument_list|,
name|lowest
operator|.
name|getNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|continueFillingGroups
return|;
block|}
comment|/**      * Lets move the group from its current state collection to the new collection if its      * state has changed      */
specifier|protected
name|void
name|updateGroupCollections
parameter_list|(
name|Group
name|group
parameter_list|,
name|boolean
name|wasFull
parameter_list|,
name|boolean
name|wasUsable
parameter_list|)
block|{
name|boolean
name|full
init|=
name|group
operator|.
name|isFull
argument_list|()
decl_stmt|;
if|if
condition|(
name|wasFull
operator|&&
operator|!
name|full
condition|)
block|{
name|fullGroups
operator|.
name|remove
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
name|boolean
name|usable
init|=
name|group
operator|.
name|isUsable
argument_list|()
decl_stmt|;
if|if
condition|(
name|wasUsable
operator|&&
operator|!
name|usable
condition|)
block|{
name|completeGroups
operator|.
name|remove
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|usable
operator|||
operator|!
name|full
operator|)
operator|&&
operator|(
name|wasFull
operator|||
name|wasUsable
operator|)
condition|)
block|{
name|incompleteGroups
operator|.
name|add
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|addToUnusedNodes
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
comment|// lets add the node to the pool ready to be used if a node fails
name|unusedNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/**      * Attempts to add the node to an incomplete group, or      * a not-full group and returns true if its possible - else returns false      *      * @return true if the node has been added to a groupu      */
specifier|protected
name|boolean
name|addToExistingGroup
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|addToIncompleteGroup
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|addToNotFullGroup
argument_list|(
name|node
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|protected
name|boolean
name|addToNotFullGroup
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
return|return
name|addToPendingGroup
argument_list|(
name|completeGroups
argument_list|,
name|node
argument_list|)
return|;
block|}
specifier|protected
name|boolean
name|addToIncompleteGroup
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
return|return
name|addToPendingGroup
argument_list|(
name|incompleteGroups
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/**      * Adds the given node to the first pending group if possible      *      * @return true if the node was added to the first available group      */
specifier|protected
name|boolean
name|addToPendingGroup
parameter_list|(
name|LinkedList
name|list
parameter_list|,
name|Node
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Group
name|group
init|=
operator|(
name|Group
operator|)
name|list
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|addNodeToGroup
argument_list|(
name|group
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|.
name|isFull
argument_list|()
condition|)
block|{
name|list
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|fullGroups
operator|.
name|add
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|group
operator|.
name|isUsable
argument_list|()
condition|)
block|{
name|list
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|completeGroups
operator|.
name|add
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|protected
name|void
name|addNodeToGroup
parameter_list|(
name|Group
name|group
parameter_list|,
name|Node
name|node
parameter_list|)
block|{
name|NodeMemberships
name|memberships
init|=
operator|(
name|NodeMemberships
operator|)
name|nodeMemberships
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|memberships
operator|==
literal|null
condition|)
block|{
name|memberships
operator|=
operator|new
name|NodeMemberships
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|nodeMemberships
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|memberships
argument_list|)
expr_stmt|;
block|}
name|memberships
operator|.
name|addToGroup
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|boolean
name|removeNodeFromGroup
parameter_list|(
name|Group
name|group
parameter_list|,
name|Node
name|node
parameter_list|)
block|{
name|NodeMemberships
name|memberships
init|=
operator|(
name|NodeMemberships
operator|)
name|nodeMemberships
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|memberships
operator|!=
literal|null
condition|)
block|{
return|return
name|memberships
operator|.
name|removeFromGroup
argument_list|(
name|group
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|protected
name|void
name|addGroup
parameter_list|(
name|Group
name|group
parameter_list|)
block|{
name|groups
operator|.
name|add
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|.
name|isFull
argument_list|()
condition|)
block|{
name|fullGroups
operator|.
name|add
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|group
operator|.
name|isUsable
argument_list|()
condition|)
block|{
name|completeGroups
operator|.
name|add
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|incompleteGroups
operator|.
name|add
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|Group
name|createGroup
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
return|return
operator|new
name|Group
argument_list|(
name|minimumMemberCount
argument_list|,
name|maximumMemberCount
argument_list|)
return|;
block|}
comment|/**      * Returns true if we can add a new group to the cluster      */
specifier|protected
name|boolean
name|canCreateGroup
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
return|return
operator|(
name|maximumGroups
operator|<
literal|0
operator|||
name|groups
operator|.
name|size
argument_list|()
operator|<
name|maximumGroups
operator|)
operator|&&
name|canBeMaster
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/**      * Returns true if the given node can be a master      */
specifier|protected
name|boolean
name|canBeMaster
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
return|return
name|masterFilter
operator|==
literal|null
operator|||
name|masterFilter
operator|.
name|evaluate
argument_list|(
name|node
argument_list|)
return|;
block|}
block|}
end_class

end_unit

