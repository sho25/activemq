begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|activemq
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|BytesMessage
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Destination
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|IllegalStateException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|InvalidDestinationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|InvalidSelectorException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|JMSException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|MapMessage
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|MessageConsumer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|MessageListener
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|MessageProducer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|ObjectMessage
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|QueueBrowser
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|QueueReceiver
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|QueueSender
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|QueueSession
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Session
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|StreamMessage
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TemporaryQueue
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TemporaryTopic
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TextMessage
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Topic
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TopicPublisher
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TopicSession
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TopicSubscriber
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TransactionRolledBackException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|blob
operator|.
name|BlobDownloader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|blob
operator|.
name|BlobTransferPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|blob
operator|.
name|BlobUploader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQBlobMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQBytesMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQDestination
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQMapMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQObjectMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQStreamMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQTempDestination
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQTempQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQTempTopic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQTextMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQTopic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|Command
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ConsumerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|MessageAck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|MessageDispatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|MessageId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ProducerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|RemoveInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|Response
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|SessionId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|SessionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|TransactionId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|management
operator|.
name|JMSSessionStatsImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|management
operator|.
name|StatsCapable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|management
operator|.
name|StatsImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|thread
operator|.
name|Scheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transaction
operator|.
name|Synchronization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|usage
operator|.
name|MemoryUsage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|Callback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|LongSequenceGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  *<P>  * A<CODE>Session</CODE> object is a single-threaded context for producing  * and consuming messages. Although it may allocate provider resources outside  * the Java virtual machine (JVM), it is considered a lightweight JMS object.  *<P>  * A session serves several purposes:  *<UL>  *<LI>It is a factory for its message producers and consumers.  *<LI>It supplies provider-optimized message factories.  *<LI>It is a factory for<CODE>TemporaryTopics</CODE> and  *<CODE>TemporaryQueues</CODE>.  *<LI>It provides a way to create<CODE>Queue</CODE> or<CODE>Topic</CODE>  * objects for those clients that need to dynamically manipulate  * provider-specific destination names.  *<LI>It supports a single series of transactions that combine work spanning  * its producers and consumers into atomic units.  *<LI>It defines a serial order for the messages it consumes and the messages  * it produces.  *<LI>It retains messages it consumes until they have been acknowledged.  *<LI>It serializes execution of message listeners registered with its message  * consumers.  *<LI>It is a factory for<CODE>QueueBrowsers</CODE>.  *</UL>  *<P>  * A session can create and service multiple message producers and consumers.  *<P>  * One typical use is to have a thread block on a synchronous  *<CODE>MessageConsumer</CODE> until a message arrives. The thread may then  * use one or more of the<CODE>Session</CODE>'s<CODE>MessageProducer</CODE>s.  *<P>  * If a client desires to have one thread produce messages while others consume  * them, the client should use a separate session for its producing thread.  *<P>  * Once a connection has been started, any session with one or more registered  * message listeners is dedicated to the thread of control that delivers  * messages to it. It is erroneous for client code to use this session or any of  * its constituent objects from another thread of control. The only exception to  * this rule is the use of the session or connection<CODE>close</CODE>  * method.  *<P>  * It should be easy for most clients to partition their work naturally into  * sessions. This model allows clients to start simply and incrementally add  * message processing complexity as their need for concurrency grows.  *<P>  * The<CODE>close</CODE> method is the only session method that can be called  * while some other session method is being executed in another thread.  *<P>  * A session may be specified as transacted. Each transacted session supports a  * single series of transactions. Each transaction groups a set of message sends  * and a set of message receives into an atomic unit of work. In effect,  * transactions organize a session's input message stream and output message  * stream into series of atomic units. When a transaction commits, its atomic  * unit of input is acknowledged and its associated atomic unit of output is  * sent. If a transaction rollback is done, the transaction's sent messages are  * destroyed and the session's input is automatically recovered.  *<P>  * The content of a transaction's input and output units is simply those  * messages that have been produced and consumed within the session's current  * transaction.  *<P>  * A transaction is completed using either its session's<CODE>commit</CODE>  * method or its session's<CODE>rollback</CODE> method. The completion of a  * session's current transaction automatically begins the next. The result is  * that a transacted session always has a current transaction within which its  * work is done.  *<P>  * The Java Transaction Service (JTS) or some other transaction monitor may be  * used to combine a session's transaction with transactions on other resources  * (databases, other JMS sessions, etc.). Since Java distributed transactions  * are controlled via the Java Transaction API (JTA), use of the session's  *<CODE>commit</CODE> and<CODE>rollback</CODE> methods in this context is  * prohibited.  *<P>  * The JMS API does not require support for JTA; however, it does define how a  * provider supplies this support.  *<P>  * Although it is also possible for a JMS client to handle distributed  * transactions directly, it is unlikely that many JMS clients will do this.  * Support for JTA in the JMS API is targeted at systems vendors who will be  * integrating the JMS API into their application server products.  *  *  * @see javax.jms.Session  * @see javax.jms.QueueSession  * @see javax.jms.TopicSession  * @see javax.jms.XASession  */
end_comment

begin_class
specifier|public
class|class
name|ActiveMQSession
implements|implements
name|Session
implements|,
name|QueueSession
implements|,
name|TopicSession
implements|,
name|StatsCapable
implements|,
name|ActiveMQDispatcher
block|{
comment|/**      * Only acknowledge an individual message - using message.acknowledge()      * as opposed to CLIENT_ACKNOWLEDGE which      * acknowledges all messages consumed by a session at when acknowledge()      * is called      */
specifier|public
specifier|static
specifier|final
name|int
name|INDIVIDUAL_ACKNOWLEDGE
init|=
literal|4
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|MAX_ACK_CONSTANT
init|=
name|INDIVIDUAL_ACKNOWLEDGE
decl_stmt|;
specifier|public
specifier|static
interface|interface
name|DeliveryListener
block|{
name|void
name|beforeDelivery
parameter_list|(
name|ActiveMQSession
name|session
parameter_list|,
name|Message
name|msg
parameter_list|)
function_decl|;
name|void
name|afterDelivery
parameter_list|(
name|ActiveMQSession
name|session
parameter_list|,
name|Message
name|msg
parameter_list|)
function_decl|;
block|}
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ActiveMQSession
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ThreadPoolExecutor
name|connectionExecutor
decl_stmt|;
specifier|protected
name|int
name|acknowledgementMode
decl_stmt|;
specifier|protected
specifier|final
name|ActiveMQConnection
name|connection
decl_stmt|;
specifier|protected
specifier|final
name|SessionInfo
name|info
decl_stmt|;
specifier|protected
specifier|final
name|LongSequenceGenerator
name|consumerIdGenerator
init|=
operator|new
name|LongSequenceGenerator
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|LongSequenceGenerator
name|producerIdGenerator
init|=
operator|new
name|LongSequenceGenerator
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|LongSequenceGenerator
name|deliveryIdGenerator
init|=
operator|new
name|LongSequenceGenerator
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|ActiveMQSessionExecutor
name|executor
decl_stmt|;
specifier|protected
specifier|final
name|AtomicBoolean
name|started
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|ActiveMQMessageConsumer
argument_list|>
name|consumers
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|ActiveMQMessageConsumer
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|ActiveMQMessageProducer
argument_list|>
name|producers
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|ActiveMQMessageProducer
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
name|boolean
name|closed
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|synchronizationRegistered
decl_stmt|;
specifier|protected
name|boolean
name|asyncDispatch
decl_stmt|;
specifier|protected
name|boolean
name|sessionAsyncDispatch
decl_stmt|;
specifier|protected
specifier|final
name|boolean
name|debug
decl_stmt|;
specifier|protected
specifier|final
name|Object
name|sendMutex
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|Object
name|redeliveryGuard
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|clearInProgress
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
specifier|private
name|MessageListener
name|messageListener
decl_stmt|;
specifier|private
specifier|final
name|JMSSessionStatsImpl
name|stats
decl_stmt|;
specifier|private
name|TransactionContext
name|transactionContext
decl_stmt|;
specifier|private
name|DeliveryListener
name|deliveryListener
decl_stmt|;
specifier|private
name|MessageTransformer
name|transformer
decl_stmt|;
specifier|private
name|BlobTransferPolicy
name|blobTransferPolicy
decl_stmt|;
specifier|private
name|long
name|lastDeliveredSequenceId
init|=
operator|-
literal|2
decl_stmt|;
comment|/**      * Construct the Session      *      * @param connection      * @param sessionId      * @param acknowledgeMode n.b if transacted - the acknowledgeMode ==      *                Session.SESSION_TRANSACTED      * @param asyncDispatch      * @param sessionAsyncDispatch      * @throws JMSException on internal error      */
specifier|protected
name|ActiveMQSession
parameter_list|(
name|ActiveMQConnection
name|connection
parameter_list|,
name|SessionId
name|sessionId
parameter_list|,
name|int
name|acknowledgeMode
parameter_list|,
name|boolean
name|asyncDispatch
parameter_list|,
name|boolean
name|sessionAsyncDispatch
parameter_list|)
throws|throws
name|JMSException
block|{
name|this
operator|.
name|debug
operator|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
expr_stmt|;
name|this
operator|.
name|connection
operator|=
name|connection
expr_stmt|;
name|this
operator|.
name|acknowledgementMode
operator|=
name|acknowledgeMode
expr_stmt|;
name|this
operator|.
name|asyncDispatch
operator|=
name|asyncDispatch
expr_stmt|;
name|this
operator|.
name|sessionAsyncDispatch
operator|=
name|sessionAsyncDispatch
expr_stmt|;
name|this
operator|.
name|info
operator|=
operator|new
name|SessionInfo
argument_list|(
name|connection
operator|.
name|getConnectionInfo
argument_list|()
argument_list|,
name|sessionId
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|setTransactionContext
argument_list|(
operator|new
name|TransactionContext
argument_list|(
name|connection
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|new
name|JMSSessionStatsImpl
argument_list|(
name|producers
argument_list|,
name|consumers
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|.
name|asyncSendPacket
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|setTransformer
argument_list|(
name|connection
operator|.
name|getTransformer
argument_list|()
argument_list|)
expr_stmt|;
name|setBlobTransferPolicy
argument_list|(
name|connection
operator|.
name|getBlobTransferPolicy
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|connectionExecutor
operator|=
name|connection
operator|.
name|getExecutor
argument_list|()
expr_stmt|;
name|this
operator|.
name|executor
operator|=
operator|new
name|ActiveMQSessionExecutor
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|connection
operator|.
name|addSession
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|.
name|isStarted
argument_list|()
condition|)
block|{
name|start
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
name|ActiveMQSession
parameter_list|(
name|ActiveMQConnection
name|connection
parameter_list|,
name|SessionId
name|sessionId
parameter_list|,
name|int
name|acknowledgeMode
parameter_list|,
name|boolean
name|asyncDispatch
parameter_list|)
throws|throws
name|JMSException
block|{
name|this
argument_list|(
name|connection
argument_list|,
name|sessionId
argument_list|,
name|acknowledgeMode
argument_list|,
name|asyncDispatch
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the transaction context of the session.      *      * @param transactionContext - provides the means to control a JMS      *                transaction.      */
specifier|public
name|void
name|setTransactionContext
parameter_list|(
name|TransactionContext
name|transactionContext
parameter_list|)
block|{
name|this
operator|.
name|transactionContext
operator|=
name|transactionContext
expr_stmt|;
block|}
comment|/**      * Returns the transaction context of the session.      *      * @return transactionContext - session's transaction context.      */
specifier|public
name|TransactionContext
name|getTransactionContext
parameter_list|()
block|{
return|return
name|transactionContext
return|;
block|}
comment|/*      * (non-Javadoc)      *      * @see org.apache.activemq.management.StatsCapable#getStats()      */
annotation|@
name|Override
specifier|public
name|StatsImpl
name|getStats
parameter_list|()
block|{
return|return
name|stats
return|;
block|}
comment|/**      * Returns the session's statistics.      *      * @return stats - session's statistics.      */
specifier|public
name|JMSSessionStatsImpl
name|getSessionStats
parameter_list|()
block|{
return|return
name|stats
return|;
block|}
comment|/**      * Creates a<CODE>BytesMessage</CODE> object. A<CODE>BytesMessage</CODE>      * object is used to send a message containing a stream of uninterpreted      * bytes.      *      * @return the an ActiveMQBytesMessage      * @throws JMSException if the JMS provider fails to create this message due      *                 to some internal error.      */
annotation|@
name|Override
specifier|public
name|BytesMessage
name|createBytesMessage
parameter_list|()
throws|throws
name|JMSException
block|{
name|ActiveMQBytesMessage
name|message
init|=
operator|new
name|ActiveMQBytesMessage
argument_list|()
decl_stmt|;
name|configureMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates a<CODE>MapMessage</CODE> object. A<CODE>MapMessage</CODE>      * object is used to send a self-defining set of name-value pairs, where      * names are<CODE>String</CODE> objects and values are primitive values      * in the Java programming language.      *      * @return an ActiveMQMapMessage      * @throws JMSException if the JMS provider fails to create this message due      *                 to some internal error.      */
annotation|@
name|Override
specifier|public
name|MapMessage
name|createMapMessage
parameter_list|()
throws|throws
name|JMSException
block|{
name|ActiveMQMapMessage
name|message
init|=
operator|new
name|ActiveMQMapMessage
argument_list|()
decl_stmt|;
name|configureMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates a<CODE>Message</CODE> object. The<CODE>Message</CODE>      * interface is the root interface of all JMS messages. A      *<CODE>Message</CODE> object holds all the standard message header      * information. It can be sent when a message containing only header      * information is sufficient.      *      * @return an ActiveMQMessage      * @throws JMSException if the JMS provider fails to create this message due      *                 to some internal error.      */
annotation|@
name|Override
specifier|public
name|Message
name|createMessage
parameter_list|()
throws|throws
name|JMSException
block|{
name|ActiveMQMessage
name|message
init|=
operator|new
name|ActiveMQMessage
argument_list|()
decl_stmt|;
name|configureMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates an<CODE>ObjectMessage</CODE> object. An      *<CODE>ObjectMessage</CODE> object is used to send a message that      * contains a serializable Java object.      *      * @return an ActiveMQObjectMessage      * @throws JMSException if the JMS provider fails to create this message due      *                 to some internal error.      */
annotation|@
name|Override
specifier|public
name|ObjectMessage
name|createObjectMessage
parameter_list|()
throws|throws
name|JMSException
block|{
name|ActiveMQObjectMessage
name|message
init|=
operator|new
name|ActiveMQObjectMessage
argument_list|()
decl_stmt|;
name|configureMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates an initialized<CODE>ObjectMessage</CODE> object. An      *<CODE>ObjectMessage</CODE> object is used to send a message that      * contains a serializable Java object.      *      * @param object the object to use to initialize this message      * @return an ActiveMQObjectMessage      * @throws JMSException if the JMS provider fails to create this message due      *                 to some internal error.      */
annotation|@
name|Override
specifier|public
name|ObjectMessage
name|createObjectMessage
parameter_list|(
name|Serializable
name|object
parameter_list|)
throws|throws
name|JMSException
block|{
name|ActiveMQObjectMessage
name|message
init|=
operator|new
name|ActiveMQObjectMessage
argument_list|()
decl_stmt|;
name|configureMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|message
operator|.
name|setObject
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates a<CODE>StreamMessage</CODE> object. A      *<CODE>StreamMessage</CODE> object is used to send a self-defining      * stream of primitive values in the Java programming language.      *      * @return an ActiveMQStreamMessage      * @throws JMSException if the JMS provider fails to create this message due      *                 to some internal error.      */
annotation|@
name|Override
specifier|public
name|StreamMessage
name|createStreamMessage
parameter_list|()
throws|throws
name|JMSException
block|{
name|ActiveMQStreamMessage
name|message
init|=
operator|new
name|ActiveMQStreamMessage
argument_list|()
decl_stmt|;
name|configureMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates a<CODE>TextMessage</CODE> object. A<CODE>TextMessage</CODE>      * object is used to send a message containing a<CODE>String</CODE>      * object.      *      * @return an ActiveMQTextMessage      * @throws JMSException if the JMS provider fails to create this message due      *                 to some internal error.      */
annotation|@
name|Override
specifier|public
name|TextMessage
name|createTextMessage
parameter_list|()
throws|throws
name|JMSException
block|{
name|ActiveMQTextMessage
name|message
init|=
operator|new
name|ActiveMQTextMessage
argument_list|()
decl_stmt|;
name|configureMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates an initialized<CODE>TextMessage</CODE> object. A      *<CODE>TextMessage</CODE> object is used to send a message containing a      *<CODE>String</CODE>.      *      * @param text the string used to initialize this message      * @return an ActiveMQTextMessage      * @throws JMSException if the JMS provider fails to create this message due      *                 to some internal error.      */
annotation|@
name|Override
specifier|public
name|TextMessage
name|createTextMessage
parameter_list|(
name|String
name|text
parameter_list|)
throws|throws
name|JMSException
block|{
name|ActiveMQTextMessage
name|message
init|=
operator|new
name|ActiveMQTextMessage
argument_list|()
decl_stmt|;
name|message
operator|.
name|setText
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|configureMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates an initialized<CODE>BlobMessage</CODE> object. A      *<CODE>BlobMessage</CODE> object is used to send a message containing a      *<CODE>URL</CODE> which points to some network addressible BLOB.      *      * @param url the network addressable URL used to pass directly to the      *                consumer      * @return a BlobMessage      * @throws JMSException if the JMS provider fails to create this message due      *                 to some internal error.      */
specifier|public
name|BlobMessage
name|createBlobMessage
parameter_list|(
name|URL
name|url
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
name|createBlobMessage
argument_list|(
name|url
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates an initialized<CODE>BlobMessage</CODE> object. A      *<CODE>BlobMessage</CODE> object is used to send a message containing a      *<CODE>URL</CODE> which points to some network addressible BLOB.      *      * @param url the network addressable URL used to pass directly to the      *                consumer      * @param deletedByBroker indicates whether or not the resource is deleted      *                by the broker when the message is acknowledged      * @return a BlobMessage      * @throws JMSException if the JMS provider fails to create this message due      *                 to some internal error.      */
specifier|public
name|BlobMessage
name|createBlobMessage
parameter_list|(
name|URL
name|url
parameter_list|,
name|boolean
name|deletedByBroker
parameter_list|)
throws|throws
name|JMSException
block|{
name|ActiveMQBlobMessage
name|message
init|=
operator|new
name|ActiveMQBlobMessage
argument_list|()
decl_stmt|;
name|configureMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|message
operator|.
name|setURL
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|message
operator|.
name|setDeletedByBroker
argument_list|(
name|deletedByBroker
argument_list|)
expr_stmt|;
name|message
operator|.
name|setBlobDownloader
argument_list|(
operator|new
name|BlobDownloader
argument_list|(
name|getBlobTransferPolicy
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates an initialized<CODE>BlobMessage</CODE> object. A      *<CODE>BlobMessage</CODE> object is used to send a message containing      * the<CODE>File</CODE> content. Before the message is sent the file      * conent will be uploaded to the broker or some other remote repository      * depending on the {@link #getBlobTransferPolicy()}.      *      * @param file the file to be uploaded to some remote repo (or the broker)      *                depending on the strategy      * @return a BlobMessage      * @throws JMSException if the JMS provider fails to create this message due      *                 to some internal error.      */
specifier|public
name|BlobMessage
name|createBlobMessage
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|JMSException
block|{
name|ActiveMQBlobMessage
name|message
init|=
operator|new
name|ActiveMQBlobMessage
argument_list|()
decl_stmt|;
name|configureMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|message
operator|.
name|setBlobUploader
argument_list|(
operator|new
name|BlobUploader
argument_list|(
name|getBlobTransferPolicy
argument_list|()
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|setBlobDownloader
argument_list|(
operator|new
name|BlobDownloader
argument_list|(
operator|(
name|getBlobTransferPolicy
argument_list|()
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|setDeletedByBroker
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|message
operator|.
name|setName
argument_list|(
name|file
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Creates an initialized<CODE>BlobMessage</CODE> object. A      *<CODE>BlobMessage</CODE> object is used to send a message containing      * the<CODE>File</CODE> content. Before the message is sent the file      * conent will be uploaded to the broker or some other remote repository      * depending on the {@link #getBlobTransferPolicy()}.<br/>      *<p>      * The caller of this method is responsible for closing the      * input stream that is used, however the stream can not be closed      * until<b>after</b> the message has been sent.  To have this class      * manage the stream and close it automatically, use the method      * {@link ActiveMQSession#createBlobMessage(File)}      *      * @param in the stream to be uploaded to some remote repo (or the broker)      *                depending on the strategy      * @return a BlobMessage      * @throws JMSException if the JMS provider fails to create this message due      *                 to some internal error.      */
specifier|public
name|BlobMessage
name|createBlobMessage
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|JMSException
block|{
name|ActiveMQBlobMessage
name|message
init|=
operator|new
name|ActiveMQBlobMessage
argument_list|()
decl_stmt|;
name|configureMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|message
operator|.
name|setBlobUploader
argument_list|(
operator|new
name|BlobUploader
argument_list|(
name|getBlobTransferPolicy
argument_list|()
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|setBlobDownloader
argument_list|(
operator|new
name|BlobDownloader
argument_list|(
name|getBlobTransferPolicy
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|message
operator|.
name|setDeletedByBroker
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
comment|/**      * Indicates whether the session is in transacted mode.      *      * @return true if the session is in transacted mode      * @throws JMSException if there is some internal error.      */
annotation|@
name|Override
specifier|public
name|boolean
name|getTransacted
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|isTransacted
argument_list|()
return|;
block|}
comment|/**      * Returns the acknowledgement mode of the session. The acknowledgement mode      * is set at the time that the session is created. If the session is      * transacted, the acknowledgement mode is ignored.      *      * @return If the session is not transacted, returns the current      *         acknowledgement mode for the session. If the session is      *         transacted, returns SESSION_TRANSACTED.      * @throws JMSException      * @see javax.jms.Connection#createSession(boolean,int)      * @since 1.1 exception JMSException if there is some internal error.      */
annotation|@
name|Override
specifier|public
name|int
name|getAcknowledgeMode
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|acknowledgementMode
return|;
block|}
comment|/**      * Commits all messages done in this transaction and releases any locks      * currently held.      *      * @throws JMSException if the JMS provider fails to commit the transaction      *                 due to some internal error.      * @throws TransactionRolledBackException if the transaction is rolled back      *                 due to some internal error during commit.      * @throws javax.jms.IllegalStateException if the method is not called by a      *                 transacted session.      */
annotation|@
name|Override
specifier|public
name|void
name|commit
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getTransacted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|javax
operator|.
name|jms
operator|.
name|IllegalStateException
argument_list|(
literal|"Not a transacted session"
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getSessionId
argument_list|()
operator|+
literal|" Transaction Commit :"
operator|+
name|transactionContext
operator|.
name|getTransactionId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|transactionContext
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
comment|/**      * Rolls back any messages done in this transaction and releases any locks      * currently held.      *      * @throws JMSException if the JMS provider fails to roll back the      *                 transaction due to some internal error.      * @throws javax.jms.IllegalStateException if the method is not called by a      *                 transacted session.      */
annotation|@
name|Override
specifier|public
name|void
name|rollback
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getTransacted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|javax
operator|.
name|jms
operator|.
name|IllegalStateException
argument_list|(
literal|"Not a transacted session"
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getSessionId
argument_list|()
operator|+
literal|" Transaction Rollback, txid:"
operator|+
name|transactionContext
operator|.
name|getTransactionId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|transactionContext
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
comment|/**      * Closes the session.      *<P>      * Since a provider may allocate some resources on behalf of a session      * outside the JVM, clients should close the resources when they are not      * needed. Relying on garbage collection to eventually reclaim these      * resources may not be timely enough.      *<P>      * There is no need to close the producers and consumers of a closed      * session.      *<P>      * This call will block until a<CODE>receive</CODE> call or message      * listener in progress has completed. A blocked message consumer      *<CODE>receive</CODE> call returns<CODE>null</CODE> when this session      * is closed.      *<P>      * Closing a transacted session must roll back the transaction in progress.      *<P>      * This method is the only<CODE>Session</CODE> method that can be called      * concurrently.      *<P>      * Invoking any other<CODE>Session</CODE> method on a closed session must      * throw a<CODE> JMSException.IllegalStateException</CODE>. Closing a      * closed session must<I>not</I> throw an exception.      *      * @throws JMSException if the JMS provider fails to close the session due      *                 to some internal error.      */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|JMSException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
if|if
condition|(
name|getTransactionContext
argument_list|()
operator|.
name|isInXATransaction
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|synchronizationRegistered
condition|)
block|{
name|synchronizationRegistered
operator|=
literal|true
expr_stmt|;
name|getTransactionContext
argument_list|()
operator|.
name|addSynchronization
argument_list|(
operator|new
name|Synchronization
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|afterCommit
parameter_list|()
throws|throws
name|Exception
block|{
name|doClose
argument_list|()
expr_stmt|;
name|synchronizationRegistered
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|afterRollback
parameter_list|()
throws|throws
name|Exception
block|{
name|doClose
argument_list|()
expr_stmt|;
name|synchronizationRegistered
operator|=
literal|false
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|doClose
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|doClose
parameter_list|()
throws|throws
name|JMSException
block|{
name|dispose
argument_list|()
expr_stmt|;
name|RemoveInfo
name|removeCommand
init|=
name|info
operator|.
name|createRemoveCommand
argument_list|()
decl_stmt|;
name|removeCommand
operator|.
name|setLastDeliveredSequenceId
argument_list|(
name|lastDeliveredSequenceId
argument_list|)
expr_stmt|;
name|connection
operator|.
name|asyncSendPacket
argument_list|(
name|removeCommand
argument_list|)
expr_stmt|;
block|}
specifier|final
name|AtomicInteger
name|clearRequestsCounter
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|void
name|clearMessagesInProgress
parameter_list|(
name|AtomicInteger
name|transportInterruptionProcessingComplete
parameter_list|)
block|{
name|clearRequestsCounter
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|executor
operator|.
name|clearMessagesInProgress
argument_list|()
expr_stmt|;
comment|// we are called from inside the transport reconnection logic which involves us
comment|// clearing all the connections' consumers dispatch and delivered lists. So rather
comment|// than trying to grab a mutex (which could be already owned by the message listener
comment|// calling the send or an ack) we allow it to complete in a separate thread via the
comment|// scheduler and notify us via connection.transportInterruptionProcessingComplete()
comment|//
comment|// We must be careful though not to allow multiple calls to this method from a
comment|// connection that is having issue becoming fully established from causing a large
comment|// build up of scheduled tasks to clear the same consumers over and over.
if|if
condition|(
name|consumers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|clearInProgress
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
for|for
control|(
specifier|final
name|ActiveMQMessageConsumer
name|consumer
range|:
name|consumers
control|)
block|{
name|consumer
operator|.
name|inProgressClearRequired
argument_list|()
expr_stmt|;
name|transportInterruptionProcessingComplete
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
try|try
block|{
name|connection
operator|.
name|getScheduler
argument_list|()
operator|.
name|executeAfterDelay
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|consumer
operator|.
name|clearMessagesInProgress
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|JMSException
name|e
parameter_list|)
block|{
name|connection
operator|.
name|onClientInternalException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|connection
operator|.
name|getScheduler
argument_list|()
operator|.
name|executeAfterDelay
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|clearInProgress
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|JMSException
name|e
parameter_list|)
block|{
name|connection
operator|.
name|onClientInternalException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|void
name|deliverAcks
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQMessageConsumer
argument_list|>
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|consumer
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|consumer
operator|.
name|deliverAcks
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
specifier|synchronized
name|void
name|dispose
parameter_list|()
throws|throws
name|JMSException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
try|try
block|{
name|executor
operator|.
name|close
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQMessageConsumer
argument_list|>
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|consumer
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|consumer
operator|.
name|setFailureError
argument_list|(
name|connection
operator|.
name|getFirstFailureError
argument_list|()
argument_list|)
expr_stmt|;
name|consumer
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|lastDeliveredSequenceId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|lastDeliveredSequenceId
argument_list|,
name|consumer
operator|.
name|getLastDeliveredSequenceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|consumers
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQMessageProducer
argument_list|>
name|iter
init|=
name|producers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageProducer
name|producer
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|producer
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
name|producers
operator|.
name|clear
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|getTransactionContext
argument_list|()
operator|.
name|isInLocalTransaction
argument_list|()
condition|)
block|{
name|rollback
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|JMSException
name|e
parameter_list|)
block|{                 }
block|}
finally|finally
block|{
name|connection
operator|.
name|removeSession
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|transactionContext
operator|=
literal|null
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Checks that the session is not closed then configures the message      */
specifier|protected
name|void
name|configureMessage
parameter_list|(
name|ActiveMQMessage
name|message
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|message
operator|.
name|setConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
comment|/**      * Check if the session is closed. It is used for ensuring that the session      * is open before performing various operations.      *      * @throws IllegalStateException if the Session is closed      */
specifier|protected
name|void
name|checkClosed
parameter_list|()
throws|throws
name|IllegalStateException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The Session is closed"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Checks if the session is closed.      *      * @return true if the session is closed, false otherwise.      */
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|closed
return|;
block|}
comment|/**      * Stops message delivery in this session, and restarts message delivery      * with the oldest unacknowledged message.      *<P>      * All consumers deliver messages in a serial order. Acknowledging a      * received message automatically acknowledges all messages that have been      * delivered to the client.      *<P>      * Restarting a session causes it to take the following actions:      *<UL>      *<LI>Stop message delivery      *<LI>Mark all messages that might have been delivered but not      * acknowledged as "redelivered"      *<LI>Restart the delivery sequence including all unacknowledged messages      * that had been previously delivered. Redelivered messages do not have to      * be delivered in exactly their original delivery order.      *</UL>      *      * @throws JMSException if the JMS provider fails to stop and restart      *                 message delivery due to some internal error.      * @throws IllegalStateException if the method is called by a transacted      *                 session.      */
annotation|@
name|Override
specifier|public
name|void
name|recover
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|getTransacted
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"This session is transacted"
argument_list|)
throw|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQMessageConsumer
argument_list|>
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|c
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|c
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Returns the session's distinguished message listener (optional).      *      * @return the message listener associated with this session      * @throws JMSException if the JMS provider fails to get the message      *                 listener due to an internal error.      * @see javax.jms.Session#setMessageListener(javax.jms.MessageListener)      * @see javax.jms.ServerSessionPool      * @see javax.jms.ServerSession      */
annotation|@
name|Override
specifier|public
name|MessageListener
name|getMessageListener
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|messageListener
return|;
block|}
comment|/**      * Sets the session's distinguished message listener (optional).      *<P>      * When the distinguished message listener is set, no other form of message      * receipt in the session can be used; however, all forms of sending      * messages are still supported.      *<P>      * If this session has been closed, then an {@link IllegalStateException} is      * thrown, if trying to set a new listener. However setting the listener      * to<tt>null</tt> is allowed, to clear the listener, even if this session      * has been closed prior.      *<P>      * This is an expert facility not used by regular JMS clients.      *      * @param listener the message listener to associate with this session      * @throws JMSException if the JMS provider fails to set the message      *                 listener due to an internal error.      * @see javax.jms.Session#getMessageListener()      * @see javax.jms.ServerSessionPool      * @see javax.jms.ServerSession      */
annotation|@
name|Override
specifier|public
name|void
name|setMessageListener
parameter_list|(
name|MessageListener
name|listener
parameter_list|)
throws|throws
name|JMSException
block|{
comment|// only check for closed if we set a new listener, as we allow to clear
comment|// the listener, such as when an application is shutting down, and is
comment|// no longer using a message listener on this session
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|checkClosed
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|messageListener
operator|=
name|listener
expr_stmt|;
if|if
condition|(
name|listener
operator|!=
literal|null
condition|)
block|{
name|executor
operator|.
name|setDispatchedBySessionPool
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Optional operation, intended to be used only by Application Servers, not      * by ordinary JMS clients.      *      * @see javax.jms.ServerSession      */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|MessageDispatch
name|messageDispatch
decl_stmt|;
while|while
condition|(
operator|(
name|messageDispatch
operator|=
name|executor
operator|.
name|dequeueNoWait
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
specifier|final
name|MessageDispatch
name|md
init|=
name|messageDispatch
decl_stmt|;
specifier|final
name|ActiveMQMessage
name|message
init|=
operator|(
name|ActiveMQMessage
operator|)
name|md
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|MessageAck
name|earlyAck
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|message
operator|.
name|isExpired
argument_list|()
condition|)
block|{
name|earlyAck
operator|=
operator|new
name|MessageAck
argument_list|(
name|md
argument_list|,
name|MessageAck
operator|.
name|EXPIRED_ACK_TYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|earlyAck
operator|.
name|setFirstMessageId
argument_list|(
name|message
operator|.
name|getMessageId
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|connection
operator|.
name|isDuplicate
argument_list|(
name|ActiveMQSession
operator|.
name|this
argument_list|,
name|message
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} got duplicate: {}"
argument_list|,
name|this
argument_list|,
name|message
operator|.
name|getMessageId
argument_list|()
argument_list|)
expr_stmt|;
name|earlyAck
operator|=
operator|new
name|MessageAck
argument_list|(
name|md
argument_list|,
name|MessageAck
operator|.
name|POSION_ACK_TYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|earlyAck
operator|.
name|setFirstMessageId
argument_list|(
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|getMessageId
argument_list|()
argument_list|)
expr_stmt|;
name|earlyAck
operator|.
name|setPoisonCause
argument_list|(
operator|new
name|Throwable
argument_list|(
literal|"Duplicate delivery to "
operator|+
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|earlyAck
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|asyncSendPacket
argument_list|(
name|earlyAck
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"error dispatching ack: {} "
argument_list|,
name|earlyAck
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|connection
operator|.
name|onClientInternalException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|isClientAcknowledge
argument_list|()
operator|||
name|isIndividualAcknowledge
argument_list|()
condition|)
block|{
name|message
operator|.
name|setAcknowledgeCallback
argument_list|(
operator|new
name|Callback
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|execute
parameter_list|()
throws|throws
name|Exception
block|{                     }
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deliveryListener
operator|!=
literal|null
condition|)
block|{
name|deliveryListener
operator|.
name|beforeDelivery
argument_list|(
name|this
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
name|md
operator|.
name|setDeliverySequenceId
argument_list|(
name|getNextDeliveryId
argument_list|()
argument_list|)
expr_stmt|;
name|lastDeliveredSequenceId
operator|=
name|message
operator|.
name|getMessageId
argument_list|()
operator|.
name|getBrokerSequenceId
argument_list|()
expr_stmt|;
specifier|final
name|MessageAck
name|ack
init|=
operator|new
name|MessageAck
argument_list|(
name|md
argument_list|,
name|MessageAck
operator|.
name|STANDARD_ACK_TYPE
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|AtomicBoolean
name|afterDeliveryError
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/*             * The redelivery guard is to allow the endpoint lifecycle to complete before the messsage is dispatched.             * We dont want the after deliver being called after the redeliver as it may cause some weird stuff.             * */
synchronized|synchronized
init|(
name|redeliveryGuard
init|)
block|{
try|try
block|{
name|ack
operator|.
name|setFirstMessageId
argument_list|(
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|getMessageId
argument_list|()
argument_list|)
expr_stmt|;
name|doStartTransaction
argument_list|()
expr_stmt|;
name|ack
operator|.
name|setTransactionId
argument_list|(
name|getTransactionContext
argument_list|()
operator|.
name|getTransactionId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
operator|.
name|getTransactionId
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|getTransactionContext
argument_list|()
operator|.
name|addSynchronization
argument_list|(
operator|new
name|Synchronization
argument_list|()
block|{
specifier|final
name|int
name|clearRequestCount
init|=
operator|(
name|clearRequestsCounter
operator|.
name|get
argument_list|()
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|?
name|clearRequestsCounter
operator|.
name|incrementAndGet
argument_list|()
else|:
name|clearRequestsCounter
operator|.
name|get
argument_list|()
operator|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|beforeEnd
parameter_list|()
throws|throws
name|Exception
block|{
comment|// validate our consumer so we don't push stale acks that get ignored
if|if
condition|(
name|ack
operator|.
name|getTransactionId
argument_list|()
operator|.
name|isXATransaction
argument_list|()
operator|&&
operator|!
name|connection
operator|.
name|hasDispatcher
argument_list|(
name|ack
operator|.
name|getConsumerId
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"forcing rollback - {} consumer no longer active on {}"
argument_list|,
name|ack
argument_list|,
name|connection
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|TransactionRolledBackException
argument_list|(
literal|"consumer "
operator|+
name|ack
operator|.
name|getConsumerId
argument_list|()
operator|+
literal|" no longer active on "
operator|+
name|connection
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"beforeEnd ack {}"
argument_list|,
name|ack
argument_list|)
expr_stmt|;
name|sendAck
argument_list|(
name|ack
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|afterRollback
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"rollback {}"
argument_list|,
name|ack
argument_list|,
operator|new
name|Throwable
argument_list|(
literal|"here"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// ensure we don't filter this as a duplicate
name|connection
operator|.
name|rollbackDuplicate
argument_list|(
name|ActiveMQSession
operator|.
name|this
argument_list|,
name|md
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// don't redeliver if we have been interrupted b/c the broker will redeliver on reconnect
if|if
condition|(
name|clearRequestsCounter
operator|.
name|get
argument_list|()
operator|>
name|clearRequestCount
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No redelivery of {} on rollback of {} due to failover of {}"
argument_list|,
name|md
argument_list|,
name|ack
operator|.
name|getTransactionId
argument_list|()
argument_list|,
name|connection
operator|.
name|getTransport
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// validate our consumer so we don't push stale acks that get ignored or redeliver what will be redispatched
if|if
condition|(
name|ack
operator|.
name|getTransactionId
argument_list|()
operator|.
name|isXATransaction
argument_list|()
operator|&&
operator|!
name|connection
operator|.
name|hasDispatcher
argument_list|(
name|ack
operator|.
name|getConsumerId
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No local redelivery of {} on rollback of {} because consumer is no longer active on {}"
argument_list|,
name|md
argument_list|,
name|ack
operator|.
name|getTransactionId
argument_list|()
argument_list|,
name|connection
operator|.
name|getTransport
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|RedeliveryPolicy
name|redeliveryPolicy
init|=
name|connection
operator|.
name|getRedeliveryPolicy
argument_list|()
decl_stmt|;
name|int
name|redeliveryCounter
init|=
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|getRedeliveryCounter
argument_list|()
decl_stmt|;
if|if
condition|(
name|redeliveryPolicy
operator|.
name|getMaximumRedeliveries
argument_list|()
operator|!=
name|RedeliveryPolicy
operator|.
name|NO_MAXIMUM_REDELIVERIES
operator|&&
name|redeliveryCounter
operator|>=
name|redeliveryPolicy
operator|.
name|getMaximumRedeliveries
argument_list|()
condition|)
block|{
comment|// We need to NACK the messages so that they get
comment|// sent to the
comment|// DLQ.
comment|// Acknowledge the last message.
name|MessageAck
name|ack
init|=
operator|new
name|MessageAck
argument_list|(
name|md
argument_list|,
name|MessageAck
operator|.
name|POSION_ACK_TYPE
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|ack
operator|.
name|setFirstMessageId
argument_list|(
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|getMessageId
argument_list|()
argument_list|)
expr_stmt|;
name|ack
operator|.
name|setPoisonCause
argument_list|(
operator|new
name|Throwable
argument_list|(
literal|"Exceeded ra redelivery policy limit:"
operator|+
name|redeliveryPolicy
argument_list|)
argument_list|)
expr_stmt|;
name|asyncSendPacket
argument_list|(
name|ack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MessageAck
name|ack
init|=
operator|new
name|MessageAck
argument_list|(
name|md
argument_list|,
name|MessageAck
operator|.
name|REDELIVERED_ACK_TYPE
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|ack
operator|.
name|setFirstMessageId
argument_list|(
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|getMessageId
argument_list|()
argument_list|)
expr_stmt|;
name|asyncSendPacket
argument_list|(
name|ack
argument_list|)
expr_stmt|;
comment|// Figure out how long we should wait to resend
comment|// this message.
name|long
name|redeliveryDelay
init|=
name|redeliveryPolicy
operator|.
name|getInitialRedeliveryDelay
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|redeliveryCounter
condition|;
name|i
operator|++
control|)
block|{
name|redeliveryDelay
operator|=
name|redeliveryPolicy
operator|.
name|getNextRedeliveryDelay
argument_list|(
name|redeliveryDelay
argument_list|)
expr_stmt|;
block|}
comment|/*                                     * If we are a non blocking delivery then we need to stop the executor to avoid more                                     * messages being delivered, once the message is redelivered we can restart it.                                     * */
if|if
condition|(
operator|!
name|connection
operator|.
name|isNonBlockingRedelivery
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Blocking session until re-delivery..."
argument_list|)
expr_stmt|;
name|executor
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|connection
operator|.
name|getScheduler
argument_list|()
operator|.
name|executeAfterDelay
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|/*                                             * wait for the first delivery to be complete, i.e. after delivery has been called.                                             * */
synchronized|synchronized
init|(
name|redeliveryGuard
init|)
block|{
comment|/*                                                 * If its non blocking then we can just dispatch in a new session.                                                 * */
if|if
condition|(
name|connection
operator|.
name|isNonBlockingRedelivery
argument_list|()
condition|)
block|{
operator|(
operator|(
name|ActiveMQDispatcher
operator|)
name|md
operator|.
name|getConsumer
argument_list|()
operator|)
operator|.
name|dispatch
argument_list|(
name|md
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*                                                     * If there has been an error thrown during afterDelivery then the                                                     * endpoint will be marked as dead so redelivery will fail (and eventually                                                     * the session marked as stale), in this case we can only call dispatch                                                     * which will create a new session with a new endpoint.                                                     * */
if|if
condition|(
name|afterDeliveryError
operator|.
name|get
argument_list|()
condition|)
block|{
operator|(
operator|(
name|ActiveMQDispatcher
operator|)
name|md
operator|.
name|getConsumer
argument_list|()
operator|)
operator|.
name|dispatch
argument_list|(
name|md
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|executor
operator|.
name|executeFirst
argument_list|(
name|md
argument_list|)
expr_stmt|;
name|executor
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
argument_list|,
name|redeliveryDelay
argument_list|)
expr_stmt|;
block|}
name|md
operator|.
name|getMessage
argument_list|()
operator|.
name|onMessageRolledBack
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|trace
argument_list|(
literal|"{} onMessage({})"
argument_list|,
name|this
argument_list|,
name|message
operator|.
name|getMessageId
argument_list|()
argument_list|)
expr_stmt|;
name|messageListener
operator|.
name|onMessage
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isClosed
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{} error dispatching message: {} "
argument_list|,
name|this
argument_list|,
name|message
operator|.
name|getMessageId
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getTransactionContext
argument_list|()
operator|!=
literal|null
operator|&&
name|getTransactionContext
argument_list|()
operator|.
name|isInXATransaction
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Marking transaction: {} rollbackOnly"
argument_list|,
name|getTransactionContext
argument_list|()
argument_list|)
expr_stmt|;
name|getTransactionContext
argument_list|()
operator|.
name|setRollbackOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// A problem while invoking the MessageListener does not
comment|// in general indicate a problem with the connection to the broker, i.e.
comment|// it will usually be sufficient to let the afterDelivery() method either
comment|// commit or roll back in order to deal with the exception.
comment|// However, we notify any registered client internal exception listener
comment|// of the problem.
name|connection
operator|.
name|onClientInternalException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|ack
operator|.
name|getTransactionId
argument_list|()
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|asyncSendPacket
argument_list|(
name|ack
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|connection
operator|.
name|onClientInternalException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|deliveryListener
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|deliveryListener
operator|.
name|afterDelivery
argument_list|(
name|this
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to call after delivery"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|afterDeliveryError
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|t
argument_list|)
throw|;
block|}
block|}
block|}
comment|/*             * this can be outside the try/catch as if an exception is thrown then this session will be marked as stale anyway.             * It also needs to be outside the redelivery guard.             * */
try|try
block|{
name|executor
operator|.
name|waitForQueueRestart
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|connection
operator|.
name|onClientInternalException
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Creates a<CODE>MessageProducer</CODE> to send messages to the      * specified destination.      *<P>      * A client uses a<CODE>MessageProducer</CODE> object to send messages to      * a destination. Since<CODE>Queue</CODE> and<CODE>Topic</CODE> both      * inherit from<CODE>Destination</CODE>, they can be used in the      * destination parameter to create a<CODE>MessageProducer</CODE> object.      *      * @param destination the<CODE>Destination</CODE> to send to, or null if      *                this is a producer which does not have a specified      *                destination.      * @return the MessageProducer      * @throws JMSException if the session fails to create a MessageProducer due      *                 to some internal error.      * @throws InvalidDestinationException if an invalid destination is      *                 specified.      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|MessageProducer
name|createProducer
parameter_list|(
name|Destination
name|destination
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|destination
operator|instanceof
name|CustomDestination
condition|)
block|{
name|CustomDestination
name|customDestination
init|=
operator|(
name|CustomDestination
operator|)
name|destination
decl_stmt|;
return|return
name|customDestination
operator|.
name|createProducer
argument_list|(
name|this
argument_list|)
return|;
block|}
name|int
name|timeSendOut
init|=
name|connection
operator|.
name|getSendTimeout
argument_list|()
decl_stmt|;
return|return
operator|new
name|ActiveMQMessageProducer
argument_list|(
name|this
argument_list|,
name|getNextProducerId
argument_list|()
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|destination
argument_list|)
argument_list|,
name|timeSendOut
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>MessageConsumer</CODE> for the specified destination.      * Since<CODE>Queue</CODE> and<CODE> Topic</CODE> both inherit from      *<CODE>Destination</CODE>, they can be used in the destination      * parameter to create a<CODE>MessageConsumer</CODE>.      *      * @param destination the<CODE>Destination</CODE> to access.      * @return the MessageConsumer      * @throws JMSException if the session fails to create a consumer due to      *                 some internal error.      * @throws InvalidDestinationException if an invalid destination is      *                 specified.      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|MessageConsumer
name|createConsumer
parameter_list|(
name|Destination
name|destination
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
name|createConsumer
argument_list|(
name|destination
argument_list|,
operator|(
name|String
operator|)
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>MessageConsumer</CODE> for the specified destination,      * using a message selector. Since<CODE> Queue</CODE> and      *<CODE>Topic</CODE> both inherit from<CODE>Destination</CODE>, they      * can be used in the destination parameter to create a      *<CODE>MessageConsumer</CODE>.      *<P>      * A client uses a<CODE>MessageConsumer</CODE> object to receive messages      * that have been sent to a destination.      *      * @param destination the<CODE>Destination</CODE> to access      * @param messageSelector only messages with properties matching the message      *                selector expression are delivered. A value of null or an      *                empty string indicates that there is no message selector      *                for the message consumer.      * @return the MessageConsumer      * @throws JMSException if the session fails to create a MessageConsumer due      *                 to some internal error.      * @throws InvalidDestinationException if an invalid destination is      *                 specified.      * @throws InvalidSelectorException if the message selector is invalid.      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|MessageConsumer
name|createConsumer
parameter_list|(
name|Destination
name|destination
parameter_list|,
name|String
name|messageSelector
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
name|createConsumer
argument_list|(
name|destination
argument_list|,
name|messageSelector
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>MessageConsumer</CODE> for the specified destination.      * Since<CODE>Queue</CODE> and<CODE> Topic</CODE> both inherit from      *<CODE>Destination</CODE>, they can be used in the destination      * parameter to create a<CODE>MessageConsumer</CODE>.      *      * @param destination the<CODE>Destination</CODE> to access.      * @param messageListener the listener to use for async consumption of messages      * @return the MessageConsumer      * @throws JMSException if the session fails to create a consumer due to      *                 some internal error.      * @throws InvalidDestinationException if an invalid destination is      *                 specified.      * @since 1.1      */
specifier|public
name|MessageConsumer
name|createConsumer
parameter_list|(
name|Destination
name|destination
parameter_list|,
name|MessageListener
name|messageListener
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
name|createConsumer
argument_list|(
name|destination
argument_list|,
literal|null
argument_list|,
name|messageListener
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>MessageConsumer</CODE> for the specified destination,      * using a message selector. Since<CODE> Queue</CODE> and      *<CODE>Topic</CODE> both inherit from<CODE>Destination</CODE>, they      * can be used in the destination parameter to create a      *<CODE>MessageConsumer</CODE>.      *<P>      * A client uses a<CODE>MessageConsumer</CODE> object to receive messages      * that have been sent to a destination.      *      * @param destination the<CODE>Destination</CODE> to access      * @param messageSelector only messages with properties matching the message      *                selector expression are delivered. A value of null or an      *                empty string indicates that there is no message selector      *                for the message consumer.      * @param messageListener the listener to use for async consumption of messages      * @return the MessageConsumer      * @throws JMSException if the session fails to create a MessageConsumer due      *                 to some internal error.      * @throws InvalidDestinationException if an invalid destination is      *                 specified.      * @throws InvalidSelectorException if the message selector is invalid.      * @since 1.1      */
specifier|public
name|MessageConsumer
name|createConsumer
parameter_list|(
name|Destination
name|destination
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|MessageListener
name|messageListener
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
name|createConsumer
argument_list|(
name|destination
argument_list|,
name|messageSelector
argument_list|,
literal|false
argument_list|,
name|messageListener
argument_list|)
return|;
block|}
comment|/**      * Creates<CODE>MessageConsumer</CODE> for the specified destination,      * using a message selector. This method can specify whether messages      * published by its own connection should be delivered to it, if the      * destination is a topic.      *<P>      * Since<CODE>Queue</CODE> and<CODE>Topic</CODE> both inherit from      *<CODE>Destination</CODE>, they can be used in the destination      * parameter to create a<CODE>MessageConsumer</CODE>.      *<P>      * A client uses a<CODE>MessageConsumer</CODE> object to receive messages      * that have been published to a destination.      *<P>      * In some cases, a connection may both publish and subscribe to a topic.      * The consumer<CODE>NoLocal</CODE> attribute allows a consumer to      * inhibit the delivery of messages published by its own connection. The      * default value for this attribute is False. The<CODE>noLocal</CODE>      * value must be supported by destinations that are topics.      *      * @param destination the<CODE>Destination</CODE> to access      * @param messageSelector only messages with properties matching the message      *                selector expression are delivered. A value of null or an      *                empty string indicates that there is no message selector      *                for the message consumer.      * @param noLocal - if true, and the destination is a topic, inhibits the      *                delivery of messages published by its own connection. The      *                behavior for<CODE>NoLocal</CODE> is not specified if      *                the destination is a queue.      * @return the MessageConsumer      * @throws JMSException if the session fails to create a MessageConsumer due      *                 to some internal error.      * @throws InvalidDestinationException if an invalid destination is      *                 specified.      * @throws InvalidSelectorException if the message selector is invalid.      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|MessageConsumer
name|createConsumer
parameter_list|(
name|Destination
name|destination
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|boolean
name|noLocal
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
name|createConsumer
argument_list|(
name|destination
argument_list|,
name|messageSelector
argument_list|,
name|noLocal
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates<CODE>MessageConsumer</CODE> for the specified destination,      * using a message selector. This method can specify whether messages      * published by its own connection should be delivered to it, if the      * destination is a topic.      *<P>      * Since<CODE>Queue</CODE> and<CODE>Topic</CODE> both inherit from      *<CODE>Destination</CODE>, they can be used in the destination      * parameter to create a<CODE>MessageConsumer</CODE>.      *<P>      * A client uses a<CODE>MessageConsumer</CODE> object to receive messages      * that have been published to a destination.      *<P>      * In some cases, a connection may both publish and subscribe to a topic.      * The consumer<CODE>NoLocal</CODE> attribute allows a consumer to      * inhibit the delivery of messages published by its own connection. The      * default value for this attribute is False. The<CODE>noLocal</CODE>      * value must be supported by destinations that are topics.      *      * @param destination the<CODE>Destination</CODE> to access      * @param messageSelector only messages with properties matching the message      *                selector expression are delivered. A value of null or an      *                empty string indicates that there is no message selector      *                for the message consumer.      * @param noLocal - if true, and the destination is a topic, inhibits the      *                delivery of messages published by its own connection. The      *                behavior for<CODE>NoLocal</CODE> is not specified if      *                the destination is a queue.      * @param messageListener the listener to use for async consumption of messages      * @return the MessageConsumer      * @throws JMSException if the session fails to create a MessageConsumer due      *                 to some internal error.      * @throws InvalidDestinationException if an invalid destination is      *                 specified.      * @throws InvalidSelectorException if the message selector is invalid.      * @since 1.1      */
specifier|public
name|MessageConsumer
name|createConsumer
parameter_list|(
name|Destination
name|destination
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|boolean
name|noLocal
parameter_list|,
name|MessageListener
name|messageListener
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|destination
operator|instanceof
name|CustomDestination
condition|)
block|{
name|CustomDestination
name|customDestination
init|=
operator|(
name|CustomDestination
operator|)
name|destination
decl_stmt|;
return|return
name|customDestination
operator|.
name|createConsumer
argument_list|(
name|this
argument_list|,
name|messageSelector
argument_list|,
name|noLocal
argument_list|)
return|;
block|}
name|ActiveMQPrefetchPolicy
name|prefetchPolicy
init|=
name|connection
operator|.
name|getPrefetchPolicy
argument_list|()
decl_stmt|;
name|int
name|prefetch
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|destination
operator|instanceof
name|Topic
condition|)
block|{
name|prefetch
operator|=
name|prefetchPolicy
operator|.
name|getTopicPrefetch
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|prefetch
operator|=
name|prefetchPolicy
operator|.
name|getQueuePrefetch
argument_list|()
expr_stmt|;
block|}
name|ActiveMQDestination
name|activemqDestination
init|=
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|destination
argument_list|)
decl_stmt|;
return|return
operator|new
name|ActiveMQMessageConsumer
argument_list|(
name|this
argument_list|,
name|getNextConsumerId
argument_list|()
argument_list|,
name|activemqDestination
argument_list|,
literal|null
argument_list|,
name|messageSelector
argument_list|,
name|prefetch
argument_list|,
name|prefetchPolicy
operator|.
name|getMaximumPendingMessageLimit
argument_list|()
argument_list|,
name|noLocal
argument_list|,
literal|false
argument_list|,
name|isAsyncDispatch
argument_list|()
argument_list|,
name|messageListener
argument_list|)
return|;
block|}
comment|/**      * Creates a queue identity given a<CODE>Queue</CODE> name.      *<P>      * This facility is provided for the rare cases where clients need to      * dynamically manipulate queue identity. It allows the creation of a queue      * identity with a provider-specific name. Clients that depend on this      * ability are not portable.      *<P>      * Note that this method is not for creating the physical queue. The      * physical creation of queues is an administrative task and is not to be      * initiated by the JMS API. The one exception is the creation of temporary      * queues, which is accomplished with the<CODE>createTemporaryQueue</CODE>      * method.      *      * @param queueName the name of this<CODE>Queue</CODE>      * @return a<CODE>Queue</CODE> with the given name      * @throws JMSException if the session fails to create a queue due to some      *                 internal error.      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|Queue
name|createQueue
parameter_list|(
name|String
name|queueName
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|queueName
operator|.
name|startsWith
argument_list|(
name|ActiveMQDestination
operator|.
name|TEMP_DESTINATION_NAME_PREFIX
argument_list|)
condition|)
block|{
return|return
operator|new
name|ActiveMQTempQueue
argument_list|(
name|queueName
argument_list|)
return|;
block|}
return|return
operator|new
name|ActiveMQQueue
argument_list|(
name|queueName
argument_list|)
return|;
block|}
comment|/**      * Creates a topic identity given a<CODE>Topic</CODE> name.      *<P>      * This facility is provided for the rare cases where clients need to      * dynamically manipulate topic identity. This allows the creation of a      * topic identity with a provider-specific name. Clients that depend on this      * ability are not portable.      *<P>      * Note that this method is not for creating the physical topic. The      * physical creation of topics is an administrative task and is not to be      * initiated by the JMS API. The one exception is the creation of temporary      * topics, which is accomplished with the<CODE>createTemporaryTopic</CODE>      * method.      *      * @param topicName the name of this<CODE>Topic</CODE>      * @return a<CODE>Topic</CODE> with the given name      * @throws JMSException if the session fails to create a topic due to some      *                 internal error.      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|Topic
name|createTopic
parameter_list|(
name|String
name|topicName
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|topicName
operator|.
name|startsWith
argument_list|(
name|ActiveMQDestination
operator|.
name|TEMP_DESTINATION_NAME_PREFIX
argument_list|)
condition|)
block|{
return|return
operator|new
name|ActiveMQTempTopic
argument_list|(
name|topicName
argument_list|)
return|;
block|}
return|return
operator|new
name|ActiveMQTopic
argument_list|(
name|topicName
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>QueueBrowser</CODE> object to peek at the messages on      * the specified queue.      *      * @param queue the<CODE>queue</CODE> to access      * @exception InvalidDestinationException if an invalid destination is      *                    specified      * @since 1.1      */
comment|/**      * Creates a durable subscriber to the specified topic.      *<P>      * If a client needs to receive all the messages published on a topic,      * including the ones published while the subscriber is inactive, it uses a      * durable<CODE>TopicSubscriber</CODE>. The JMS provider retains a      * record of this durable subscription and insures that all messages from      * the topic's publishers are retained until they are acknowledged by this      * durable subscriber or they have expired.      *<P>      * Sessions with durable subscribers must always provide the same client      * identifier. In addition, each client must specify a name that uniquely      * identifies (within client identifier) each durable subscription it      * creates. Only one session at a time can have a      *<CODE>TopicSubscriber</CODE> for a particular durable subscription.      *<P>      * A client can change an existing durable subscription by creating a      * durable<CODE>TopicSubscriber</CODE> with the same name and a new topic      * and/or message selector. Changing a durable subscriber is equivalent to      * unsubscribing (deleting) the old one and creating a new one.      *<P>      * In some cases, a connection may both publish and subscribe to a topic.      * The subscriber<CODE>NoLocal</CODE> attribute allows a subscriber to      * inhibit the delivery of messages published by its own connection. The      * default value for this attribute is false.      *      * @param topic the non-temporary<CODE>Topic</CODE> to subscribe to      * @param name the name used to identify this subscription      * @return the TopicSubscriber      * @throws JMSException if the session fails to create a subscriber due to      *                 some internal error.      * @throws InvalidDestinationException if an invalid topic is specified.      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|TopicSubscriber
name|createDurableSubscriber
parameter_list|(
name|Topic
name|topic
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|createDurableSubscriber
argument_list|(
name|topic
argument_list|,
name|name
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a durable subscriber to the specified topic, using a message      * selector and specifying whether messages published by its own connection      * should be delivered to it.      *<P>      * If a client needs to receive all the messages published on a topic,      * including the ones published while the subscriber is inactive, it uses a      * durable<CODE>TopicSubscriber</CODE>. The JMS provider retains a      * record of this durable subscription and insures that all messages from      * the topic's publishers are retained until they are acknowledged by this      * durable subscriber or they have expired.      *<P>      * Sessions with durable subscribers must always provide the same client      * identifier. In addition, each client must specify a name which uniquely      * identifies (within client identifier) each durable subscription it      * creates. Only one session at a time can have a      *<CODE>TopicSubscriber</CODE> for a particular durable subscription. An      * inactive durable subscriber is one that exists but does not currently      * have a message consumer associated with it.      *<P>      * A client can change an existing durable subscription by creating a      * durable<CODE>TopicSubscriber</CODE> with the same name and a new topic      * and/or message selector. Changing a durable subscriber is equivalent to      * unsubscribing (deleting) the old one and creating a new one.      *      * @param topic the non-temporary<CODE>Topic</CODE> to subscribe to      * @param name the name used to identify this subscription      * @param messageSelector only messages with properties matching the message      *                selector expression are delivered. A value of null or an      *                empty string indicates that there is no message selector      *                for the message consumer.      * @param noLocal if set, inhibits the delivery of messages published by its      *                own connection      * @return the Queue Browser      * @throws JMSException if the session fails to create a subscriber due to      *                 some internal error.      * @throws InvalidDestinationException if an invalid topic is specified.      * @throws InvalidSelectorException if the message selector is invalid.      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|TopicSubscriber
name|createDurableSubscriber
parameter_list|(
name|Topic
name|topic
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|boolean
name|noLocal
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|topic
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|InvalidDestinationException
argument_list|(
literal|"Topic cannot be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|topic
operator|instanceof
name|CustomDestination
condition|)
block|{
name|CustomDestination
name|customDestination
init|=
operator|(
name|CustomDestination
operator|)
name|topic
decl_stmt|;
return|return
name|customDestination
operator|.
name|createDurableSubscriber
argument_list|(
name|this
argument_list|,
name|name
argument_list|,
name|messageSelector
argument_list|,
name|noLocal
argument_list|)
return|;
block|}
name|connection
operator|.
name|checkClientIDWasManuallySpecified
argument_list|()
expr_stmt|;
name|ActiveMQPrefetchPolicy
name|prefetchPolicy
init|=
name|this
operator|.
name|connection
operator|.
name|getPrefetchPolicy
argument_list|()
decl_stmt|;
name|int
name|prefetch
init|=
name|isAutoAcknowledge
argument_list|()
operator|&&
name|connection
operator|.
name|isOptimizedMessageDispatch
argument_list|()
condition|?
name|prefetchPolicy
operator|.
name|getOptimizeDurableTopicPrefetch
argument_list|()
else|:
name|prefetchPolicy
operator|.
name|getDurableTopicPrefetch
argument_list|()
decl_stmt|;
name|int
name|maxPrendingLimit
init|=
name|prefetchPolicy
operator|.
name|getMaximumPendingMessageLimit
argument_list|()
decl_stmt|;
return|return
operator|new
name|ActiveMQTopicSubscriber
argument_list|(
name|this
argument_list|,
name|getNextConsumerId
argument_list|()
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|topic
argument_list|)
argument_list|,
name|name
argument_list|,
name|messageSelector
argument_list|,
name|prefetch
argument_list|,
name|maxPrendingLimit
argument_list|,
name|noLocal
argument_list|,
literal|false
argument_list|,
name|asyncDispatch
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>QueueBrowser</CODE> object to peek at the messages on      * the specified queue.      *      * @param queue the<CODE>queue</CODE> to access      * @return the Queue Browser      * @throws JMSException if the session fails to create a browser due to some      *                 internal error.      * @throws InvalidDestinationException if an invalid destination is      *                 specified      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|QueueBrowser
name|createBrowser
parameter_list|(
name|Queue
name|queue
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|createBrowser
argument_list|(
name|queue
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>QueueBrowser</CODE> object to peek at the messages on      * the specified queue using a message selector.      *      * @param queue the<CODE>queue</CODE> to access      * @param messageSelector only messages with properties matching the message      *                selector expression are delivered. A value of null or an      *                empty string indicates that there is no message selector      *                for the message consumer.      * @return the Queue Browser      * @throws JMSException if the session fails to create a browser due to some      *                 internal error.      * @throws InvalidDestinationException if an invalid destination is      *                 specified      * @throws InvalidSelectorException if the message selector is invalid.      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|QueueBrowser
name|createBrowser
parameter_list|(
name|Queue
name|queue
parameter_list|,
name|String
name|messageSelector
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|new
name|ActiveMQQueueBrowser
argument_list|(
name|this
argument_list|,
name|getNextConsumerId
argument_list|()
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|queue
argument_list|)
argument_list|,
name|messageSelector
argument_list|,
name|asyncDispatch
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>TemporaryQueue</CODE> object. Its lifetime will be that      * of the<CODE>Connection</CODE> unless it is deleted earlier.      *      * @return a temporary queue identity      * @throws JMSException if the session fails to create a temporary queue due      *                 to some internal error.      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|TemporaryQueue
name|createTemporaryQueue
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|(
name|TemporaryQueue
operator|)
name|connection
operator|.
name|createTempDestination
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>TemporaryTopic</CODE> object. Its lifetime will be that      * of the<CODE>Connection</CODE> unless it is deleted earlier.      *      * @return a temporary topic identity      * @throws JMSException if the session fails to create a temporary topic due      *                 to some internal error.      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|TemporaryTopic
name|createTemporaryTopic
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
operator|(
name|TemporaryTopic
operator|)
name|connection
operator|.
name|createTempDestination
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>QueueReceiver</CODE> object to receive messages from      * the specified queue.      *      * @param queue the<CODE>Queue</CODE> to access      * @return a new QueueBrowser instance.      * @throws JMSException if the session fails to create a receiver due to      *                 some internal error.      * @throws JMSException      * @throws InvalidDestinationException if an invalid queue is specified.      */
annotation|@
name|Override
specifier|public
name|QueueReceiver
name|createReceiver
parameter_list|(
name|Queue
name|queue
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|createReceiver
argument_list|(
name|queue
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>QueueReceiver</CODE> object to receive messages from      * the specified queue using a message selector.      *      * @param queue the<CODE>Queue</CODE> to access      * @param messageSelector only messages with properties matching the message      *                selector expression are delivered. A value of null or an      *                empty string indicates that there is no message selector      *                for the message consumer.      * @return QueueReceiver      * @throws JMSException if the session fails to create a receiver due to      *                 some internal error.      * @throws InvalidDestinationException if an invalid queue is specified.      * @throws InvalidSelectorException if the message selector is invalid.      */
annotation|@
name|Override
specifier|public
name|QueueReceiver
name|createReceiver
parameter_list|(
name|Queue
name|queue
parameter_list|,
name|String
name|messageSelector
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|queue
operator|instanceof
name|CustomDestination
condition|)
block|{
name|CustomDestination
name|customDestination
init|=
operator|(
name|CustomDestination
operator|)
name|queue
decl_stmt|;
return|return
name|customDestination
operator|.
name|createReceiver
argument_list|(
name|this
argument_list|,
name|messageSelector
argument_list|)
return|;
block|}
name|ActiveMQPrefetchPolicy
name|prefetchPolicy
init|=
name|this
operator|.
name|connection
operator|.
name|getPrefetchPolicy
argument_list|()
decl_stmt|;
return|return
operator|new
name|ActiveMQQueueReceiver
argument_list|(
name|this
argument_list|,
name|getNextConsumerId
argument_list|()
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|queue
argument_list|)
argument_list|,
name|messageSelector
argument_list|,
name|prefetchPolicy
operator|.
name|getQueuePrefetch
argument_list|()
argument_list|,
name|prefetchPolicy
operator|.
name|getMaximumPendingMessageLimit
argument_list|()
argument_list|,
name|asyncDispatch
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>QueueSender</CODE> object to send messages to the      * specified queue.      *      * @param queue the<CODE>Queue</CODE> to access, or null if this is an      *                unidentified producer      * @return QueueSender      * @throws JMSException if the session fails to create a sender due to some      *                 internal error.      * @throws InvalidDestinationException if an invalid queue is specified.      */
annotation|@
name|Override
specifier|public
name|QueueSender
name|createSender
parameter_list|(
name|Queue
name|queue
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|queue
operator|instanceof
name|CustomDestination
condition|)
block|{
name|CustomDestination
name|customDestination
init|=
operator|(
name|CustomDestination
operator|)
name|queue
decl_stmt|;
return|return
name|customDestination
operator|.
name|createSender
argument_list|(
name|this
argument_list|)
return|;
block|}
name|int
name|timeSendOut
init|=
name|connection
operator|.
name|getSendTimeout
argument_list|()
decl_stmt|;
return|return
operator|new
name|ActiveMQQueueSender
argument_list|(
name|this
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|queue
argument_list|)
argument_list|,
name|timeSendOut
argument_list|)
return|;
block|}
comment|/**      * Creates a nondurable subscriber to the specified topic.<p/>      *<P>      * A client uses a<CODE>TopicSubscriber</CODE> object to receive messages      * that have been published to a topic.<p/>      *<P>      * Regular<CODE>TopicSubscriber</CODE> objects are not durable. They      * receive only messages that are published while they are active.<p/>      *<P>      * In some cases, a connection may both publish and subscribe to a topic.      * The subscriber<CODE>NoLocal</CODE> attribute allows a subscriber to      * inhibit the delivery of messages published by its own connection. The      * default value for this attribute is false.      *      * @param topic the<CODE>Topic</CODE> to subscribe to      * @return TopicSubscriber      * @throws JMSException if the session fails to create a subscriber due to      *                 some internal error.      * @throws InvalidDestinationException if an invalid topic is specified.      */
annotation|@
name|Override
specifier|public
name|TopicSubscriber
name|createSubscriber
parameter_list|(
name|Topic
name|topic
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
return|return
name|createSubscriber
argument_list|(
name|topic
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a nondurable subscriber to the specified topic, using a message      * selector or specifying whether messages published by its own connection      * should be delivered to it.<p/>      *<P>      * A client uses a<CODE>TopicSubscriber</CODE> object to receive messages      * that have been published to a topic.<p/>      *<P>      * Regular<CODE>TopicSubscriber</CODE> objects are not durable. They      * receive only messages that are published while they are active.<p/>      *<P>      * Messages filtered out by a subscriber's message selector will never be      * delivered to the subscriber. From the subscriber's perspective, they do      * not exist.<p/>      *<P>      * In some cases, a connection may both publish and subscribe to a topic.      * The subscriber<CODE>NoLocal</CODE> attribute allows a subscriber to      * inhibit the delivery of messages published by its own connection. The      * default value for this attribute is false.      *      * @param topic the<CODE>Topic</CODE> to subscribe to      * @param messageSelector only messages with properties matching the message      *                selector expression are delivered. A value of null or an      *                empty string indicates that there is no message selector      *                for the message consumer.      * @param noLocal if set, inhibits the delivery of messages published by its      *                own connection      * @return TopicSubscriber      * @throws JMSException if the session fails to create a subscriber due to      *                 some internal error.      * @throws InvalidDestinationException if an invalid topic is specified.      * @throws InvalidSelectorException if the message selector is invalid.      */
annotation|@
name|Override
specifier|public
name|TopicSubscriber
name|createSubscriber
parameter_list|(
name|Topic
name|topic
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|boolean
name|noLocal
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|topic
operator|instanceof
name|CustomDestination
condition|)
block|{
name|CustomDestination
name|customDestination
init|=
operator|(
name|CustomDestination
operator|)
name|topic
decl_stmt|;
return|return
name|customDestination
operator|.
name|createSubscriber
argument_list|(
name|this
argument_list|,
name|messageSelector
argument_list|,
name|noLocal
argument_list|)
return|;
block|}
name|ActiveMQPrefetchPolicy
name|prefetchPolicy
init|=
name|this
operator|.
name|connection
operator|.
name|getPrefetchPolicy
argument_list|()
decl_stmt|;
return|return
operator|new
name|ActiveMQTopicSubscriber
argument_list|(
name|this
argument_list|,
name|getNextConsumerId
argument_list|()
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|topic
argument_list|)
argument_list|,
literal|null
argument_list|,
name|messageSelector
argument_list|,
name|prefetchPolicy
operator|.
name|getTopicPrefetch
argument_list|()
argument_list|,
name|prefetchPolicy
operator|.
name|getMaximumPendingMessageLimit
argument_list|()
argument_list|,
name|noLocal
argument_list|,
literal|false
argument_list|,
name|asyncDispatch
argument_list|)
return|;
block|}
comment|/**      * Creates a publisher for the specified topic.<p/>      *<P>      * A client uses a<CODE>TopicPublisher</CODE> object to publish messages      * on a topic. Each time a client creates a<CODE>TopicPublisher</CODE> on      * a topic, it defines a new sequence of messages that have no ordering      * relationship with the messages it has previously sent.      *      * @param topic the<CODE>Topic</CODE> to publish to, or null if this is      *                an unidentified producer      * @return TopicPublisher      * @throws JMSException if the session fails to create a publisher due to      *                 some internal error.      * @throws InvalidDestinationException if an invalid topic is specified.      */
annotation|@
name|Override
specifier|public
name|TopicPublisher
name|createPublisher
parameter_list|(
name|Topic
name|topic
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|topic
operator|instanceof
name|CustomDestination
condition|)
block|{
name|CustomDestination
name|customDestination
init|=
operator|(
name|CustomDestination
operator|)
name|topic
decl_stmt|;
return|return
name|customDestination
operator|.
name|createPublisher
argument_list|(
name|this
argument_list|)
return|;
block|}
name|int
name|timeSendOut
init|=
name|connection
operator|.
name|getSendTimeout
argument_list|()
decl_stmt|;
return|return
operator|new
name|ActiveMQTopicPublisher
argument_list|(
name|this
argument_list|,
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|topic
argument_list|)
argument_list|,
name|timeSendOut
argument_list|)
return|;
block|}
comment|/**      * Unsubscribes a durable subscription that has been created by a client.      *<P>      * This method deletes the state being maintained on behalf of the      * subscriber by its provider.      *<P>      * It is erroneous for a client to delete a durable subscription while there      * is an active<CODE>MessageConsumer</CODE> or      *<CODE>TopicSubscriber</CODE> for the subscription, or while a consumed      * message is part of a pending transaction or has not been acknowledged in      * the session.      *      * @param name the name used to identify this subscription      * @throws JMSException if the session fails to unsubscribe to the durable      *                 subscription due to some internal error.      * @throws InvalidDestinationException if an invalid subscription name is      *                 specified.      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|void
name|unsubscribe
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
name|connection
operator|.
name|unsubscribe
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|dispatch
parameter_list|(
name|MessageDispatch
name|messageDispatch
parameter_list|)
block|{
try|try
block|{
name|executor
operator|.
name|execute
argument_list|(
name|messageDispatch
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|connection
operator|.
name|onClientInternalException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Acknowledges all consumed messages of the session of this consumed      * message.      *<P>      * All consumed JMS messages support the<CODE>acknowledge</CODE> method      * for use when a client has specified that its JMS session's consumed      * messages are to be explicitly acknowledged. By invoking      *<CODE>acknowledge</CODE> on a consumed message, a client acknowledges      * all messages consumed by the session that the message was delivered to.      *<P>      * Calls to<CODE>acknowledge</CODE> are ignored for both transacted      * sessions and sessions specified to use implicit acknowledgement modes.      *<P>      * A client may individually acknowledge each message as it is consumed, or      * it may choose to acknowledge messages as an application-defined group      * (which is done by calling acknowledge on the last received message of the      * group, thereby acknowledging all messages consumed by the session.)      *<P>      * Messages that have been received but not acknowledged may be redelivered.      *      * @throws JMSException if the JMS provider fails to acknowledge the      *                 messages due to some internal error.      * @throws javax.jms.IllegalStateException if this method is called on a      *                 closed session.      * @see javax.jms.Session#CLIENT_ACKNOWLEDGE      */
specifier|public
name|void
name|acknowledge
parameter_list|()
throws|throws
name|JMSException
block|{
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQMessageConsumer
argument_list|>
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|c
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|c
operator|.
name|acknowledge
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Add a message consumer.      *      * @param consumer - message consumer.      * @throws JMSException      */
specifier|protected
name|void
name|addConsumer
parameter_list|(
name|ActiveMQMessageConsumer
name|consumer
parameter_list|)
throws|throws
name|JMSException
block|{
name|this
operator|.
name|consumers
operator|.
name|add
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
if|if
condition|(
name|consumer
operator|.
name|isDurableSubscriber
argument_list|()
condition|)
block|{
name|stats
operator|.
name|onCreateDurableSubscriber
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|connection
operator|.
name|addDispatcher
argument_list|(
name|consumer
operator|.
name|getConsumerId
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove the message consumer.      *      * @param consumer - consumer to be removed.      * @throws JMSException      */
specifier|protected
name|void
name|removeConsumer
parameter_list|(
name|ActiveMQMessageConsumer
name|consumer
parameter_list|)
block|{
name|this
operator|.
name|connection
operator|.
name|removeDispatcher
argument_list|(
name|consumer
operator|.
name|getConsumerId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|consumer
operator|.
name|isDurableSubscriber
argument_list|()
condition|)
block|{
name|stats
operator|.
name|onRemoveDurableSubscriber
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|consumers
operator|.
name|remove
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|.
name|removeDispatcher
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds a message producer.      *      * @param producer - message producer to be added.      * @throws JMSException      */
specifier|protected
name|void
name|addProducer
parameter_list|(
name|ActiveMQMessageProducer
name|producer
parameter_list|)
throws|throws
name|JMSException
block|{
name|this
operator|.
name|producers
operator|.
name|add
argument_list|(
name|producer
argument_list|)
expr_stmt|;
name|this
operator|.
name|connection
operator|.
name|addProducer
argument_list|(
name|producer
operator|.
name|getProducerInfo
argument_list|()
operator|.
name|getProducerId
argument_list|()
argument_list|,
name|producer
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes a message producer.      *      * @param producer - message producer to be removed.      * @throws JMSException      */
specifier|protected
name|void
name|removeProducer
parameter_list|(
name|ActiveMQMessageProducer
name|producer
parameter_list|)
block|{
name|this
operator|.
name|connection
operator|.
name|removeProducer
argument_list|(
name|producer
operator|.
name|getProducerInfo
argument_list|()
operator|.
name|getProducerId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|producers
operator|.
name|remove
argument_list|(
name|producer
argument_list|)
expr_stmt|;
block|}
comment|/**      * Start this Session.      *      * @throws JMSException      */
specifier|protected
name|void
name|start
parameter_list|()
throws|throws
name|JMSException
block|{
name|started
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQMessageConsumer
argument_list|>
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|c
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|c
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|executor
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**      * Stops this session.      *      * @throws JMSException      */
specifier|protected
name|void
name|stop
parameter_list|()
throws|throws
name|JMSException
block|{
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQMessageConsumer
argument_list|>
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|c
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|c
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|started
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|executor
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns the session id.      *      * @return value - session id.      */
specifier|protected
name|SessionId
name|getSessionId
parameter_list|()
block|{
return|return
name|info
operator|.
name|getSessionId
argument_list|()
return|;
block|}
comment|/**      * @return a unique ConsumerId instance.      */
specifier|protected
name|ConsumerId
name|getNextConsumerId
parameter_list|()
block|{
return|return
operator|new
name|ConsumerId
argument_list|(
name|info
operator|.
name|getSessionId
argument_list|()
argument_list|,
name|consumerIdGenerator
operator|.
name|getNextSequenceId
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @return a unique ProducerId instance.      */
specifier|protected
name|ProducerId
name|getNextProducerId
parameter_list|()
block|{
return|return
operator|new
name|ProducerId
argument_list|(
name|info
operator|.
name|getSessionId
argument_list|()
argument_list|,
name|producerIdGenerator
operator|.
name|getNextSequenceId
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Sends the message for dispatch by the broker.      *      * @param producer - message producer.      * @param destination - message destination.      * @param message - message to be sent.      * @param deliveryMode - JMS message delivery mode.      * @param priority - message priority.      * @param timeToLive - message expiration.      * @param producerWindow      * @param onComplete      * @throws JMSException      */
specifier|protected
name|void
name|send
parameter_list|(
name|ActiveMQMessageProducer
name|producer
parameter_list|,
name|ActiveMQDestination
name|destination
parameter_list|,
name|Message
name|message
parameter_list|,
name|int
name|deliveryMode
parameter_list|,
name|int
name|priority
parameter_list|,
name|long
name|timeToLive
parameter_list|,
name|MemoryUsage
name|producerWindow
parameter_list|,
name|int
name|sendTimeout
parameter_list|,
name|AsyncCallback
name|onComplete
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|destination
operator|.
name|isTemporary
argument_list|()
operator|&&
name|connection
operator|.
name|isDeleted
argument_list|(
name|destination
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidDestinationException
argument_list|(
literal|"Cannot publish to a deleted Destination: "
operator|+
name|destination
argument_list|)
throw|;
block|}
synchronized|synchronized
init|(
name|sendMutex
init|)
block|{
comment|// tell the Broker we are about to start a new transaction
name|doStartTransaction
argument_list|()
expr_stmt|;
name|TransactionId
name|txid
init|=
name|transactionContext
operator|.
name|getTransactionId
argument_list|()
decl_stmt|;
name|long
name|sequenceNumber
init|=
name|producer
operator|.
name|getMessageSequence
argument_list|()
decl_stmt|;
comment|//Set the "JMS" header fields on the original message, see 1.1 spec section 3.4.11
name|message
operator|.
name|setJMSDeliveryMode
argument_list|(
name|deliveryMode
argument_list|)
expr_stmt|;
name|long
name|expiration
init|=
literal|0L
decl_stmt|;
if|if
condition|(
operator|!
name|producer
operator|.
name|getDisableMessageTimestamp
argument_list|()
condition|)
block|{
name|long
name|timeStamp
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|message
operator|.
name|setJMSTimestamp
argument_list|(
name|timeStamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeToLive
operator|>
literal|0
condition|)
block|{
name|expiration
operator|=
name|timeToLive
operator|+
name|timeStamp
expr_stmt|;
block|}
block|}
name|message
operator|.
name|setJMSExpiration
argument_list|(
name|expiration
argument_list|)
expr_stmt|;
name|message
operator|.
name|setJMSPriority
argument_list|(
name|priority
argument_list|)
expr_stmt|;
name|message
operator|.
name|setJMSRedelivered
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// transform to our own message format here
name|ActiveMQMessage
name|msg
init|=
name|ActiveMQMessageTransformation
operator|.
name|transformMessage
argument_list|(
name|message
argument_list|,
name|connection
argument_list|)
decl_stmt|;
name|msg
operator|.
name|setDestination
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setMessageId
argument_list|(
operator|new
name|MessageId
argument_list|(
name|producer
operator|.
name|getProducerInfo
argument_list|()
operator|.
name|getProducerId
argument_list|()
argument_list|,
name|sequenceNumber
argument_list|)
argument_list|)
expr_stmt|;
comment|// Set the message id.
if|if
condition|(
name|msg
operator|!=
name|message
condition|)
block|{
name|message
operator|.
name|setJMSMessageID
argument_list|(
name|msg
operator|.
name|getMessageId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Make sure the JMS destination is set on the foreign messages too.
name|message
operator|.
name|setJMSDestination
argument_list|(
name|destination
argument_list|)
expr_stmt|;
block|}
comment|//clear the brokerPath in case we are re-sending this message
name|msg
operator|.
name|setBrokerPath
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setTransactionId
argument_list|(
name|txid
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|.
name|isCopyMessageOnSend
argument_list|()
condition|)
block|{
name|msg
operator|=
operator|(
name|ActiveMQMessage
operator|)
name|msg
operator|.
name|copy
argument_list|()
expr_stmt|;
block|}
name|msg
operator|.
name|setConnection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|msg
operator|.
name|onSend
argument_list|()
expr_stmt|;
name|msg
operator|.
name|setProducerId
argument_list|(
name|msg
operator|.
name|getMessageId
argument_list|()
operator|.
name|getProducerId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
name|getSessionId
argument_list|()
operator|+
literal|" sending message: "
operator|+
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|onComplete
operator|==
literal|null
operator|&&
name|sendTimeout
operator|<=
literal|0
operator|&&
operator|!
name|msg
operator|.
name|isResponseRequired
argument_list|()
operator|&&
operator|!
name|connection
operator|.
name|isAlwaysSyncSend
argument_list|()
operator|&&
operator|(
operator|!
name|msg
operator|.
name|isPersistent
argument_list|()
operator|||
name|connection
operator|.
name|isUseAsyncSend
argument_list|()
operator|||
name|txid
operator|!=
literal|null
operator|)
condition|)
block|{
name|this
operator|.
name|connection
operator|.
name|asyncSendPacket
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|producerWindow
operator|!=
literal|null
condition|)
block|{
comment|// Since we defer lots of the marshaling till we hit the
comment|// wire, this might not
comment|// provide and accurate size. We may change over to doing
comment|// more aggressive marshaling,
comment|// to get more accurate sizes.. this is more important once
comment|// users start using producer window
comment|// flow control.
name|int
name|size
init|=
name|msg
operator|.
name|getSize
argument_list|()
decl_stmt|;
name|producerWindow
operator|.
name|increaseUsage
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sendTimeout
operator|>
literal|0
operator|&&
name|onComplete
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|connection
operator|.
name|syncSendPacket
argument_list|(
name|msg
argument_list|,
name|sendTimeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|connection
operator|.
name|syncSendPacket
argument_list|(
name|msg
argument_list|,
name|onComplete
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Send TransactionInfo to indicate transaction has started      *      * @throws JMSException if some internal error occurs      */
specifier|protected
name|void
name|doStartTransaction
parameter_list|()
throws|throws
name|JMSException
block|{
if|if
condition|(
name|getTransacted
argument_list|()
operator|&&
operator|!
name|transactionContext
operator|.
name|isInXATransaction
argument_list|()
condition|)
block|{
name|transactionContext
operator|.
name|begin
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Checks whether the session has unconsumed messages.      *      * @return true - if there are unconsumed messages.      */
specifier|public
name|boolean
name|hasUncomsumedMessages
parameter_list|()
block|{
return|return
name|executor
operator|.
name|hasUncomsumedMessages
argument_list|()
return|;
block|}
comment|/**      * Checks whether the session uses transactions.      *      * @return true - if the session uses transactions.      */
specifier|public
name|boolean
name|isTransacted
parameter_list|()
block|{
return|return
name|this
operator|.
name|acknowledgementMode
operator|==
name|Session
operator|.
name|SESSION_TRANSACTED
operator|||
operator|(
name|transactionContext
operator|.
name|isInXATransaction
argument_list|()
operator|)
return|;
block|}
comment|/**      * Checks whether the session used client acknowledgment.      *      * @return true - if the session uses client acknowledgment.      */
specifier|protected
name|boolean
name|isClientAcknowledge
parameter_list|()
block|{
return|return
name|this
operator|.
name|acknowledgementMode
operator|==
name|Session
operator|.
name|CLIENT_ACKNOWLEDGE
return|;
block|}
comment|/**      * Checks whether the session used auto acknowledgment.      *      * @return true - if the session uses client acknowledgment.      */
specifier|public
name|boolean
name|isAutoAcknowledge
parameter_list|()
block|{
return|return
name|acknowledgementMode
operator|==
name|Session
operator|.
name|AUTO_ACKNOWLEDGE
return|;
block|}
comment|/**      * Checks whether the session used dup ok acknowledgment.      *      * @return true - if the session uses client acknowledgment.      */
specifier|public
name|boolean
name|isDupsOkAcknowledge
parameter_list|()
block|{
return|return
name|acknowledgementMode
operator|==
name|Session
operator|.
name|DUPS_OK_ACKNOWLEDGE
return|;
block|}
specifier|public
name|boolean
name|isIndividualAcknowledge
parameter_list|()
block|{
return|return
name|acknowledgementMode
operator|==
name|ActiveMQSession
operator|.
name|INDIVIDUAL_ACKNOWLEDGE
return|;
block|}
comment|/**      * Returns the message delivery listener.      *      * @return deliveryListener - message delivery listener.      */
specifier|public
name|DeliveryListener
name|getDeliveryListener
parameter_list|()
block|{
return|return
name|deliveryListener
return|;
block|}
comment|/**      * Sets the message delivery listener.      *      * @param deliveryListener - message delivery listener.      */
specifier|public
name|void
name|setDeliveryListener
parameter_list|(
name|DeliveryListener
name|deliveryListener
parameter_list|)
block|{
name|this
operator|.
name|deliveryListener
operator|=
name|deliveryListener
expr_stmt|;
block|}
comment|/**      * Returns the SessionInfo bean.      *      * @return info - SessionInfo bean.      * @throws JMSException      */
specifier|protected
name|SessionInfo
name|getSessionInfo
parameter_list|()
throws|throws
name|JMSException
block|{
name|SessionInfo
name|info
init|=
operator|new
name|SessionInfo
argument_list|(
name|connection
operator|.
name|getConnectionInfo
argument_list|()
argument_list|,
name|getSessionId
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|info
return|;
block|}
comment|/**      * Send the asynchronous command.      *      * @param command - command to be executed.      * @throws JMSException      */
specifier|public
name|void
name|asyncSendPacket
parameter_list|(
name|Command
name|command
parameter_list|)
throws|throws
name|JMSException
block|{
name|connection
operator|.
name|asyncSendPacket
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
comment|/**      * Send the synchronous command.      *      * @param command - command to be executed.      * @return Response      * @throws JMSException      */
specifier|public
name|Response
name|syncSendPacket
parameter_list|(
name|Command
name|command
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
name|connection
operator|.
name|syncSendPacket
argument_list|(
name|command
argument_list|)
return|;
block|}
specifier|public
name|long
name|getNextDeliveryId
parameter_list|()
block|{
return|return
name|deliveryIdGenerator
operator|.
name|getNextSequenceId
argument_list|()
return|;
block|}
specifier|public
name|void
name|redispatch
parameter_list|(
name|ActiveMQDispatcher
name|dispatcher
parameter_list|,
name|MessageDispatchChannel
name|unconsumedMessages
parameter_list|)
throws|throws
name|JMSException
block|{
name|List
argument_list|<
name|MessageDispatch
argument_list|>
name|c
init|=
name|unconsumedMessages
operator|.
name|removeAll
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|reverse
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|MessageDispatch
argument_list|>
name|iter
init|=
name|c
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|MessageDispatch
name|md
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|executor
operator|.
name|executeFirst
argument_list|(
name|md
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|started
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isAsyncDispatch
parameter_list|()
block|{
return|return
name|asyncDispatch
return|;
block|}
specifier|public
name|void
name|setAsyncDispatch
parameter_list|(
name|boolean
name|asyncDispatch
parameter_list|)
block|{
name|this
operator|.
name|asyncDispatch
operator|=
name|asyncDispatch
expr_stmt|;
block|}
comment|/**      * @return Returns the sessionAsyncDispatch.      */
specifier|public
name|boolean
name|isSessionAsyncDispatch
parameter_list|()
block|{
return|return
name|sessionAsyncDispatch
return|;
block|}
comment|/**      * @param sessionAsyncDispatch The sessionAsyncDispatch to set.      */
specifier|public
name|void
name|setSessionAsyncDispatch
parameter_list|(
name|boolean
name|sessionAsyncDispatch
parameter_list|)
block|{
name|this
operator|.
name|sessionAsyncDispatch
operator|=
name|sessionAsyncDispatch
expr_stmt|;
block|}
specifier|public
name|MessageTransformer
name|getTransformer
parameter_list|()
block|{
return|return
name|transformer
return|;
block|}
specifier|public
name|ActiveMQConnection
name|getConnection
parameter_list|()
block|{
return|return
name|connection
return|;
block|}
comment|/**      * Sets the transformer used to transform messages before they are sent on      * to the JMS bus or when they are received from the bus but before they are      * delivered to the JMS client      */
specifier|public
name|void
name|setTransformer
parameter_list|(
name|MessageTransformer
name|transformer
parameter_list|)
block|{
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
block|}
specifier|public
name|BlobTransferPolicy
name|getBlobTransferPolicy
parameter_list|()
block|{
return|return
name|blobTransferPolicy
return|;
block|}
comment|/**      * Sets the policy used to describe how out-of-band BLOBs (Binary Large      * OBjects) are transferred from producers to brokers to consumers      */
specifier|public
name|void
name|setBlobTransferPolicy
parameter_list|(
name|BlobTransferPolicy
name|blobTransferPolicy
parameter_list|)
block|{
name|this
operator|.
name|blobTransferPolicy
operator|=
name|blobTransferPolicy
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|MessageDispatch
argument_list|>
name|getUnconsumedMessages
parameter_list|()
block|{
return|return
name|executor
operator|.
name|getUnconsumedMessages
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ActiveMQSession {id="
operator|+
name|info
operator|.
name|getSessionId
argument_list|()
operator|+
literal|",started="
operator|+
name|started
operator|.
name|get
argument_list|()
operator|+
literal|",closed="
operator|+
name|closed
operator|+
literal|"} "
operator|+
name|sendMutex
return|;
block|}
specifier|public
name|void
name|checkMessageListener
parameter_list|()
throws|throws
name|JMSException
block|{
if|if
condition|(
name|messageListener
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot synchronously receive a message when a MessageListener is set"
argument_list|)
throw|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQMessageConsumer
argument_list|>
name|i
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|consumer
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|consumer
operator|.
name|hasMessageListener
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot synchronously receive a message when a MessageListener is set"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|protected
name|void
name|setOptimizeAcknowledge
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQMessageConsumer
argument_list|>
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|c
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|c
operator|.
name|setOptimizeAcknowledge
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|setPrefetchSize
parameter_list|(
name|ConsumerId
name|id
parameter_list|,
name|int
name|prefetch
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQMessageConsumer
argument_list|>
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|c
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|getConsumerId
argument_list|()
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|c
operator|.
name|setPrefetchSize
argument_list|(
name|prefetch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
specifier|protected
name|void
name|close
parameter_list|(
name|ConsumerId
name|id
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQMessageConsumer
argument_list|>
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|c
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|getConsumerId
argument_list|()
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
try|try
block|{
name|c
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|JMSException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception closing consumer"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Closed consumer on Command, "
operator|+
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
specifier|public
name|boolean
name|isInUse
parameter_list|(
name|ActiveMQTempDestination
name|destination
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQMessageConsumer
argument_list|>
name|iter
init|=
name|consumers
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQMessageConsumer
name|c
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|isInUse
argument_list|(
name|destination
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * highest sequence id of the last message delivered by this session.      * Passed to the broker in the close command, maintained by dispose()      * @return lastDeliveredSequenceId      */
specifier|public
name|long
name|getLastDeliveredSequenceId
parameter_list|()
block|{
return|return
name|lastDeliveredSequenceId
return|;
block|}
specifier|protected
name|void
name|sendAck
parameter_list|(
name|MessageAck
name|ack
parameter_list|)
throws|throws
name|JMSException
block|{
name|sendAck
argument_list|(
name|ack
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|sendAck
parameter_list|(
name|MessageAck
name|ack
parameter_list|,
name|boolean
name|lazy
parameter_list|)
throws|throws
name|JMSException
block|{
if|if
condition|(
name|lazy
operator|||
name|connection
operator|.
name|isSendAcksAsync
argument_list|()
operator|||
name|getTransacted
argument_list|()
condition|)
block|{
name|asyncSendPacket
argument_list|(
name|ack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syncSendPacket
argument_list|(
name|ack
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|Scheduler
name|getScheduler
parameter_list|()
throws|throws
name|JMSException
block|{
return|return
name|this
operator|.
name|connection
operator|.
name|getScheduler
argument_list|()
return|;
block|}
specifier|protected
name|ThreadPoolExecutor
name|getConnectionExecutor
parameter_list|()
block|{
return|return
name|this
operator|.
name|connectionExecutor
return|;
block|}
block|}
end_class

end_unit

