begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|activemq
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionHandler
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Connection
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|ConnectionConsumer
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|ConnectionMetaData
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Destination
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|ExceptionListener
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|IllegalStateException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|InvalidDestinationException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|JMSException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|QueueConnection
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|QueueSession
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|ServerSessionPool
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Session
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|Topic
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TopicConnection
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|TopicSession
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|jms
operator|.
name|XAConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|advisory
operator|.
name|DestinationSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|blob
operator|.
name|BlobTransferPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|broker
operator|.
name|region
operator|.
name|policy
operator|.
name|RedeliveryPolicyMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQDestination
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQTempDestination
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQTempQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQTempTopic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|BrokerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|Command
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|CommandTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ConnectionControl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ConnectionError
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ConnectionId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ConnectionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ConsumerControl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ConsumerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ConsumerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ControlCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|DestinationInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ExceptionResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|MessageDispatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|MessageId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ProducerAck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ProducerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|RemoveInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|RemoveSubscriptionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|Response
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|SessionId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ShutdownInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|WireFormatInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|management
operator|.
name|JMSConnectionStatsImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|management
operator|.
name|JMSStatsImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|management
operator|.
name|StatsCapable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|management
operator|.
name|StatsImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|state
operator|.
name|CommandVisitorAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|thread
operator|.
name|Scheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|thread
operator|.
name|TaskRunnerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|FutureResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|RequestTimedOutIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|ResponseCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|Transport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|TransportListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|failover
operator|.
name|FailoverTransport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|IdGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|IntrospectionSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|JMSExceptionSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|LongSequenceGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|ServiceSupport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|util
operator|.
name|ThreadPoolUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
class|class
name|ActiveMQConnection
implements|implements
name|Connection
implements|,
name|TopicConnection
implements|,
name|QueueConnection
implements|,
name|StatsCapable
implements|,
name|Closeable
implements|,
name|TransportListener
implements|,
name|EnhancedConnection
block|{
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_USER
init|=
name|ActiveMQConnectionFactory
operator|.
name|DEFAULT_USER
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_PASSWORD
init|=
name|ActiveMQConnectionFactory
operator|.
name|DEFAULT_PASSWORD
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_BROKER_URL
init|=
name|ActiveMQConnectionFactory
operator|.
name|DEFAULT_BROKER_URL
decl_stmt|;
specifier|public
specifier|static
name|int
name|DEFAULT_THREAD_POOL_SIZE
init|=
literal|1000
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ActiveMQConnection
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|final
name|ConcurrentMap
argument_list|<
name|ActiveMQTempDestination
argument_list|,
name|ActiveMQTempDestination
argument_list|>
name|activeTempDestinations
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|protected
name|boolean
name|dispatchAsync
init|=
literal|true
decl_stmt|;
specifier|protected
name|boolean
name|alwaysSessionAsync
init|=
literal|true
decl_stmt|;
specifier|private
name|TaskRunnerFactory
name|sessionTaskRunner
decl_stmt|;
specifier|private
specifier|final
name|ThreadPoolExecutor
name|executor
decl_stmt|;
comment|// Connection state variables
specifier|private
specifier|final
name|ConnectionInfo
name|info
decl_stmt|;
specifier|private
name|ExceptionListener
name|exceptionListener
decl_stmt|;
specifier|private
name|ClientInternalExceptionListener
name|clientInternalExceptionListener
decl_stmt|;
specifier|private
name|boolean
name|clientIDSet
decl_stmt|;
specifier|private
name|boolean
name|isConnectionInfoSentToBroker
decl_stmt|;
specifier|private
name|boolean
name|userSpecifiedClientID
decl_stmt|;
comment|// Configuration options variables
specifier|private
name|ActiveMQPrefetchPolicy
name|prefetchPolicy
init|=
operator|new
name|ActiveMQPrefetchPolicy
argument_list|()
decl_stmt|;
specifier|private
name|BlobTransferPolicy
name|blobTransferPolicy
decl_stmt|;
specifier|private
name|RedeliveryPolicyMap
name|redeliveryPolicyMap
decl_stmt|;
specifier|private
name|MessageTransformer
name|transformer
decl_stmt|;
specifier|private
name|boolean
name|disableTimeStampsByDefault
decl_stmt|;
specifier|private
name|boolean
name|optimizedMessageDispatch
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|copyMessageOnSend
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|useCompression
decl_stmt|;
specifier|private
name|boolean
name|objectMessageSerializationDefered
decl_stmt|;
specifier|private
name|boolean
name|useAsyncSend
decl_stmt|;
specifier|private
name|boolean
name|optimizeAcknowledge
decl_stmt|;
specifier|private
name|long
name|optimizeAcknowledgeTimeOut
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|optimizedAckScheduledAckInterval
init|=
literal|0
decl_stmt|;
specifier|private
name|boolean
name|nestedMapAndListEnabled
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|useRetroactiveConsumer
decl_stmt|;
specifier|private
name|boolean
name|exclusiveConsumer
decl_stmt|;
specifier|private
name|boolean
name|alwaysSyncSend
decl_stmt|;
specifier|private
name|int
name|closeTimeout
init|=
literal|15000
decl_stmt|;
specifier|private
name|boolean
name|watchTopicAdvisories
init|=
literal|true
decl_stmt|;
specifier|private
name|long
name|warnAboutUnstartedConnectionTimeout
init|=
literal|500L
decl_stmt|;
specifier|private
name|int
name|sendTimeout
init|=
literal|0
decl_stmt|;
specifier|private
name|boolean
name|sendAcksAsync
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|checkForDuplicates
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|queueOnlyConnection
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|consumerExpiryCheckEnabled
init|=
literal|true
decl_stmt|;
specifier|private
specifier|final
name|Transport
name|transport
decl_stmt|;
specifier|private
specifier|final
name|IdGenerator
name|clientIdGenerator
decl_stmt|;
specifier|private
specifier|final
name|JMSStatsImpl
name|factoryStats
decl_stmt|;
specifier|private
specifier|final
name|JMSConnectionStatsImpl
name|stats
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|started
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|closing
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|closed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AtomicBoolean
name|transportFailed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|ActiveMQSession
argument_list|>
name|sessions
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|ActiveMQConnectionConsumer
argument_list|>
name|connectionConsumers
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|TransportListener
argument_list|>
name|transportListeners
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Maps ConsumerIds to ActiveMQConsumer objects
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|ConsumerId
argument_list|,
name|ActiveMQDispatcher
argument_list|>
name|dispatchers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|ProducerId
argument_list|,
name|ActiveMQMessageProducer
argument_list|>
name|producers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LongSequenceGenerator
name|sessionIdGenerator
init|=
operator|new
name|LongSequenceGenerator
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|SessionId
name|connectionSessionId
decl_stmt|;
specifier|private
specifier|final
name|LongSequenceGenerator
name|consumerIdGenerator
init|=
operator|new
name|LongSequenceGenerator
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LongSequenceGenerator
name|tempDestinationIdGenerator
init|=
operator|new
name|LongSequenceGenerator
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LongSequenceGenerator
name|localTransactionIdGenerator
init|=
operator|new
name|LongSequenceGenerator
argument_list|()
decl_stmt|;
specifier|private
name|AdvisoryConsumer
name|advisoryConsumer
decl_stmt|;
specifier|private
specifier|final
name|CountDownLatch
name|brokerInfoReceived
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|private
name|BrokerInfo
name|brokerInfo
decl_stmt|;
specifier|private
name|IOException
name|firstFailureError
decl_stmt|;
specifier|private
name|int
name|producerWindowSize
init|=
name|ActiveMQConnectionFactory
operator|.
name|DEFAULT_PRODUCER_WINDOW_SIZE
decl_stmt|;
comment|// Assume that protocol is the latest. Change to the actual protocol
comment|// version when a WireFormatInfo is received.
specifier|private
specifier|final
name|AtomicInteger
name|protocolVersion
init|=
operator|new
name|AtomicInteger
argument_list|(
name|CommandTypes
operator|.
name|PROTOCOL_VERSION
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|long
name|timeCreated
decl_stmt|;
specifier|private
specifier|final
name|ConnectionAudit
name|connectionAudit
init|=
operator|new
name|ConnectionAudit
argument_list|()
decl_stmt|;
specifier|private
name|DestinationSource
name|destinationSource
decl_stmt|;
specifier|private
specifier|final
name|Object
name|ensureConnectionInfoSentMutex
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|useDedicatedTaskRunner
decl_stmt|;
specifier|protected
name|AtomicInteger
name|transportInterruptionProcessingComplete
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|private
name|long
name|consumerFailoverRedeliveryWaitPeriod
decl_stmt|;
specifier|private
name|Scheduler
name|scheduler
decl_stmt|;
specifier|private
name|boolean
name|messagePrioritySupported
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|transactedIndividualAck
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|nonBlockingRedelivery
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|rmIdFromConnectionId
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|maxThreadPoolSize
init|=
name|DEFAULT_THREAD_POOL_SIZE
decl_stmt|;
specifier|private
name|RejectedExecutionHandler
name|rejectedTaskHandler
init|=
literal|null
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|trustedPackages
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|trustAllPackages
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|connectResponseTimeout
decl_stmt|;
comment|/**      * Construct an<code>ActiveMQConnection</code>      *      * @param transport      * @param factoryStats      * @throws Exception      */
specifier|protected
name|ActiveMQConnection
parameter_list|(
specifier|final
name|Transport
name|transport
parameter_list|,
name|IdGenerator
name|clientIdGenerator
parameter_list|,
name|IdGenerator
name|connectionIdGenerator
parameter_list|,
name|JMSStatsImpl
name|factoryStats
parameter_list|)
throws|throws
name|Exception
block|{
name|this
operator|.
name|transport
operator|=
name|transport
expr_stmt|;
name|this
operator|.
name|clientIdGenerator
operator|=
name|clientIdGenerator
expr_stmt|;
name|this
operator|.
name|factoryStats
operator|=
name|factoryStats
expr_stmt|;
comment|// Configure a single threaded executor who's core thread can timeout if
comment|// idle
name|executor
operator|=
operator|new
name|ThreadPoolExecutor
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ThreadFactory
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
name|Thread
name|thread
init|=
operator|new
name|Thread
argument_list|(
name|r
argument_list|,
literal|"ActiveMQ Connection Executor: "
operator|+
name|transport
argument_list|)
decl_stmt|;
comment|//Don't make these daemon threads - see https://issues.apache.org/jira/browse/AMQ-796
comment|//thread.setDaemon(true);
return|return
name|thread
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// asyncConnectionThread.allowCoreThreadTimeOut(true);
name|String
name|uniqueId
init|=
name|connectionIdGenerator
operator|.
name|generateId
argument_list|()
decl_stmt|;
name|this
operator|.
name|info
operator|=
operator|new
name|ConnectionInfo
argument_list|(
operator|new
name|ConnectionId
argument_list|(
name|uniqueId
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|info
operator|.
name|setManageable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|info
operator|.
name|setFaultTolerant
argument_list|(
name|transport
operator|.
name|isFaultTolerant
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|connectionSessionId
operator|=
operator|new
name|SessionId
argument_list|(
name|info
operator|.
name|getConnectionId
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|this
operator|.
name|transport
operator|.
name|setTransportListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|stats
operator|=
operator|new
name|JMSConnectionStatsImpl
argument_list|(
name|sessions
argument_list|,
name|this
operator|instanceof
name|XAConnection
argument_list|)
expr_stmt|;
name|this
operator|.
name|factoryStats
operator|.
name|addConnection
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|timeCreated
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|this
operator|.
name|connectionAudit
operator|.
name|setCheckForDuplicates
argument_list|(
name|transport
operator|.
name|isFaultTolerant
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|setUserName
parameter_list|(
name|String
name|userName
parameter_list|)
block|{
name|this
operator|.
name|info
operator|.
name|setUserName
argument_list|(
name|userName
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|setPassword
parameter_list|(
name|String
name|password
parameter_list|)
block|{
name|this
operator|.
name|info
operator|.
name|setPassword
argument_list|(
name|password
argument_list|)
expr_stmt|;
block|}
comment|/**      * A static helper method to create a new connection      *      * @return an ActiveMQConnection      * @throws JMSException      */
specifier|public
specifier|static
name|ActiveMQConnection
name|makeConnection
parameter_list|()
throws|throws
name|JMSException
block|{
name|ActiveMQConnectionFactory
name|factory
init|=
operator|new
name|ActiveMQConnectionFactory
argument_list|()
decl_stmt|;
return|return
operator|(
name|ActiveMQConnection
operator|)
name|factory
operator|.
name|createConnection
argument_list|()
return|;
block|}
comment|/**      * A static helper method to create a new connection      *      * @param uri      * @return and ActiveMQConnection      * @throws JMSException      */
specifier|public
specifier|static
name|ActiveMQConnection
name|makeConnection
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|JMSException
throws|,
name|URISyntaxException
block|{
name|ActiveMQConnectionFactory
name|factory
init|=
operator|new
name|ActiveMQConnectionFactory
argument_list|(
name|uri
argument_list|)
decl_stmt|;
return|return
operator|(
name|ActiveMQConnection
operator|)
name|factory
operator|.
name|createConnection
argument_list|()
return|;
block|}
comment|/**      * A static helper method to create a new connection      *      * @param user      * @param password      * @param uri      * @return an ActiveMQConnection      * @throws JMSException      */
specifier|public
specifier|static
name|ActiveMQConnection
name|makeConnection
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|password
parameter_list|,
name|String
name|uri
parameter_list|)
throws|throws
name|JMSException
throws|,
name|URISyntaxException
block|{
name|ActiveMQConnectionFactory
name|factory
init|=
operator|new
name|ActiveMQConnectionFactory
argument_list|(
name|user
argument_list|,
name|password
argument_list|,
operator|new
name|URI
argument_list|(
name|uri
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|ActiveMQConnection
operator|)
name|factory
operator|.
name|createConnection
argument_list|()
return|;
block|}
comment|/**      * @return a number unique for this connection      */
specifier|public
name|JMSConnectionStatsImpl
name|getConnectionStats
parameter_list|()
block|{
return|return
name|stats
return|;
block|}
comment|/**      * Creates a<CODE>Session</CODE> object.      *      * @param transacted indicates whether the session is transacted      * @param acknowledgeMode indicates whether the consumer or the client will      *                acknowledge any messages it receives; ignored if the      *                session is transacted. Legal values are      *<code>Session.AUTO_ACKNOWLEDGE</code>,      *<code>Session.CLIENT_ACKNOWLEDGE</code>, and      *<code>Session.DUPS_OK_ACKNOWLEDGE</code>.      * @return a newly created session      * @throws JMSException if the<CODE>Connection</CODE> object fails to      *                 create a session due to some internal error or lack of      *                 support for the specific transaction and acknowledgement      *                 mode.      * @see Session#AUTO_ACKNOWLEDGE      * @see Session#CLIENT_ACKNOWLEDGE      * @see Session#DUPS_OK_ACKNOWLEDGE      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|Session
name|createSession
parameter_list|(
name|boolean
name|transacted
parameter_list|,
name|int
name|acknowledgeMode
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
name|ensureConnectionInfoSent
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|transacted
condition|)
block|{
if|if
condition|(
name|acknowledgeMode
operator|==
name|Session
operator|.
name|SESSION_TRANSACTED
condition|)
block|{
throw|throw
operator|new
name|JMSException
argument_list|(
literal|"acknowledgeMode SESSION_TRANSACTED cannot be used for an non-transacted Session"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|acknowledgeMode
argument_list|<
name|Session
operator|.
name|SESSION_TRANSACTED
operator|||
name|acknowledgeMode
argument_list|>
name|ActiveMQSession
operator|.
name|MAX_ACK_CONSTANT
condition|)
block|{
throw|throw
operator|new
name|JMSException
argument_list|(
literal|"invalid acknowledgeMode: "
operator|+
name|acknowledgeMode
operator|+
literal|". Valid values are Session.AUTO_ACKNOWLEDGE (1), "
operator|+
literal|"Session.CLIENT_ACKNOWLEDGE (2), Session.DUPS_OK_ACKNOWLEDGE (3), ActiveMQSession.INDIVIDUAL_ACKNOWLEDGE (4) or for transacted sessions Session.SESSION_TRANSACTED (0)"
argument_list|)
throw|;
block|}
block|}
return|return
operator|new
name|ActiveMQSession
argument_list|(
name|this
argument_list|,
name|getNextSessionId
argument_list|()
argument_list|,
name|transacted
condition|?
name|Session
operator|.
name|SESSION_TRANSACTED
else|:
name|acknowledgeMode
argument_list|,
name|isDispatchAsync
argument_list|()
argument_list|,
name|isAlwaysSessionAsync
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @return sessionId      */
specifier|protected
name|SessionId
name|getNextSessionId
parameter_list|()
block|{
return|return
operator|new
name|SessionId
argument_list|(
name|info
operator|.
name|getConnectionId
argument_list|()
argument_list|,
name|sessionIdGenerator
operator|.
name|getNextSequenceId
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Gets the client identifier for this connection.      *<P>      * This value is specific to the JMS provider. It is either preconfigured by      * an administrator in a<CODE> ConnectionFactory</CODE> object or assigned      * dynamically by the application by calling the<code>setClientID</code>      * method.      *      * @return the unique client identifier      * @throws JMSException if the JMS provider fails to return the client ID      *                 for this connection due to some internal error.      */
annotation|@
name|Override
specifier|public
name|String
name|getClientID
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|info
operator|.
name|getClientId
argument_list|()
return|;
block|}
comment|/**      * Sets the client identifier for this connection.      *<P>      * The preferred way to assign a JMS client's client identifier is for it to      * be configured in a client-specific<CODE>ConnectionFactory</CODE>      * object and transparently assigned to the<CODE>Connection</CODE> object      * it creates.      *<P>      * Alternatively, a client can set a connection's client identifier using a      * provider-specific value. The facility to set a connection's client      * identifier explicitly is not a mechanism for overriding the identifier      * that has been administratively configured. It is provided for the case      * where no administratively specified identifier exists. If one does exist,      * an attempt to change it by setting it must throw an      *<CODE>IllegalStateException</CODE>. If a client sets the client      * identifier explicitly, it must do so immediately after it creates the      * connection and before any other action on the connection is taken. After      * this point, setting the client identifier is a programming error that      * should throw an<CODE>IllegalStateException</CODE>.      *<P>      * The purpose of the client identifier is to associate a connection and its      * objects with a state maintained on behalf of the client by a provider.      * The only such state identified by the JMS API is that required to support      * durable subscriptions.      *<P>      * If another connection with the same<code>clientID</code> is already      * running when this method is called, the JMS provider should detect the      * duplicate ID and throw an<CODE>InvalidClientIDException</CODE>.      *      * @param newClientID the unique client identifier      * @throws JMSException if the JMS provider fails to set the client ID for      *                 this connection due to some internal error.      * @throws javax.jms.InvalidClientIDException if the JMS client specifies an      *                 invalid or duplicate client ID.      * @throws javax.jms.IllegalStateException if the JMS client attempts to set      *                 a connection's client ID at the wrong time or when it has      *                 been administratively configured.      */
annotation|@
name|Override
specifier|public
name|void
name|setClientID
parameter_list|(
name|String
name|newClientID
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|clientIDSet
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The clientID has already been set"
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|isConnectionInfoSentToBroker
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Setting clientID on a used Connection is not allowed"
argument_list|)
throw|;
block|}
name|this
operator|.
name|info
operator|.
name|setClientId
argument_list|(
name|newClientID
argument_list|)
expr_stmt|;
name|this
operator|.
name|userSpecifiedClientID
operator|=
literal|true
expr_stmt|;
name|ensureConnectionInfoSent
argument_list|()
expr_stmt|;
block|}
comment|/**      * Sets the default client id that the connection will use if explicitly not      * set with the setClientId() call.      */
specifier|public
name|void
name|setDefaultClientID
parameter_list|(
name|String
name|clientID
parameter_list|)
throws|throws
name|JMSException
block|{
name|this
operator|.
name|info
operator|.
name|setClientId
argument_list|(
name|clientID
argument_list|)
expr_stmt|;
name|this
operator|.
name|userSpecifiedClientID
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Gets the metadata for this connection.      *      * @return the connection metadata      * @throws JMSException if the JMS provider fails to get the connection      *                 metadata for this connection.      * @see javax.jms.ConnectionMetaData      */
annotation|@
name|Override
specifier|public
name|ConnectionMetaData
name|getMetaData
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
return|return
name|ActiveMQConnectionMetaData
operator|.
name|INSTANCE
return|;
block|}
comment|/**      * Gets the<CODE>ExceptionListener</CODE> object for this connection. Not      * every<CODE>Connection</CODE> has an<CODE>ExceptionListener</CODE>      * associated with it.      *      * @return the<CODE>ExceptionListener</CODE> for this connection, or      *         null, if no<CODE>ExceptionListener</CODE> is associated with      *         this connection.      * @throws JMSException if the JMS provider fails to get the      *<CODE>ExceptionListener</CODE> for this connection.      * @see javax.jms.Connection#setExceptionListener(ExceptionListener)      */
annotation|@
name|Override
specifier|public
name|ExceptionListener
name|getExceptionListener
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
return|return
name|this
operator|.
name|exceptionListener
return|;
block|}
comment|/**      * Sets an exception listener for this connection.      *<P>      * If a JMS provider detects a serious problem with a connection, it informs      * the connection's<CODE> ExceptionListener</CODE>, if one has been      * registered. It does this by calling the listener's<CODE>onException      *</CODE>      * method, passing it a<CODE>JMSException</CODE> object describing the      * problem.      *<P>      * An exception listener allows a client to be notified of a problem      * asynchronously. Some connections only consume messages, so they would      * have no other way to learn their connection has failed.      *<P>      * A connection serializes execution of its<CODE>ExceptionListener</CODE>.      *<P>      * A JMS provider should attempt to resolve connection problems itself      * before it notifies the client of them.      *      * @param listener the exception listener      * @throws JMSException if the JMS provider fails to set the exception      *                 listener for this connection.      */
annotation|@
name|Override
specifier|public
name|void
name|setExceptionListener
parameter_list|(
name|ExceptionListener
name|listener
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
name|this
operator|.
name|exceptionListener
operator|=
name|listener
expr_stmt|;
block|}
comment|/**      * Gets the<code>ClientInternalExceptionListener</code> object for this connection.      * Not every<CODE>ActiveMQConnectionn</CODE> has a<CODE>ClientInternalExceptionListener</CODE>      * associated with it.      *      * @return the listener or<code>null</code> if no listener is registered with the connection.      */
specifier|public
name|ClientInternalExceptionListener
name|getClientInternalExceptionListener
parameter_list|()
block|{
return|return
name|clientInternalExceptionListener
return|;
block|}
comment|/**      * Sets a client internal exception listener for this connection.      * The connection will notify the listener, if one has been registered, of exceptions thrown by container components      * (e.g. an EJB container in case of Message Driven Beans) during asynchronous processing of a message.      * It does this by calling the listener's<code>onException()</code> method passing it a<code>Throwable</code>      * describing the problem.      *      * @param listener the exception listener      */
specifier|public
name|void
name|setClientInternalExceptionListener
parameter_list|(
name|ClientInternalExceptionListener
name|listener
parameter_list|)
block|{
name|this
operator|.
name|clientInternalExceptionListener
operator|=
name|listener
expr_stmt|;
block|}
comment|/**      * Starts (or restarts) a connection's delivery of incoming messages. A call      * to<CODE>start</CODE> on a connection that has already been started is      * ignored.      *      * @throws JMSException if the JMS provider fails to start message delivery      *                 due to some internal error.      * @see javax.jms.Connection#stop()      */
annotation|@
name|Override
specifier|public
name|void
name|start
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
name|ensureConnectionInfoSent
argument_list|()
expr_stmt|;
if|if
condition|(
name|started
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQSession
argument_list|>
name|i
init|=
name|sessions
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQSession
name|session
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|session
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Temporarily stops a connection's delivery of incoming messages. Delivery      * can be restarted using the connection's<CODE>start</CODE> method. When      * the connection is stopped, delivery to all the connection's message      * consumers is inhibited: synchronous receives block, and messages are not      * delivered to message listeners.      *<P>      * This call blocks until receives and/or message listeners in progress have      * completed.      *<P>      * Stopping a connection has no effect on its ability to send messages. A      * call to<CODE>stop</CODE> on a connection that has already been stopped      * is ignored.      *<P>      * A call to<CODE>stop</CODE> must not return until delivery of messages      * has paused. This means that a client can rely on the fact that none of      * its message listeners will be called and that all threads of control      * waiting for<CODE>receive</CODE> calls to return will not return with a      * message until the connection is restarted. The receive timers for a      * stopped connection continue to advance, so receives may time out while      * the connection is stopped.      *<P>      * If message listeners are running when<CODE>stop</CODE> is invoked, the      *<CODE>stop</CODE> call must wait until all of them have returned before      * it may return. While these message listeners are completing, they must      * have the full services of the connection available to them.      *      * @throws JMSException if the JMS provider fails to stop message delivery      *                 due to some internal error.      * @see javax.jms.Connection#start()      */
annotation|@
name|Override
specifier|public
name|void
name|stop
parameter_list|()
throws|throws
name|JMSException
block|{
name|doStop
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * @see #stop()      * @param checkClosed<tt>true</tt> to check for already closed and throw {@link java.lang.IllegalStateException} if already closed,      *<tt>false</tt> to skip this check      * @throws JMSException if the JMS provider fails to stop message delivery due to some internal error.      */
name|void
name|doStop
parameter_list|(
name|boolean
name|checkClosed
parameter_list|)
throws|throws
name|JMSException
block|{
if|if
condition|(
name|checkClosed
condition|)
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|started
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|sessions
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQSession
argument_list|>
name|i
init|=
name|sessions
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQSession
name|s
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|s
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Closes the connection.      *<P>      * Since a provider typically allocates significant resources outside the      * JVM on behalf of a connection, clients should close these resources when      * they are not needed. Relying on garbage collection to eventually reclaim      * these resources may not be timely enough.      *<P>      * There is no need to close the sessions, producers, and consumers of a      * closed connection.      *<P>      * Closing a connection causes all temporary destinations to be deleted.      *<P>      * When this method is invoked, it should not return until message      * processing has been shut down in an orderly fashion. This means that all      * message listeners that may have been running have returned, and that all      * pending receives have returned. A close terminates all pending message      * receives on the connection's sessions' consumers. The receives may return      * with a message or with null, depending on whether there was a message      * available at the time of the close. If one or more of the connection's      * sessions' message listeners is processing a message at the time when      * connection<CODE>close</CODE> is invoked, all the facilities of the      * connection and its sessions must remain available to those listeners      * until they return control to the JMS provider.      *<P>      * Closing a connection causes any of its sessions' transactions in progress      * to be rolled back. In the case where a session's work is coordinated by      * an external transaction manager, a session's<CODE>commit</CODE> and      *<CODE> rollback</CODE> methods are not used and the result of a closed      * session's work is determined later by the transaction manager. Closing a      * connection does NOT force an acknowledgment of client-acknowledged      * sessions.      *<P>      * Invoking the<CODE>acknowledge</CODE> method of a received message from      * a closed connection's session must throw an      *<CODE>IllegalStateException</CODE>. Closing a closed connection must      * NOT throw an exception.      *      * @throws JMSException if the JMS provider fails to close the connection      *                 due to some internal error. For example, a failure to      *                 release resources or to close a socket connection can      *                 cause this exception to be thrown.      */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|JMSException
block|{
try|try
block|{
comment|// If we were running, lets stop first.
if|if
condition|(
operator|!
name|closed
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|transportFailed
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// do not fail if already closed as according to JMS spec we must not
comment|// throw exception if already closed
name|doStop
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
name|closing
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|destinationSource
operator|!=
literal|null
condition|)
block|{
name|destinationSource
operator|.
name|stop
argument_list|()
expr_stmt|;
name|destinationSource
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|advisoryConsumer
operator|!=
literal|null
condition|)
block|{
name|advisoryConsumer
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|advisoryConsumer
operator|=
literal|null
expr_stmt|;
block|}
name|Scheduler
name|scheduler
init|=
name|this
operator|.
name|scheduler
decl_stmt|;
if|if
condition|(
name|scheduler
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|scheduler
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|JMSException
name|ex
init|=
name|JMSExceptionSupport
operator|.
name|create
argument_list|(
name|e
argument_list|)
decl_stmt|;
throw|throw
name|ex
throw|;
block|}
block|}
name|long
name|lastDeliveredSequenceId
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQSession
argument_list|>
name|i
init|=
name|this
operator|.
name|sessions
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQSession
name|s
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|s
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|lastDeliveredSequenceId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|lastDeliveredSequenceId
argument_list|,
name|s
operator|.
name|getLastDeliveredSequenceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQConnectionConsumer
argument_list|>
name|i
init|=
name|this
operator|.
name|connectionConsumers
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQConnectionConsumer
name|c
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|c
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|activeTempDestinations
operator|.
name|clear
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|isConnectionInfoSentToBroker
condition|)
block|{
comment|// If we announced ourselves to the broker.. Try to let the broker
comment|// know that the connection is being shutdown.
name|RemoveInfo
name|removeCommand
init|=
name|info
operator|.
name|createRemoveCommand
argument_list|()
decl_stmt|;
name|removeCommand
operator|.
name|setLastDeliveredSequenceId
argument_list|(
name|lastDeliveredSequenceId
argument_list|)
expr_stmt|;
try|try
block|{
name|syncSendPacket
argument_list|(
name|removeCommand
argument_list|,
name|closeTimeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|JMSException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|RequestTimedOutIOException
condition|)
block|{
comment|// expected
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
name|doAsyncSendPacket
argument_list|(
operator|new
name|ShutdownInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// release anyway even if previous communication fails
name|started
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// TODO if we move the TaskRunnerFactory to the connection
comment|// factory
comment|// then we may need to call
comment|// factory.onConnectionClose(this);
if|if
condition|(
name|sessionTaskRunner
operator|!=
literal|null
condition|)
block|{
name|sessionTaskRunner
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|closed
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|closing
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|executor
operator|!=
literal|null
condition|)
block|{
name|ThreadPoolUtils
operator|.
name|shutdown
argument_list|(
name|executor
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error shutting down thread pool: "
operator|+
name|executor
operator|+
literal|". This exception will be ignored."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|ServiceSupport
operator|.
name|dispose
argument_list|(
name|this
operator|.
name|transport
argument_list|)
expr_stmt|;
name|factoryStats
operator|.
name|removeConnection
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Tells the broker to terminate its VM. This can be used to cleanly      * terminate a broker running in a standalone java process. Server must have      * property enable.vm.shutdown=true defined to allow this to work.      */
comment|// TODO : org.apache.activemq.message.BrokerAdminCommand not yet
comment|// implemented.
comment|/*      * public void terminateBrokerVM() throws JMSException { BrokerAdminCommand      * command = new BrokerAdminCommand();      * command.setCommand(BrokerAdminCommand.SHUTDOWN_SERVER_VM);      * asyncSendPacket(command); }      */
comment|/**      * Create a durable connection consumer for this connection (optional      * operation). This is an expert facility not used by regular JMS clients.      *      * @param topic topic to access      * @param subscriptionName durable subscription name      * @param messageSelector only messages with properties matching the message      *                selector expression are delivered. A value of null or an      *                empty string indicates that there is no message selector      *                for the message consumer.      * @param sessionPool the server session pool to associate with this durable      *                connection consumer      * @param maxMessages the maximum number of messages that can be assigned to      *                a server session at one time      * @return the durable connection consumer      * @throws JMSException if the<CODE>Connection</CODE> object fails to      *                 create a connection consumer due to some internal error      *                 or invalid arguments for<CODE>sessionPool</CODE> and      *<CODE>messageSelector</CODE>.      * @throws javax.jms.InvalidDestinationException if an invalid destination      *                 is specified.      * @throws javax.jms.InvalidSelectorException if the message selector is      *                 invalid.      * @see javax.jms.ConnectionConsumer      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|ConnectionConsumer
name|createDurableConnectionConsumer
parameter_list|(
name|Topic
name|topic
parameter_list|,
name|String
name|subscriptionName
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|ServerSessionPool
name|sessionPool
parameter_list|,
name|int
name|maxMessages
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
name|this
operator|.
name|createDurableConnectionConsumer
argument_list|(
name|topic
argument_list|,
name|subscriptionName
argument_list|,
name|messageSelector
argument_list|,
name|sessionPool
argument_list|,
name|maxMessages
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Create a durable connection consumer for this connection (optional      * operation). This is an expert facility not used by regular JMS clients.      *      * @param topic topic to access      * @param subscriptionName durable subscription name      * @param messageSelector only messages with properties matching the message      *                selector expression are delivered. A value of null or an      *                empty string indicates that there is no message selector      *                for the message consumer.      * @param sessionPool the server session pool to associate with this durable      *                connection consumer      * @param maxMessages the maximum number of messages that can be assigned to      *                a server session at one time      * @param noLocal set true if you want to filter out messages published      *                locally      * @return the durable connection consumer      * @throws JMSException if the<CODE>Connection</CODE> object fails to      *                 create a connection consumer due to some internal error      *                 or invalid arguments for<CODE>sessionPool</CODE> and      *<CODE>messageSelector</CODE>.      * @throws javax.jms.InvalidDestinationException if an invalid destination      *                 is specified.      * @throws javax.jms.InvalidSelectorException if the message selector is      *                 invalid.      * @see javax.jms.ConnectionConsumer      * @since 1.1      */
specifier|public
name|ConnectionConsumer
name|createDurableConnectionConsumer
parameter_list|(
name|Topic
name|topic
parameter_list|,
name|String
name|subscriptionName
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|ServerSessionPool
name|sessionPool
parameter_list|,
name|int
name|maxMessages
parameter_list|,
name|boolean
name|noLocal
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
if|if
condition|(
name|queueOnlyConnection
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"QueueConnection cannot be used to create Pub/Sub based resources."
argument_list|)
throw|;
block|}
name|ensureConnectionInfoSent
argument_list|()
expr_stmt|;
name|SessionId
name|sessionId
init|=
operator|new
name|SessionId
argument_list|(
name|info
operator|.
name|getConnectionId
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ConsumerInfo
name|info
init|=
operator|new
name|ConsumerInfo
argument_list|(
operator|new
name|ConsumerId
argument_list|(
name|sessionId
argument_list|,
name|consumerIdGenerator
operator|.
name|getNextSequenceId
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|info
operator|.
name|setDestination
argument_list|(
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|topic
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|setSubscriptionName
argument_list|(
name|subscriptionName
argument_list|)
expr_stmt|;
name|info
operator|.
name|setSelector
argument_list|(
name|messageSelector
argument_list|)
expr_stmt|;
name|info
operator|.
name|setPrefetchSize
argument_list|(
name|maxMessages
argument_list|)
expr_stmt|;
name|info
operator|.
name|setDispatchAsync
argument_list|(
name|isDispatchAsync
argument_list|()
argument_list|)
expr_stmt|;
comment|// Allows the options on the destination to configure the consumerInfo
if|if
condition|(
name|info
operator|.
name|getDestination
argument_list|()
operator|.
name|getOptions
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|info
operator|.
name|getDestination
argument_list|()
operator|.
name|getOptions
argument_list|()
argument_list|)
decl_stmt|;
name|IntrospectionSupport
operator|.
name|setProperties
argument_list|(
name|this
operator|.
name|info
argument_list|,
name|options
argument_list|,
literal|"consumer."
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ActiveMQConnectionConsumer
argument_list|(
name|this
argument_list|,
name|sessionPool
argument_list|,
name|info
argument_list|)
return|;
block|}
comment|// Properties
comment|// -------------------------------------------------------------------------
comment|/**      * Returns true if this connection has been started      *      * @return true if this Connection is started      */
specifier|public
name|boolean
name|isStarted
parameter_list|()
block|{
return|return
name|started
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**      * Returns true if the connection is closed      */
specifier|public
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|closed
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**      * Returns true if the connection is in the process of being closed      */
specifier|public
name|boolean
name|isClosing
parameter_list|()
block|{
return|return
name|closing
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**      * Returns true if the underlying transport has failed      */
specifier|public
name|boolean
name|isTransportFailed
parameter_list|()
block|{
return|return
name|transportFailed
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**      * @return Returns the prefetchPolicy.      */
specifier|public
name|ActiveMQPrefetchPolicy
name|getPrefetchPolicy
parameter_list|()
block|{
return|return
name|prefetchPolicy
return|;
block|}
comment|/**      * Sets the<a      * href="http://activemq.apache.org/what-is-the-prefetch-limit-for.html">prefetch      * policy</a> for consumers created by this connection.      */
specifier|public
name|void
name|setPrefetchPolicy
parameter_list|(
name|ActiveMQPrefetchPolicy
name|prefetchPolicy
parameter_list|)
block|{
name|this
operator|.
name|prefetchPolicy
operator|=
name|prefetchPolicy
expr_stmt|;
block|}
comment|/**      */
specifier|public
name|Transport
name|getTransportChannel
parameter_list|()
block|{
return|return
name|transport
return|;
block|}
comment|/**      * @return Returns the clientID of the connection, forcing one to be      *         generated if one has not yet been configured.      */
specifier|public
name|String
name|getInitializedClientID
parameter_list|()
throws|throws
name|JMSException
block|{
name|ensureConnectionInfoSent
argument_list|()
expr_stmt|;
return|return
name|info
operator|.
name|getClientId
argument_list|()
return|;
block|}
comment|/**      * @return Returns the timeStampsDisableByDefault.      */
specifier|public
name|boolean
name|isDisableTimeStampsByDefault
parameter_list|()
block|{
return|return
name|disableTimeStampsByDefault
return|;
block|}
comment|/**      * Sets whether or not timestamps on messages should be disabled or not. If      * you disable them it adds a small performance boost.      */
specifier|public
name|void
name|setDisableTimeStampsByDefault
parameter_list|(
name|boolean
name|timeStampsDisableByDefault
parameter_list|)
block|{
name|this
operator|.
name|disableTimeStampsByDefault
operator|=
name|timeStampsDisableByDefault
expr_stmt|;
block|}
comment|/**      * @return Returns the dispatchOptimizedMessage.      */
specifier|public
name|boolean
name|isOptimizedMessageDispatch
parameter_list|()
block|{
return|return
name|optimizedMessageDispatch
return|;
block|}
comment|/**      * If this flag is set then an larger prefetch limit is used - only      * applicable for durable topic subscribers.      */
specifier|public
name|void
name|setOptimizedMessageDispatch
parameter_list|(
name|boolean
name|dispatchOptimizedMessage
parameter_list|)
block|{
name|this
operator|.
name|optimizedMessageDispatch
operator|=
name|dispatchOptimizedMessage
expr_stmt|;
block|}
comment|/**      * @return Returns the closeTimeout.      */
specifier|public
name|int
name|getCloseTimeout
parameter_list|()
block|{
return|return
name|closeTimeout
return|;
block|}
comment|/**      * Sets the timeout before a close is considered complete. Normally a      * close() on a connection waits for confirmation from the broker; this      * allows that operation to timeout to save the client hanging if there is      * no broker      */
specifier|public
name|void
name|setCloseTimeout
parameter_list|(
name|int
name|closeTimeout
parameter_list|)
block|{
name|this
operator|.
name|closeTimeout
operator|=
name|closeTimeout
expr_stmt|;
block|}
comment|/**      * @return ConnectionInfo      */
specifier|public
name|ConnectionInfo
name|getConnectionInfo
parameter_list|()
block|{
return|return
name|this
operator|.
name|info
return|;
block|}
specifier|public
name|boolean
name|isUseRetroactiveConsumer
parameter_list|()
block|{
return|return
name|useRetroactiveConsumer
return|;
block|}
comment|/**      * Sets whether or not retroactive consumers are enabled. Retroactive      * consumers allow non-durable topic subscribers to receive old messages      * that were published before the non-durable subscriber started.      */
specifier|public
name|void
name|setUseRetroactiveConsumer
parameter_list|(
name|boolean
name|useRetroactiveConsumer
parameter_list|)
block|{
name|this
operator|.
name|useRetroactiveConsumer
operator|=
name|useRetroactiveConsumer
expr_stmt|;
block|}
specifier|public
name|boolean
name|isNestedMapAndListEnabled
parameter_list|()
block|{
return|return
name|nestedMapAndListEnabled
return|;
block|}
comment|/**      * Enables/disables whether or not Message properties and MapMessage entries      * support<a      * href="http://activemq.apache.org/structured-message-properties-and-mapmessages.html">Nested      * Structures</a> of Map and List objects      */
specifier|public
name|void
name|setNestedMapAndListEnabled
parameter_list|(
name|boolean
name|structuredMapsEnabled
parameter_list|)
block|{
name|this
operator|.
name|nestedMapAndListEnabled
operator|=
name|structuredMapsEnabled
expr_stmt|;
block|}
specifier|public
name|boolean
name|isExclusiveConsumer
parameter_list|()
block|{
return|return
name|exclusiveConsumer
return|;
block|}
comment|/**      * Enables or disables whether or not queue consumers should be exclusive or      * not for example to preserve ordering when not using<a      * href="http://activemq.apache.org/message-groups.html">Message Groups</a>      *      * @param exclusiveConsumer      */
specifier|public
name|void
name|setExclusiveConsumer
parameter_list|(
name|boolean
name|exclusiveConsumer
parameter_list|)
block|{
name|this
operator|.
name|exclusiveConsumer
operator|=
name|exclusiveConsumer
expr_stmt|;
block|}
comment|/**      * Adds a transport listener so that a client can be notified of events in      * the underlying transport      */
specifier|public
name|void
name|addTransportListener
parameter_list|(
name|TransportListener
name|transportListener
parameter_list|)
block|{
name|transportListeners
operator|.
name|add
argument_list|(
name|transportListener
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|removeTransportListener
parameter_list|(
name|TransportListener
name|transportListener
parameter_list|)
block|{
name|transportListeners
operator|.
name|remove
argument_list|(
name|transportListener
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|isUseDedicatedTaskRunner
parameter_list|()
block|{
return|return
name|useDedicatedTaskRunner
return|;
block|}
specifier|public
name|void
name|setUseDedicatedTaskRunner
parameter_list|(
name|boolean
name|useDedicatedTaskRunner
parameter_list|)
block|{
name|this
operator|.
name|useDedicatedTaskRunner
operator|=
name|useDedicatedTaskRunner
expr_stmt|;
block|}
specifier|public
name|TaskRunnerFactory
name|getSessionTaskRunner
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|sessionTaskRunner
operator|==
literal|null
condition|)
block|{
name|sessionTaskRunner
operator|=
operator|new
name|TaskRunnerFactory
argument_list|(
literal|"ActiveMQ Session Task"
argument_list|,
name|ThreadPriorities
operator|.
name|INBOUND_CLIENT_SESSION
argument_list|,
literal|false
argument_list|,
literal|1000
argument_list|,
name|isUseDedicatedTaskRunner
argument_list|()
argument_list|,
name|maxThreadPoolSize
argument_list|)
expr_stmt|;
name|sessionTaskRunner
operator|.
name|setRejectedTaskHandler
argument_list|(
name|rejectedTaskHandler
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sessionTaskRunner
return|;
block|}
specifier|public
name|void
name|setSessionTaskRunner
parameter_list|(
name|TaskRunnerFactory
name|sessionTaskRunner
parameter_list|)
block|{
name|this
operator|.
name|sessionTaskRunner
operator|=
name|sessionTaskRunner
expr_stmt|;
block|}
specifier|public
name|MessageTransformer
name|getTransformer
parameter_list|()
block|{
return|return
name|transformer
return|;
block|}
comment|/**      * Sets the transformer used to transform messages before they are sent on      * to the JMS bus or when they are received from the bus but before they are      * delivered to the JMS client      */
specifier|public
name|void
name|setTransformer
parameter_list|(
name|MessageTransformer
name|transformer
parameter_list|)
block|{
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
block|}
comment|/**      * @return the statsEnabled      */
specifier|public
name|boolean
name|isStatsEnabled
parameter_list|()
block|{
return|return
name|this
operator|.
name|stats
operator|.
name|isEnabled
argument_list|()
return|;
block|}
comment|/**      * @param statsEnabled the statsEnabled to set      */
specifier|public
name|void
name|setStatsEnabled
parameter_list|(
name|boolean
name|statsEnabled
parameter_list|)
block|{
name|this
operator|.
name|stats
operator|.
name|setEnabled
argument_list|(
name|statsEnabled
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the {@link DestinationSource} object which can be used to listen to destinations      * being created or destroyed or to enquire about the current destinations available on the broker      *      * @return a lazily created destination source      * @throws JMSException      */
annotation|@
name|Override
specifier|public
name|DestinationSource
name|getDestinationSource
parameter_list|()
throws|throws
name|JMSException
block|{
if|if
condition|(
name|destinationSource
operator|==
literal|null
condition|)
block|{
name|destinationSource
operator|=
operator|new
name|DestinationSource
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|destinationSource
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
return|return
name|destinationSource
return|;
block|}
comment|// Implementation methods
comment|// -------------------------------------------------------------------------
comment|/**      * Used internally for adding Sessions to the Connection      *      * @param session      * @throws JMSException      * @throws JMSException      */
specifier|protected
name|void
name|addSession
parameter_list|(
name|ActiveMQSession
name|session
parameter_list|)
throws|throws
name|JMSException
block|{
name|this
operator|.
name|sessions
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
if|if
condition|(
name|sessions
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
name|session
operator|.
name|isTransacted
argument_list|()
condition|)
block|{
name|optimizedMessageDispatch
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|/**      * Used interanlly for removing Sessions from a Connection      *      * @param session      */
specifier|protected
name|void
name|removeSession
parameter_list|(
name|ActiveMQSession
name|session
parameter_list|)
block|{
name|this
operator|.
name|sessions
operator|.
name|remove
argument_list|(
name|session
argument_list|)
expr_stmt|;
name|this
operator|.
name|removeDispatcher
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add a ConnectionConsumer      *      * @param connectionConsumer      * @throws JMSException      */
specifier|protected
name|void
name|addConnectionConsumer
parameter_list|(
name|ActiveMQConnectionConsumer
name|connectionConsumer
parameter_list|)
throws|throws
name|JMSException
block|{
name|this
operator|.
name|connectionConsumers
operator|.
name|add
argument_list|(
name|connectionConsumer
argument_list|)
expr_stmt|;
block|}
comment|/**      * Remove a ConnectionConsumer      *      * @param connectionConsumer      */
specifier|protected
name|void
name|removeConnectionConsumer
parameter_list|(
name|ActiveMQConnectionConsumer
name|connectionConsumer
parameter_list|)
block|{
name|this
operator|.
name|connectionConsumers
operator|.
name|remove
argument_list|(
name|connectionConsumer
argument_list|)
expr_stmt|;
name|this
operator|.
name|removeDispatcher
argument_list|(
name|connectionConsumer
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a<CODE>TopicSession</CODE> object.      *      * @param transacted indicates whether the session is transacted      * @param acknowledgeMode indicates whether the consumer or the client will      *                acknowledge any messages it receives; ignored if the      *                session is transacted. Legal values are      *<code>Session.AUTO_ACKNOWLEDGE</code>,      *<code>Session.CLIENT_ACKNOWLEDGE</code>, and      *<code>Session.DUPS_OK_ACKNOWLEDGE</code>.      * @return a newly created topic session      * @throws JMSException if the<CODE>TopicConnection</CODE> object fails      *                 to create a session due to some internal error or lack of      *                 support for the specific transaction and acknowledgement      *                 mode.      * @see Session#AUTO_ACKNOWLEDGE      * @see Session#CLIENT_ACKNOWLEDGE      * @see Session#DUPS_OK_ACKNOWLEDGE      */
annotation|@
name|Override
specifier|public
name|TopicSession
name|createTopicSession
parameter_list|(
name|boolean
name|transacted
parameter_list|,
name|int
name|acknowledgeMode
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
operator|new
name|ActiveMQTopicSession
argument_list|(
operator|(
name|ActiveMQSession
operator|)
name|createSession
argument_list|(
name|transacted
argument_list|,
name|acknowledgeMode
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Creates a connection consumer for this connection (optional operation).      * This is an expert facility not used by regular JMS clients.      *      * @param topic the topic to access      * @param messageSelector only messages with properties matching the message      *                selector expression are delivered. A value of null or an      *                empty string indicates that there is no message selector      *                for the message consumer.      * @param sessionPool the server session pool to associate with this      *                connection consumer      * @param maxMessages the maximum number of messages that can be assigned to      *                a server session at one time      * @return the connection consumer      * @throws JMSException if the<CODE>TopicConnection</CODE> object fails      *                 to create a connection consumer due to some internal      *                 error or invalid arguments for<CODE>sessionPool</CODE>      *                 and<CODE>messageSelector</CODE>.      * @throws javax.jms.InvalidDestinationException if an invalid topic is      *                 specified.      * @throws javax.jms.InvalidSelectorException if the message selector is      *                 invalid.      * @see javax.jms.ConnectionConsumer      */
annotation|@
name|Override
specifier|public
name|ConnectionConsumer
name|createConnectionConsumer
parameter_list|(
name|Topic
name|topic
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|ServerSessionPool
name|sessionPool
parameter_list|,
name|int
name|maxMessages
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
name|createConnectionConsumer
argument_list|(
name|topic
argument_list|,
name|messageSelector
argument_list|,
name|sessionPool
argument_list|,
name|maxMessages
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a connection consumer for this connection (optional operation).      * This is an expert facility not used by regular JMS clients.      *      * @param queue the queue to access      * @param messageSelector only messages with properties matching the message      *                selector expression are delivered. A value of null or an      *                empty string indicates that there is no message selector      *                for the message consumer.      * @param sessionPool the server session pool to associate with this      *                connection consumer      * @param maxMessages the maximum number of messages that can be assigned to      *                a server session at one time      * @return the connection consumer      * @throws JMSException if the<CODE>QueueConnection</CODE> object fails      *                 to create a connection consumer due to some internal      *                 error or invalid arguments for<CODE>sessionPool</CODE>      *                 and<CODE>messageSelector</CODE>.      * @throws javax.jms.InvalidDestinationException if an invalid queue is      *                 specified.      * @throws javax.jms.InvalidSelectorException if the message selector is      *                 invalid.      * @see javax.jms.ConnectionConsumer      */
annotation|@
name|Override
specifier|public
name|ConnectionConsumer
name|createConnectionConsumer
parameter_list|(
name|Queue
name|queue
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|ServerSessionPool
name|sessionPool
parameter_list|,
name|int
name|maxMessages
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
name|createConnectionConsumer
argument_list|(
name|queue
argument_list|,
name|messageSelector
argument_list|,
name|sessionPool
argument_list|,
name|maxMessages
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Creates a connection consumer for this connection (optional operation).      * This is an expert facility not used by regular JMS clients.      *      * @param destination the destination to access      * @param messageSelector only messages with properties matching the message      *                selector expression are delivered. A value of null or an      *                empty string indicates that there is no message selector      *                for the message consumer.      * @param sessionPool the server session pool to associate with this      *                connection consumer      * @param maxMessages the maximum number of messages that can be assigned to      *                a server session at one time      * @return the connection consumer      * @throws JMSException if the<CODE>Connection</CODE> object fails to      *                 create a connection consumer due to some internal error      *                 or invalid arguments for<CODE>sessionPool</CODE> and      *<CODE>messageSelector</CODE>.      * @throws javax.jms.InvalidDestinationException if an invalid destination      *                 is specified.      * @throws javax.jms.InvalidSelectorException if the message selector is      *                 invalid.      * @see javax.jms.ConnectionConsumer      * @since 1.1      */
annotation|@
name|Override
specifier|public
name|ConnectionConsumer
name|createConnectionConsumer
parameter_list|(
name|Destination
name|destination
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|ServerSessionPool
name|sessionPool
parameter_list|,
name|int
name|maxMessages
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
name|createConnectionConsumer
argument_list|(
name|destination
argument_list|,
name|messageSelector
argument_list|,
name|sessionPool
argument_list|,
name|maxMessages
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|ConnectionConsumer
name|createConnectionConsumer
parameter_list|(
name|Destination
name|destination
parameter_list|,
name|String
name|messageSelector
parameter_list|,
name|ServerSessionPool
name|sessionPool
parameter_list|,
name|int
name|maxMessages
parameter_list|,
name|boolean
name|noLocal
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
name|ensureConnectionInfoSent
argument_list|()
expr_stmt|;
name|ConsumerId
name|consumerId
init|=
name|createConsumerId
argument_list|()
decl_stmt|;
name|ConsumerInfo
name|consumerInfo
init|=
operator|new
name|ConsumerInfo
argument_list|(
name|consumerId
argument_list|)
decl_stmt|;
name|consumerInfo
operator|.
name|setDestination
argument_list|(
name|ActiveMQMessageTransformation
operator|.
name|transformDestination
argument_list|(
name|destination
argument_list|)
argument_list|)
expr_stmt|;
name|consumerInfo
operator|.
name|setSelector
argument_list|(
name|messageSelector
argument_list|)
expr_stmt|;
name|consumerInfo
operator|.
name|setPrefetchSize
argument_list|(
name|maxMessages
argument_list|)
expr_stmt|;
name|consumerInfo
operator|.
name|setNoLocal
argument_list|(
name|noLocal
argument_list|)
expr_stmt|;
name|consumerInfo
operator|.
name|setDispatchAsync
argument_list|(
name|isDispatchAsync
argument_list|()
argument_list|)
expr_stmt|;
comment|// Allows the options on the destination to configure the consumerInfo
if|if
condition|(
name|consumerInfo
operator|.
name|getDestination
argument_list|()
operator|.
name|getOptions
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|consumerInfo
operator|.
name|getDestination
argument_list|()
operator|.
name|getOptions
argument_list|()
argument_list|)
decl_stmt|;
name|IntrospectionSupport
operator|.
name|setProperties
argument_list|(
name|consumerInfo
argument_list|,
name|options
argument_list|,
literal|"consumer."
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ActiveMQConnectionConsumer
argument_list|(
name|this
argument_list|,
name|sessionPool
argument_list|,
name|consumerInfo
argument_list|)
return|;
block|}
comment|/**      * @return a newly created ConsumedId unique to this connection session instance.      */
specifier|private
name|ConsumerId
name|createConsumerId
parameter_list|()
block|{
return|return
operator|new
name|ConsumerId
argument_list|(
name|connectionSessionId
argument_list|,
name|consumerIdGenerator
operator|.
name|getNextSequenceId
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates a<CODE>QueueSession</CODE> object.      *      * @param transacted indicates whether the session is transacted      * @param acknowledgeMode indicates whether the consumer or the client will      *                acknowledge any messages it receives; ignored if the      *                session is transacted. Legal values are      *<code>Session.AUTO_ACKNOWLEDGE</code>,      *<code>Session.CLIENT_ACKNOWLEDGE</code>, and      *<code>Session.DUPS_OK_ACKNOWLEDGE</code>.      * @return a newly created queue session      * @throws JMSException if the<CODE>QueueConnection</CODE> object fails      *                 to create a session due to some internal error or lack of      *                 support for the specific transaction and acknowledgement      *                 mode.      * @see Session#AUTO_ACKNOWLEDGE      * @see Session#CLIENT_ACKNOWLEDGE      * @see Session#DUPS_OK_ACKNOWLEDGE      */
annotation|@
name|Override
specifier|public
name|QueueSession
name|createQueueSession
parameter_list|(
name|boolean
name|transacted
parameter_list|,
name|int
name|acknowledgeMode
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
operator|new
name|ActiveMQQueueSession
argument_list|(
operator|(
name|ActiveMQSession
operator|)
name|createSession
argument_list|(
name|transacted
argument_list|,
name|acknowledgeMode
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Ensures that the clientID was manually specified and not auto-generated.      * If the clientID was not specified this method will throw an exception.      * This method is used to ensure that the clientID + durableSubscriber name      * are used correctly.      *      * @throws JMSException      */
specifier|public
name|void
name|checkClientIDWasManuallySpecified
parameter_list|()
throws|throws
name|JMSException
block|{
if|if
condition|(
operator|!
name|userSpecifiedClientID
condition|)
block|{
throw|throw
operator|new
name|JMSException
argument_list|(
literal|"You cannot create a durable subscriber without specifying a unique clientID on a Connection"
argument_list|)
throw|;
block|}
block|}
comment|/**      * send a Packet through the Connection - for internal use only      *      * @param command      * @throws JMSException      */
specifier|public
name|void
name|asyncSendPacket
parameter_list|(
name|Command
name|command
parameter_list|)
throws|throws
name|JMSException
block|{
if|if
condition|(
name|isClosed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConnectionClosedException
argument_list|()
throw|;
block|}
else|else
block|{
name|doAsyncSendPacket
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|doAsyncSendPacket
parameter_list|(
name|Command
name|command
parameter_list|)
throws|throws
name|JMSException
block|{
try|try
block|{
name|this
operator|.
name|transport
operator|.
name|oneway
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|JMSExceptionSupport
operator|.
name|create
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Send a packet through a Connection - for internal use only      *      * @param command      *      * @throws JMSException      */
specifier|public
name|void
name|syncSendPacket
parameter_list|(
specifier|final
name|Command
name|command
parameter_list|,
specifier|final
name|AsyncCallback
name|onComplete
parameter_list|)
throws|throws
name|JMSException
block|{
if|if
condition|(
name|onComplete
operator|==
literal|null
condition|)
block|{
name|syncSendPacket
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isClosed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConnectionClosedException
argument_list|()
throw|;
block|}
try|try
block|{
name|this
operator|.
name|transport
operator|.
name|asyncRequest
argument_list|(
name|command
argument_list|,
operator|new
name|ResponseCallback
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onCompletion
parameter_list|(
name|FutureResponse
name|resp
parameter_list|)
block|{
name|Response
name|response
decl_stmt|;
name|Throwable
name|exception
init|=
literal|null
decl_stmt|;
try|try
block|{
name|response
operator|=
name|resp
operator|.
name|getResult
argument_list|()
expr_stmt|;
if|if
condition|(
name|response
operator|.
name|isException
argument_list|()
condition|)
block|{
name|ExceptionResponse
name|er
init|=
operator|(
name|ExceptionResponse
operator|)
name|response
decl_stmt|;
name|exception
operator|=
name|er
operator|.
name|getException
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|exception
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|exception
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|exception
operator|instanceof
name|JMSException
condition|)
block|{
name|onComplete
operator|.
name|onException
argument_list|(
operator|(
name|JMSException
operator|)
name|exception
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isClosed
argument_list|()
operator|||
name|closing
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Received an exception but connection is closing"
argument_list|)
expr_stmt|;
block|}
name|JMSException
name|jmsEx
init|=
literal|null
decl_stmt|;
try|try
block|{
name|jmsEx
operator|=
name|JMSExceptionSupport
operator|.
name|create
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Caught an exception trying to create a JMSException for "
operator|+
name|exception
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// dispose of transport for security exceptions on connection initiation
if|if
condition|(
name|exception
operator|instanceof
name|SecurityException
operator|&&
name|command
operator|instanceof
name|ConnectionInfo
condition|)
block|{
try|try
block|{
name|forceCloseOnSecurityException
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// We throw the original error from the ExceptionResponse instead.
block|}
block|}
if|if
condition|(
name|jmsEx
operator|!=
literal|null
condition|)
block|{
name|onComplete
operator|.
name|onException
argument_list|(
name|jmsEx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|onComplete
operator|.
name|onSuccess
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|JMSExceptionSupport
operator|.
name|create
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|forceCloseOnSecurityException
parameter_list|(
name|Throwable
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"force close on security exception:{}, transport={}"
argument_list|,
name|this
argument_list|,
name|transport
argument_list|,
name|exception
argument_list|)
expr_stmt|;
name|onException
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Force close due to SecurityException on connect"
argument_list|,
name|exception
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Response
name|syncSendPacket
parameter_list|(
name|Command
name|command
parameter_list|,
name|int
name|timeout
parameter_list|)
throws|throws
name|JMSException
block|{
if|if
condition|(
name|isClosed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConnectionClosedException
argument_list|()
throw|;
block|}
else|else
block|{
try|try
block|{
name|Response
name|response
init|=
call|(
name|Response
call|)
argument_list|(
name|timeout
operator|>
literal|0
condition|?
name|this
operator|.
name|transport
operator|.
name|request
argument_list|(
name|command
argument_list|,
name|timeout
argument_list|)
else|:
name|this
operator|.
name|transport
operator|.
name|request
argument_list|(
name|command
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|response
operator|.
name|isException
argument_list|()
condition|)
block|{
name|ExceptionResponse
name|er
init|=
operator|(
name|ExceptionResponse
operator|)
name|response
decl_stmt|;
if|if
condition|(
name|er
operator|.
name|getException
argument_list|()
operator|instanceof
name|JMSException
condition|)
block|{
throw|throw
operator|(
name|JMSException
operator|)
name|er
operator|.
name|getException
argument_list|()
throw|;
block|}
else|else
block|{
if|if
condition|(
name|isClosed
argument_list|()
operator|||
name|closing
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Received an exception but connection is closing"
argument_list|)
expr_stmt|;
block|}
name|JMSException
name|jmsEx
init|=
literal|null
decl_stmt|;
try|try
block|{
name|jmsEx
operator|=
name|JMSExceptionSupport
operator|.
name|create
argument_list|(
name|er
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Caught an exception trying to create a JMSException for "
operator|+
name|er
operator|.
name|getException
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|er
operator|.
name|getException
argument_list|()
operator|instanceof
name|SecurityException
operator|&&
name|command
operator|instanceof
name|ConnectionInfo
condition|)
block|{
try|try
block|{
name|forceCloseOnSecurityException
argument_list|(
name|er
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// We throw the original error from the ExceptionResponse instead.
block|}
block|}
if|if
condition|(
name|jmsEx
operator|!=
literal|null
condition|)
block|{
throw|throw
name|jmsEx
throw|;
block|}
block|}
block|}
return|return
name|response
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|JMSExceptionSupport
operator|.
name|create
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Send a packet through a Connection - for internal use only      *      * @param command      *      * @return the broker Response for the given Command.      *      * @throws JMSException      */
specifier|public
name|Response
name|syncSendPacket
parameter_list|(
name|Command
name|command
parameter_list|)
throws|throws
name|JMSException
block|{
return|return
name|syncSendPacket
argument_list|(
name|command
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**      * @return statistics for this Connection      */
annotation|@
name|Override
specifier|public
name|StatsImpl
name|getStats
parameter_list|()
block|{
return|return
name|stats
return|;
block|}
comment|/**      * simply throws an exception if the Connection is already closed or the      * Transport has failed      *      * @throws JMSException      */
specifier|protected
specifier|synchronized
name|void
name|checkClosedOrFailed
parameter_list|()
throws|throws
name|JMSException
block|{
name|checkClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|transportFailed
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConnectionFailedException
argument_list|(
name|firstFailureError
argument_list|)
throw|;
block|}
block|}
comment|/**      * simply throws an exception if the Connection is already closed      *      * @throws JMSException      */
specifier|protected
specifier|synchronized
name|void
name|checkClosed
parameter_list|()
throws|throws
name|JMSException
block|{
if|if
condition|(
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ConnectionClosedException
argument_list|()
throw|;
block|}
block|}
comment|/**      * Send the ConnectionInfo to the Broker      *      * @throws JMSException      */
specifier|protected
name|void
name|ensureConnectionInfoSent
parameter_list|()
throws|throws
name|JMSException
block|{
synchronized|synchronized
init|(
name|this
operator|.
name|ensureConnectionInfoSentMutex
init|)
block|{
comment|// Can we skip sending the ConnectionInfo packet??
if|if
condition|(
name|isConnectionInfoSentToBroker
operator|||
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
comment|//TODO shouldn't this check be on userSpecifiedClientID rather than the value of clientID?
if|if
condition|(
name|info
operator|.
name|getClientId
argument_list|()
operator|==
literal|null
operator|||
name|info
operator|.
name|getClientId
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|info
operator|.
name|setClientId
argument_list|(
name|clientIdGenerator
operator|.
name|generateId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|syncSendPacket
argument_list|(
name|info
operator|.
name|copy
argument_list|()
argument_list|,
name|getConnectResponseTimeout
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|isConnectionInfoSentToBroker
operator|=
literal|true
expr_stmt|;
comment|// Add a temp destination advisory consumer so that
comment|// We know what the valid temporary destinations are on the
comment|// broker without having to do an RPC to the broker.
name|ConsumerId
name|consumerId
init|=
operator|new
name|ConsumerId
argument_list|(
operator|new
name|SessionId
argument_list|(
name|info
operator|.
name|getConnectionId
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|consumerIdGenerator
operator|.
name|getNextSequenceId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|watchTopicAdvisories
condition|)
block|{
name|advisoryConsumer
operator|=
operator|new
name|AdvisoryConsumer
argument_list|(
name|this
argument_list|,
name|consumerId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
specifier|synchronized
name|boolean
name|isWatchTopicAdvisories
parameter_list|()
block|{
return|return
name|watchTopicAdvisories
return|;
block|}
specifier|public
specifier|synchronized
name|void
name|setWatchTopicAdvisories
parameter_list|(
name|boolean
name|watchTopicAdvisories
parameter_list|)
block|{
name|this
operator|.
name|watchTopicAdvisories
operator|=
name|watchTopicAdvisories
expr_stmt|;
block|}
comment|/**      * @return Returns the useAsyncSend.      */
specifier|public
name|boolean
name|isUseAsyncSend
parameter_list|()
block|{
return|return
name|useAsyncSend
return|;
block|}
comment|/**      * Forces the use of<a      * href="http://activemq.apache.org/async-sends.html">Async Sends</a> which      * adds a massive performance boost; but means that the send() method will      * return immediately whether the message has been sent or not which could      * lead to message loss.      */
specifier|public
name|void
name|setUseAsyncSend
parameter_list|(
name|boolean
name|useAsyncSend
parameter_list|)
block|{
name|this
operator|.
name|useAsyncSend
operator|=
name|useAsyncSend
expr_stmt|;
block|}
comment|/**      * @return true if always sync send messages      */
specifier|public
name|boolean
name|isAlwaysSyncSend
parameter_list|()
block|{
return|return
name|this
operator|.
name|alwaysSyncSend
return|;
block|}
comment|/**      * Set true if always require messages to be sync sent      *      * @param alwaysSyncSend      */
specifier|public
name|void
name|setAlwaysSyncSend
parameter_list|(
name|boolean
name|alwaysSyncSend
parameter_list|)
block|{
name|this
operator|.
name|alwaysSyncSend
operator|=
name|alwaysSyncSend
expr_stmt|;
block|}
comment|/**      * @return the messagePrioritySupported      */
specifier|public
name|boolean
name|isMessagePrioritySupported
parameter_list|()
block|{
return|return
name|this
operator|.
name|messagePrioritySupported
return|;
block|}
comment|/**      * @param messagePrioritySupported the messagePrioritySupported to set      */
specifier|public
name|void
name|setMessagePrioritySupported
parameter_list|(
name|boolean
name|messagePrioritySupported
parameter_list|)
block|{
name|this
operator|.
name|messagePrioritySupported
operator|=
name|messagePrioritySupported
expr_stmt|;
block|}
comment|/**      * Cleans up this connection so that it's state is as if the connection was      * just created. This allows the Resource Adapter to clean up a connection      * so that it can be reused without having to close and recreate the      * connection.      */
specifier|public
name|void
name|cleanup
parameter_list|()
throws|throws
name|JMSException
block|{
name|doCleanup
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|isUserSpecifiedClientID
parameter_list|()
block|{
return|return
name|userSpecifiedClientID
return|;
block|}
specifier|public
name|void
name|doCleanup
parameter_list|(
name|boolean
name|removeConnection
parameter_list|)
throws|throws
name|JMSException
block|{
if|if
condition|(
name|advisoryConsumer
operator|!=
literal|null
operator|&&
operator|!
name|isTransportFailed
argument_list|()
condition|)
block|{
name|advisoryConsumer
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|advisoryConsumer
operator|=
literal|null
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQSession
argument_list|>
name|i
init|=
name|this
operator|.
name|sessions
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQSession
name|s
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|s
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQConnectionConsumer
argument_list|>
name|i
init|=
name|this
operator|.
name|connectionConsumers
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQConnectionConsumer
name|c
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|c
operator|.
name|dispose
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|removeConnection
condition|)
block|{
if|if
condition|(
name|isConnectionInfoSentToBroker
condition|)
block|{
if|if
condition|(
operator|!
name|transportFailed
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|closing
operator|.
name|get
argument_list|()
condition|)
block|{
name|syncSendPacket
argument_list|(
name|info
operator|.
name|createRemoveCommand
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|isConnectionInfoSentToBroker
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|userSpecifiedClientID
condition|)
block|{
name|info
operator|.
name|setClientId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|userSpecifiedClientID
operator|=
literal|false
expr_stmt|;
block|}
name|clientIDSet
operator|=
literal|false
expr_stmt|;
block|}
name|started
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Changes the associated username/password that is associated with this      * connection. If the connection has been used, you must called cleanup()      * before calling this method.      *      * @throws IllegalStateException if the connection is in used.      */
specifier|public
name|void
name|changeUserInfo
parameter_list|(
name|String
name|userName
parameter_list|,
name|String
name|password
parameter_list|)
throws|throws
name|JMSException
block|{
if|if
condition|(
name|isConnectionInfoSentToBroker
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"changeUserInfo used Connection is not allowed"
argument_list|)
throw|;
block|}
name|this
operator|.
name|info
operator|.
name|setUserName
argument_list|(
name|userName
argument_list|)
expr_stmt|;
name|this
operator|.
name|info
operator|.
name|setPassword
argument_list|(
name|password
argument_list|)
expr_stmt|;
block|}
comment|/**      * @return Returns the resourceManagerId.      * @throws JMSException      */
specifier|public
name|String
name|getResourceManagerId
parameter_list|()
throws|throws
name|JMSException
block|{
if|if
condition|(
name|isRmIdFromConnectionId
argument_list|()
condition|)
block|{
return|return
name|info
operator|.
name|getConnectionId
argument_list|()
operator|.
name|getValue
argument_list|()
return|;
block|}
name|waitForBrokerInfo
argument_list|()
expr_stmt|;
if|if
condition|(
name|brokerInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|JMSException
argument_list|(
literal|"Connection failed before Broker info was received."
argument_list|)
throw|;
block|}
return|return
name|brokerInfo
operator|.
name|getBrokerId
argument_list|()
operator|.
name|getValue
argument_list|()
return|;
block|}
comment|/**      * Returns the broker name if one is available or null if one is not      * available yet.      */
specifier|public
name|String
name|getBrokerName
parameter_list|()
block|{
try|try
block|{
name|brokerInfoReceived
operator|.
name|await
argument_list|(
literal|5
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|brokerInfo
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|brokerInfo
operator|.
name|getBrokerName
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Returns the broker information if it is available or null if it is not      * available yet.      */
specifier|public
name|BrokerInfo
name|getBrokerInfo
parameter_list|()
block|{
return|return
name|brokerInfo
return|;
block|}
comment|/**      * @return Returns the RedeliveryPolicy.      * @throws JMSException      */
specifier|public
name|RedeliveryPolicy
name|getRedeliveryPolicy
parameter_list|()
throws|throws
name|JMSException
block|{
return|return
name|redeliveryPolicyMap
operator|.
name|getDefaultEntry
argument_list|()
return|;
block|}
comment|/**      * Sets the redelivery policy to be used when messages are rolled back      */
specifier|public
name|void
name|setRedeliveryPolicy
parameter_list|(
name|RedeliveryPolicy
name|redeliveryPolicy
parameter_list|)
block|{
name|this
operator|.
name|redeliveryPolicyMap
operator|.
name|setDefaultEntry
argument_list|(
name|redeliveryPolicy
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BlobTransferPolicy
name|getBlobTransferPolicy
parameter_list|()
block|{
if|if
condition|(
name|blobTransferPolicy
operator|==
literal|null
condition|)
block|{
name|blobTransferPolicy
operator|=
name|createBlobTransferPolicy
argument_list|()
expr_stmt|;
block|}
return|return
name|blobTransferPolicy
return|;
block|}
comment|/**      * Sets the policy used to describe how out-of-band BLOBs (Binary Large      * OBjects) are transferred from producers to brokers to consumers      */
specifier|public
name|void
name|setBlobTransferPolicy
parameter_list|(
name|BlobTransferPolicy
name|blobTransferPolicy
parameter_list|)
block|{
name|this
operator|.
name|blobTransferPolicy
operator|=
name|blobTransferPolicy
expr_stmt|;
block|}
comment|/**      * @return Returns the alwaysSessionAsync.      */
specifier|public
name|boolean
name|isAlwaysSessionAsync
parameter_list|()
block|{
return|return
name|alwaysSessionAsync
return|;
block|}
comment|/**      * If this flag is not set then a separate thread is not used for dispatching messages for each Session in      * the Connection. However, a separate thread is always used if there is more than one session, or the session      * isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch      * happens asynchronously.      */
specifier|public
name|void
name|setAlwaysSessionAsync
parameter_list|(
name|boolean
name|alwaysSessionAsync
parameter_list|)
block|{
name|this
operator|.
name|alwaysSessionAsync
operator|=
name|alwaysSessionAsync
expr_stmt|;
block|}
comment|/**      * @return Returns the optimizeAcknowledge.      */
specifier|public
name|boolean
name|isOptimizeAcknowledge
parameter_list|()
block|{
return|return
name|optimizeAcknowledge
return|;
block|}
comment|/**      * Enables an optimised acknowledgement mode where messages are acknowledged      * in batches rather than individually      *      * @param optimizeAcknowledge The optimizeAcknowledge to set.      */
specifier|public
name|void
name|setOptimizeAcknowledge
parameter_list|(
name|boolean
name|optimizeAcknowledge
parameter_list|)
block|{
name|this
operator|.
name|optimizeAcknowledge
operator|=
name|optimizeAcknowledge
expr_stmt|;
block|}
comment|/**      * The max time in milliseconds between optimized ack batches      * @param optimizeAcknowledgeTimeOut      */
specifier|public
name|void
name|setOptimizeAcknowledgeTimeOut
parameter_list|(
name|long
name|optimizeAcknowledgeTimeOut
parameter_list|)
block|{
name|this
operator|.
name|optimizeAcknowledgeTimeOut
operator|=
name|optimizeAcknowledgeTimeOut
expr_stmt|;
block|}
specifier|public
name|long
name|getOptimizeAcknowledgeTimeOut
parameter_list|()
block|{
return|return
name|optimizeAcknowledgeTimeOut
return|;
block|}
specifier|public
name|long
name|getWarnAboutUnstartedConnectionTimeout
parameter_list|()
block|{
return|return
name|warnAboutUnstartedConnectionTimeout
return|;
block|}
comment|/**      * Enables the timeout from a connection creation to when a warning is      * generated if the connection is not properly started via {@link #start()}      * and a message is received by a consumer. It is a very common gotcha to      * forget to<a      * href="http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html">start      * the connection</a> so this option makes the default case to create a      * warning if the user forgets. To disable the warning just set the value to<      * 0 (say -1).      */
specifier|public
name|void
name|setWarnAboutUnstartedConnectionTimeout
parameter_list|(
name|long
name|warnAboutUnstartedConnectionTimeout
parameter_list|)
block|{
name|this
operator|.
name|warnAboutUnstartedConnectionTimeout
operator|=
name|warnAboutUnstartedConnectionTimeout
expr_stmt|;
block|}
comment|/**      * @return the sendTimeout (in milliseconds)      */
specifier|public
name|int
name|getSendTimeout
parameter_list|()
block|{
return|return
name|sendTimeout
return|;
block|}
comment|/**      * @param sendTimeout the sendTimeout to set (in milliseconds)      */
specifier|public
name|void
name|setSendTimeout
parameter_list|(
name|int
name|sendTimeout
parameter_list|)
block|{
name|this
operator|.
name|sendTimeout
operator|=
name|sendTimeout
expr_stmt|;
block|}
comment|/**      * @return the sendAcksAsync      */
specifier|public
name|boolean
name|isSendAcksAsync
parameter_list|()
block|{
return|return
name|sendAcksAsync
return|;
block|}
comment|/**      * @param sendAcksAsync the sendAcksAsync to set      */
specifier|public
name|void
name|setSendAcksAsync
parameter_list|(
name|boolean
name|sendAcksAsync
parameter_list|)
block|{
name|this
operator|.
name|sendAcksAsync
operator|=
name|sendAcksAsync
expr_stmt|;
block|}
comment|/**      * Returns the time this connection was created      */
specifier|public
name|long
name|getTimeCreated
parameter_list|()
block|{
return|return
name|timeCreated
return|;
block|}
specifier|private
name|void
name|waitForBrokerInfo
parameter_list|()
throws|throws
name|JMSException
block|{
try|try
block|{
name|brokerInfoReceived
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
name|JMSExceptionSupport
operator|.
name|create
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|// Package protected so that it can be used in unit tests
specifier|public
name|Transport
name|getTransport
parameter_list|()
block|{
return|return
name|transport
return|;
block|}
specifier|public
name|void
name|addProducer
parameter_list|(
name|ProducerId
name|producerId
parameter_list|,
name|ActiveMQMessageProducer
name|producer
parameter_list|)
block|{
name|producers
operator|.
name|put
argument_list|(
name|producerId
argument_list|,
name|producer
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|removeProducer
parameter_list|(
name|ProducerId
name|producerId
parameter_list|)
block|{
name|producers
operator|.
name|remove
argument_list|(
name|producerId
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addDispatcher
parameter_list|(
name|ConsumerId
name|consumerId
parameter_list|,
name|ActiveMQDispatcher
name|dispatcher
parameter_list|)
block|{
name|dispatchers
operator|.
name|put
argument_list|(
name|consumerId
argument_list|,
name|dispatcher
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|removeDispatcher
parameter_list|(
name|ConsumerId
name|consumerId
parameter_list|)
block|{
name|dispatchers
operator|.
name|remove
argument_list|(
name|consumerId
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|hasDispatcher
parameter_list|(
name|ConsumerId
name|consumerId
parameter_list|)
block|{
return|return
name|dispatchers
operator|.
name|containsKey
argument_list|(
name|consumerId
argument_list|)
return|;
block|}
comment|/**      * @param o - the command to consume      */
annotation|@
name|Override
specifier|public
name|void
name|onCommand
parameter_list|(
specifier|final
name|Object
name|o
parameter_list|)
block|{
specifier|final
name|Command
name|command
init|=
operator|(
name|Command
operator|)
name|o
decl_stmt|;
if|if
condition|(
operator|!
name|closed
operator|.
name|get
argument_list|()
operator|&&
name|command
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|command
operator|.
name|visit
argument_list|(
operator|new
name|CommandVisitorAdapter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Response
name|processMessageDispatch
parameter_list|(
name|MessageDispatch
name|md
parameter_list|)
throws|throws
name|Exception
block|{
name|waitForTransportInterruptionProcessingToComplete
argument_list|()
expr_stmt|;
name|ActiveMQDispatcher
name|dispatcher
init|=
name|dispatchers
operator|.
name|get
argument_list|(
name|md
operator|.
name|getConsumerId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dispatcher
operator|!=
literal|null
condition|)
block|{
comment|// Copy in case a embedded broker is dispatching via
comment|// vm://
comment|// md.getMessage() == null to signal end of queue
comment|// browse.
name|Message
name|msg
init|=
name|md
operator|.
name|getMessage
argument_list|()
decl_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|null
condition|)
block|{
name|msg
operator|=
name|msg
operator|.
name|copy
argument_list|()
expr_stmt|;
name|msg
operator|.
name|setReadOnlyBody
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setReadOnlyProperties
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setRedeliveryCounter
argument_list|(
name|md
operator|.
name|getRedeliveryCounter
argument_list|()
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setConnection
argument_list|(
name|ActiveMQConnection
operator|.
name|this
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setMemoryUsage
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|md
operator|.
name|setMessage
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|dispatcher
operator|.
name|dispatch
argument_list|(
name|md
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} no dispatcher for {} in {}"
argument_list|,
name|this
argument_list|,
name|md
argument_list|,
name|dispatchers
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Response
name|processProducerAck
parameter_list|(
name|ProducerAck
name|pa
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|pa
operator|!=
literal|null
operator|&&
name|pa
operator|.
name|getProducerId
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ActiveMQMessageProducer
name|producer
init|=
name|producers
operator|.
name|get
argument_list|(
name|pa
operator|.
name|getProducerId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|producer
operator|!=
literal|null
condition|)
block|{
name|producer
operator|.
name|onProducerAck
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Response
name|processBrokerInfo
parameter_list|(
name|BrokerInfo
name|info
parameter_list|)
throws|throws
name|Exception
block|{
name|brokerInfo
operator|=
name|info
expr_stmt|;
name|brokerInfoReceived
operator|.
name|countDown
argument_list|()
expr_stmt|;
name|optimizeAcknowledge
operator|&=
operator|!
name|brokerInfo
operator|.
name|isFaultTolerantConfiguration
argument_list|()
expr_stmt|;
name|getBlobTransferPolicy
argument_list|()
operator|.
name|setBrokerUploadUrl
argument_list|(
name|info
operator|.
name|getBrokerUploadUrl
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Response
name|processConnectionError
parameter_list|(
specifier|final
name|ConnectionError
name|error
parameter_list|)
throws|throws
name|Exception
block|{
name|executor
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|onAsyncException
argument_list|(
name|error
operator|.
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Response
name|processControlCommand
parameter_list|(
name|ControlCommand
name|command
parameter_list|)
throws|throws
name|Exception
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Response
name|processConnectionControl
parameter_list|(
name|ConnectionControl
name|control
parameter_list|)
throws|throws
name|Exception
block|{
name|onConnectionControl
argument_list|(
operator|(
name|ConnectionControl
operator|)
name|command
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Response
name|processConsumerControl
parameter_list|(
name|ConsumerControl
name|control
parameter_list|)
throws|throws
name|Exception
block|{
name|onConsumerControl
argument_list|(
operator|(
name|ConsumerControl
operator|)
name|command
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Response
name|processWireFormat
parameter_list|(
name|WireFormatInfo
name|info
parameter_list|)
throws|throws
name|Exception
block|{
name|onWireFormatInfo
argument_list|(
operator|(
name|WireFormatInfo
operator|)
name|command
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|onClientInternalException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Iterator
argument_list|<
name|TransportListener
argument_list|>
name|iter
init|=
name|transportListeners
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TransportListener
name|listener
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|listener
operator|.
name|onCommand
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|onWireFormatInfo
parameter_list|(
name|WireFormatInfo
name|info
parameter_list|)
block|{
name|protocolVersion
operator|.
name|set
argument_list|(
name|info
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Handles async client internal exceptions.      * A client internal exception is usually one that has been thrown      * by a container runtime component during asynchronous processing of a      * message that does not affect the connection itself.      * This method notifies the<code>ClientInternalExceptionListener</code> by invoking      * its<code>onException</code> method, if one has been registered with this connection.      *      * @param error the exception that the problem      */
specifier|public
name|void
name|onClientInternalException
parameter_list|(
specifier|final
name|Throwable
name|error
parameter_list|)
block|{
if|if
condition|(
operator|!
name|closed
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|closing
operator|.
name|get
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|clientInternalExceptionListener
operator|!=
literal|null
condition|)
block|{
name|executor
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|ActiveMQConnection
operator|.
name|this
operator|.
name|clientInternalExceptionListener
operator|.
name|onException
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Async client internal exception occurred with no exception listener registered: {}"
argument_list|,
name|error
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Used for handling async exceptions      *      * @param error      */
specifier|public
name|void
name|onAsyncException
parameter_list|(
name|Throwable
name|error
parameter_list|)
block|{
if|if
condition|(
operator|!
name|closed
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|closing
operator|.
name|get
argument_list|()
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|exceptionListener
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|error
operator|instanceof
name|JMSException
operator|)
condition|)
block|{
name|error
operator|=
name|JMSExceptionSupport
operator|.
name|create
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
specifier|final
name|JMSException
name|e
init|=
operator|(
name|JMSException
operator|)
name|error
decl_stmt|;
name|executor
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|ActiveMQConnection
operator|.
name|this
operator|.
name|exceptionListener
operator|.
name|onException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Async exception with no exception listener: {}"
argument_list|,
name|error
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|onException
parameter_list|(
specifier|final
name|IOException
name|error
parameter_list|)
block|{
name|onAsyncException
argument_list|(
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|closed
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|closing
operator|.
name|get
argument_list|()
condition|)
block|{
name|executor
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|transportFailed
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|ServiceSupport
operator|.
name|dispose
argument_list|(
name|ActiveMQConnection
operator|.
name|this
operator|.
name|transport
argument_list|)
expr_stmt|;
name|brokerInfoReceived
operator|.
name|countDown
argument_list|()
expr_stmt|;
try|try
block|{
name|doCleanup
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|JMSException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception during connection cleanup, "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|TransportListener
argument_list|>
name|iter
init|=
name|transportListeners
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TransportListener
name|listener
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|listener
operator|.
name|onException
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|transportInterupted
parameter_list|()
block|{
name|transportInterruptionProcessingComplete
operator|.
name|set
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQSession
argument_list|>
name|i
init|=
name|this
operator|.
name|sessions
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQSession
name|s
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|s
operator|.
name|clearMessagesInProgress
argument_list|(
name|transportInterruptionProcessingComplete
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ActiveMQConnectionConsumer
name|connectionConsumer
range|:
name|this
operator|.
name|connectionConsumers
control|)
block|{
name|connectionConsumer
operator|.
name|clearMessagesInProgress
argument_list|(
name|transportInterruptionProcessingComplete
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|transportInterruptionProcessingComplete
operator|.
name|decrementAndGet
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"transport interrupted - processing required, dispatchers: "
operator|+
name|transportInterruptionProcessingComplete
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|signalInterruptionProcessingNeeded
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|TransportListener
argument_list|>
name|iter
init|=
name|transportListeners
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TransportListener
name|listener
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|listener
operator|.
name|transportInterupted
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|transportResumed
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|TransportListener
argument_list|>
name|iter
init|=
name|transportListeners
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TransportListener
name|listener
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|listener
operator|.
name|transportResumed
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Create the DestinationInfo object for the temporary destination.      *      * @param topic - if its true topic, else queue.      * @return DestinationInfo      * @throws JMSException      */
specifier|protected
name|ActiveMQTempDestination
name|createTempDestination
parameter_list|(
name|boolean
name|topic
parameter_list|)
throws|throws
name|JMSException
block|{
comment|// Check if Destination info is of temporary type.
name|ActiveMQTempDestination
name|dest
decl_stmt|;
if|if
condition|(
name|topic
condition|)
block|{
name|dest
operator|=
operator|new
name|ActiveMQTempTopic
argument_list|(
name|info
operator|.
name|getConnectionId
argument_list|()
argument_list|,
name|tempDestinationIdGenerator
operator|.
name|getNextSequenceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dest
operator|=
operator|new
name|ActiveMQTempQueue
argument_list|(
name|info
operator|.
name|getConnectionId
argument_list|()
argument_list|,
name|tempDestinationIdGenerator
operator|.
name|getNextSequenceId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|DestinationInfo
name|info
init|=
operator|new
name|DestinationInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|setConnectionId
argument_list|(
name|this
operator|.
name|info
operator|.
name|getConnectionId
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|setOperationType
argument_list|(
name|DestinationInfo
operator|.
name|ADD_OPERATION_TYPE
argument_list|)
expr_stmt|;
name|info
operator|.
name|setDestination
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|syncSendPacket
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dest
operator|.
name|setConnection
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|activeTempDestinations
operator|.
name|put
argument_list|(
name|dest
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
comment|/**      * @param destination      * @throws JMSException      */
specifier|public
name|void
name|deleteTempDestination
parameter_list|(
name|ActiveMQTempDestination
name|destination
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
for|for
control|(
name|ActiveMQSession
name|session
range|:
name|this
operator|.
name|sessions
control|)
block|{
if|if
condition|(
name|session
operator|.
name|isInUse
argument_list|(
name|destination
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|JMSException
argument_list|(
literal|"A consumer is consuming from the temporary destination"
argument_list|)
throw|;
block|}
block|}
name|activeTempDestinations
operator|.
name|remove
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|DestinationInfo
name|destInfo
init|=
operator|new
name|DestinationInfo
argument_list|()
decl_stmt|;
name|destInfo
operator|.
name|setConnectionId
argument_list|(
name|this
operator|.
name|info
operator|.
name|getConnectionId
argument_list|()
argument_list|)
expr_stmt|;
name|destInfo
operator|.
name|setOperationType
argument_list|(
name|DestinationInfo
operator|.
name|REMOVE_OPERATION_TYPE
argument_list|)
expr_stmt|;
name|destInfo
operator|.
name|setDestination
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|destInfo
operator|.
name|setTimeout
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|syncSendPacket
argument_list|(
name|destInfo
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|isDeleted
parameter_list|(
name|ActiveMQDestination
name|dest
parameter_list|)
block|{
comment|// If we are not watching the advisories.. then
comment|// we will assume that the temp destination does exist.
if|if
condition|(
name|advisoryConsumer
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
operator|!
name|activeTempDestinations
operator|.
name|containsValue
argument_list|(
name|dest
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isCopyMessageOnSend
parameter_list|()
block|{
return|return
name|copyMessageOnSend
return|;
block|}
specifier|public
name|LongSequenceGenerator
name|getLocalTransactionIdGenerator
parameter_list|()
block|{
return|return
name|localTransactionIdGenerator
return|;
block|}
specifier|public
name|boolean
name|isUseCompression
parameter_list|()
block|{
return|return
name|useCompression
return|;
block|}
comment|/**      * Enables the use of compression of the message bodies      */
specifier|public
name|void
name|setUseCompression
parameter_list|(
name|boolean
name|useCompression
parameter_list|)
block|{
name|this
operator|.
name|useCompression
operator|=
name|useCompression
expr_stmt|;
block|}
specifier|public
name|void
name|destroyDestination
parameter_list|(
name|ActiveMQDestination
name|destination
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
name|ensureConnectionInfoSent
argument_list|()
expr_stmt|;
name|DestinationInfo
name|info
init|=
operator|new
name|DestinationInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|setConnectionId
argument_list|(
name|this
operator|.
name|info
operator|.
name|getConnectionId
argument_list|()
argument_list|)
expr_stmt|;
name|info
operator|.
name|setOperationType
argument_list|(
name|DestinationInfo
operator|.
name|REMOVE_OPERATION_TYPE
argument_list|)
expr_stmt|;
name|info
operator|.
name|setDestination
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|info
operator|.
name|setTimeout
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|syncSendPacket
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|isDispatchAsync
parameter_list|()
block|{
return|return
name|dispatchAsync
return|;
block|}
comment|/**      * Enables or disables the default setting of whether or not consumers have      * their messages<a      * href="http://activemq.apache.org/consumer-dispatch-async.html">dispatched      * synchronously or asynchronously by the broker</a>. For non-durable      * topics for example we typically dispatch synchronously by default to      * minimize context switches which boost performance. However sometimes its      * better to go slower to ensure that a single blocked consumer socket does      * not block delivery to other consumers.      *      * @param asyncDispatch If true then consumers created on this connection      *                will default to having their messages dispatched      *                asynchronously. The default value is true.      */
specifier|public
name|void
name|setDispatchAsync
parameter_list|(
name|boolean
name|asyncDispatch
parameter_list|)
block|{
name|this
operator|.
name|dispatchAsync
operator|=
name|asyncDispatch
expr_stmt|;
block|}
specifier|public
name|boolean
name|isObjectMessageSerializationDefered
parameter_list|()
block|{
return|return
name|objectMessageSerializationDefered
return|;
block|}
comment|/**      * When an object is set on an ObjectMessage, the JMS spec requires the      * object to be serialized by that set method. Enabling this flag causes the      * object to not get serialized. The object may subsequently get serialized      * if the message needs to be sent over a socket or stored to disk.      */
specifier|public
name|void
name|setObjectMessageSerializationDefered
parameter_list|(
name|boolean
name|objectMessageSerializationDefered
parameter_list|)
block|{
name|this
operator|.
name|objectMessageSerializationDefered
operator|=
name|objectMessageSerializationDefered
expr_stmt|;
block|}
comment|/**      * Unsubscribes a durable subscription that has been created by a client.      *<P>      * This method deletes the state being maintained on behalf of the      * subscriber by its provider.      *<P>      * It is erroneous for a client to delete a durable subscription while there      * is an active<CODE>MessageConsumer</CODE> or      *<CODE>TopicSubscriber</CODE> for the subscription, or while a consumed      * message is part of a pending transaction or has not been acknowledged in      * the session.      *      * @param name the name used to identify this subscription      * @throws JMSException if the session fails to unsubscribe to the durable      *                 subscription due to some internal error.      * @throws InvalidDestinationException if an invalid subscription name is      *                 specified.      * @since 1.1      */
specifier|public
name|void
name|unsubscribe
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|InvalidDestinationException
throws|,
name|JMSException
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
name|RemoveSubscriptionInfo
name|rsi
init|=
operator|new
name|RemoveSubscriptionInfo
argument_list|()
decl_stmt|;
name|rsi
operator|.
name|setConnectionId
argument_list|(
name|getConnectionInfo
argument_list|()
operator|.
name|getConnectionId
argument_list|()
argument_list|)
expr_stmt|;
name|rsi
operator|.
name|setSubscriptionName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|rsi
operator|.
name|setClientId
argument_list|(
name|getConnectionInfo
argument_list|()
operator|.
name|getClientId
argument_list|()
argument_list|)
expr_stmt|;
name|syncSendPacket
argument_list|(
name|rsi
argument_list|)
expr_stmt|;
block|}
comment|/**      * Internal send method optimized: - It does not copy the message - It can      * only handle ActiveMQ messages. - You can specify if the send is async or      * sync - Does not allow you to send /w a transaction.      */
name|void
name|send
parameter_list|(
name|ActiveMQDestination
name|destination
parameter_list|,
name|ActiveMQMessage
name|msg
parameter_list|,
name|MessageId
name|messageId
parameter_list|,
name|int
name|deliveryMode
parameter_list|,
name|int
name|priority
parameter_list|,
name|long
name|timeToLive
parameter_list|,
name|boolean
name|async
parameter_list|)
throws|throws
name|JMSException
block|{
name|checkClosedOrFailed
argument_list|()
expr_stmt|;
if|if
condition|(
name|destination
operator|.
name|isTemporary
argument_list|()
operator|&&
name|isDeleted
argument_list|(
name|destination
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|JMSException
argument_list|(
literal|"Cannot publish to a deleted Destination: "
operator|+
name|destination
argument_list|)
throw|;
block|}
name|msg
operator|.
name|setJMSDestination
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setJMSDeliveryMode
argument_list|(
name|deliveryMode
argument_list|)
expr_stmt|;
name|long
name|expiration
init|=
literal|0L
decl_stmt|;
if|if
condition|(
operator|!
name|isDisableTimeStampsByDefault
argument_list|()
condition|)
block|{
name|long
name|timeStamp
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|msg
operator|.
name|setJMSTimestamp
argument_list|(
name|timeStamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeToLive
operator|>
literal|0
condition|)
block|{
name|expiration
operator|=
name|timeToLive
operator|+
name|timeStamp
expr_stmt|;
block|}
block|}
name|msg
operator|.
name|setJMSExpiration
argument_list|(
name|expiration
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setJMSPriority
argument_list|(
name|priority
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setJMSRedelivered
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|msg
operator|.
name|setMessageId
argument_list|(
name|messageId
argument_list|)
expr_stmt|;
name|msg
operator|.
name|onSend
argument_list|()
expr_stmt|;
name|msg
operator|.
name|setProducerId
argument_list|(
name|msg
operator|.
name|getMessageId
argument_list|()
operator|.
name|getProducerId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sending message: "
operator|+
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|async
condition|)
block|{
name|asyncSendPacket
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syncSendPacket
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|onConnectionControl
parameter_list|(
name|ConnectionControl
name|command
parameter_list|)
block|{
if|if
condition|(
name|command
operator|.
name|isFaultTolerant
argument_list|()
condition|)
block|{
name|this
operator|.
name|optimizeAcknowledge
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|ActiveMQSession
argument_list|>
name|i
init|=
name|this
operator|.
name|sessions
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ActiveMQSession
name|s
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|s
operator|.
name|setOptimizeAcknowledge
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|protected
name|void
name|onConsumerControl
parameter_list|(
name|ConsumerControl
name|command
parameter_list|)
block|{
if|if
condition|(
name|command
operator|.
name|isClose
argument_list|()
condition|)
block|{
for|for
control|(
name|ActiveMQSession
name|session
range|:
name|this
operator|.
name|sessions
control|)
block|{
name|session
operator|.
name|close
argument_list|(
name|command
operator|.
name|getConsumerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|ActiveMQSession
name|session
range|:
name|this
operator|.
name|sessions
control|)
block|{
name|session
operator|.
name|setPrefetchSize
argument_list|(
name|command
operator|.
name|getConsumerId
argument_list|()
argument_list|,
name|command
operator|.
name|getPrefetch
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ActiveMQConnectionConsumer
name|connectionConsumer
range|:
name|connectionConsumers
control|)
block|{
name|ConsumerInfo
name|consumerInfo
init|=
name|connectionConsumer
operator|.
name|getConsumerInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|consumerInfo
operator|.
name|getConsumerId
argument_list|()
operator|.
name|equals
argument_list|(
name|command
operator|.
name|getConsumerId
argument_list|()
argument_list|)
condition|)
block|{
name|consumerInfo
operator|.
name|setPrefetchSize
argument_list|(
name|command
operator|.
name|getPrefetch
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|protected
name|void
name|transportFailed
parameter_list|(
name|IOException
name|error
parameter_list|)
block|{
name|transportFailed
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstFailureError
operator|==
literal|null
condition|)
block|{
name|firstFailureError
operator|=
name|error
expr_stmt|;
block|}
block|}
comment|/**      * Should a JMS message be copied to a new JMS Message object as part of the      * send() method in JMS. This is enabled by default to be compliant with the      * JMS specification. You can disable it if you do not mutate JMS messages      * after they are sent for a performance boost      */
specifier|public
name|void
name|setCopyMessageOnSend
parameter_list|(
name|boolean
name|copyMessageOnSend
parameter_list|)
block|{
name|this
operator|.
name|copyMessageOnSend
operator|=
name|copyMessageOnSend
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ActiveMQConnection {id="
operator|+
name|info
operator|.
name|getConnectionId
argument_list|()
operator|+
literal|",clientId="
operator|+
name|info
operator|.
name|getClientId
argument_list|()
operator|+
literal|",started="
operator|+
name|started
operator|.
name|get
argument_list|()
operator|+
literal|"}"
return|;
block|}
specifier|protected
name|BlobTransferPolicy
name|createBlobTransferPolicy
parameter_list|()
block|{
return|return
operator|new
name|BlobTransferPolicy
argument_list|()
return|;
block|}
specifier|public
name|int
name|getProtocolVersion
parameter_list|()
block|{
return|return
name|protocolVersion
operator|.
name|get
argument_list|()
return|;
block|}
specifier|public
name|int
name|getProducerWindowSize
parameter_list|()
block|{
return|return
name|producerWindowSize
return|;
block|}
specifier|public
name|void
name|setProducerWindowSize
parameter_list|(
name|int
name|producerWindowSize
parameter_list|)
block|{
name|this
operator|.
name|producerWindowSize
operator|=
name|producerWindowSize
expr_stmt|;
block|}
specifier|public
name|void
name|setAuditDepth
parameter_list|(
name|int
name|auditDepth
parameter_list|)
block|{
name|connectionAudit
operator|.
name|setAuditDepth
argument_list|(
name|auditDepth
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setAuditMaximumProducerNumber
parameter_list|(
name|int
name|auditMaximumProducerNumber
parameter_list|)
block|{
name|connectionAudit
operator|.
name|setAuditMaximumProducerNumber
argument_list|(
name|auditMaximumProducerNumber
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|removeDispatcher
parameter_list|(
name|ActiveMQDispatcher
name|dispatcher
parameter_list|)
block|{
name|connectionAudit
operator|.
name|removeDispatcher
argument_list|(
name|dispatcher
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|boolean
name|isDuplicate
parameter_list|(
name|ActiveMQDispatcher
name|dispatcher
parameter_list|,
name|Message
name|message
parameter_list|)
block|{
return|return
name|checkForDuplicates
operator|&&
name|connectionAudit
operator|.
name|isDuplicate
argument_list|(
name|dispatcher
argument_list|,
name|message
argument_list|)
return|;
block|}
specifier|protected
name|void
name|rollbackDuplicate
parameter_list|(
name|ActiveMQDispatcher
name|dispatcher
parameter_list|,
name|Message
name|message
parameter_list|)
block|{
name|connectionAudit
operator|.
name|rollbackDuplicate
argument_list|(
name|dispatcher
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IOException
name|getFirstFailureError
parameter_list|()
block|{
return|return
name|firstFailureError
return|;
block|}
specifier|protected
name|void
name|waitForTransportInterruptionProcessingToComplete
parameter_list|()
throws|throws
name|InterruptedException
block|{
if|if
condition|(
operator|!
name|closed
operator|.
name|get
argument_list|()
operator|&&
operator|!
name|transportFailed
operator|.
name|get
argument_list|()
operator|&&
name|transportInterruptionProcessingComplete
operator|.
name|get
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"dispatch with outstanding dispatch interruption processing count "
operator|+
name|transportInterruptionProcessingComplete
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|signalInterruptionProcessingComplete
argument_list|()
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|transportInterruptionProcessingComplete
parameter_list|()
block|{
if|if
condition|(
name|transportInterruptionProcessingComplete
operator|.
name|decrementAndGet
argument_list|()
operator|==
literal|0
condition|)
block|{
name|signalInterruptionProcessingComplete
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|signalInterruptionProcessingComplete
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"transportInterruptionProcessingComplete: "
operator|+
name|transportInterruptionProcessingComplete
operator|.
name|get
argument_list|()
operator|+
literal|" for:"
operator|+
name|this
operator|.
name|getConnectionInfo
argument_list|()
operator|.
name|getConnectionId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FailoverTransport
name|failoverTransport
init|=
name|transport
operator|.
name|narrow
argument_list|(
name|FailoverTransport
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|failoverTransport
operator|!=
literal|null
condition|)
block|{
name|failoverTransport
operator|.
name|connectionInterruptProcessingComplete
argument_list|(
name|this
operator|.
name|getConnectionInfo
argument_list|()
operator|.
name|getConnectionId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"notified failover transport ("
operator|+
name|failoverTransport
operator|+
literal|") of interruption completion for: "
operator|+
name|this
operator|.
name|getConnectionInfo
argument_list|()
operator|.
name|getConnectionId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|transportInterruptionProcessingComplete
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|signalInterruptionProcessingNeeded
parameter_list|()
block|{
name|FailoverTransport
name|failoverTransport
init|=
name|transport
operator|.
name|narrow
argument_list|(
name|FailoverTransport
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|failoverTransport
operator|!=
literal|null
condition|)
block|{
name|failoverTransport
operator|.
name|getStateTracker
argument_list|()
operator|.
name|transportInterrupted
argument_list|(
name|this
operator|.
name|getConnectionInfo
argument_list|()
operator|.
name|getConnectionId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"notified failover transport ("
operator|+
name|failoverTransport
operator|+
literal|") of pending interruption processing for: "
operator|+
name|this
operator|.
name|getConnectionInfo
argument_list|()
operator|.
name|getConnectionId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * specify the amount of time in milliseconds that a consumer with a transaction pending recovery      * will wait to receive re dispatched messages.      * default value is 0 so there is no wait by default.      */
specifier|public
name|void
name|setConsumerFailoverRedeliveryWaitPeriod
parameter_list|(
name|long
name|consumerFailoverRedeliveryWaitPeriod
parameter_list|)
block|{
name|this
operator|.
name|consumerFailoverRedeliveryWaitPeriod
operator|=
name|consumerFailoverRedeliveryWaitPeriod
expr_stmt|;
block|}
specifier|public
name|long
name|getConsumerFailoverRedeliveryWaitPeriod
parameter_list|()
block|{
return|return
name|consumerFailoverRedeliveryWaitPeriod
return|;
block|}
specifier|protected
name|Scheduler
name|getScheduler
parameter_list|()
throws|throws
name|JMSException
block|{
name|Scheduler
name|result
init|=
name|scheduler
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isClosing
argument_list|()
operator|||
name|isClosed
argument_list|()
condition|)
block|{
comment|// without lock contention report the closing state
throw|throw
operator|new
name|ConnectionClosedException
argument_list|()
throw|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|result
operator|=
name|scheduler
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|checkClosed
argument_list|()
expr_stmt|;
try|try
block|{
name|result
operator|=
operator|new
name|Scheduler
argument_list|(
literal|"ActiveMQConnection["
operator|+
name|info
operator|.
name|getConnectionId
argument_list|()
operator|.
name|getValue
argument_list|()
operator|+
literal|"] Scheduler"
argument_list|)
expr_stmt|;
name|result
operator|.
name|start
argument_list|()
expr_stmt|;
name|scheduler
operator|=
name|result
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|JMSExceptionSupport
operator|.
name|create
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
specifier|protected
name|ThreadPoolExecutor
name|getExecutor
parameter_list|()
block|{
return|return
name|this
operator|.
name|executor
return|;
block|}
specifier|protected
name|CopyOnWriteArrayList
argument_list|<
name|ActiveMQSession
argument_list|>
name|getSessions
parameter_list|()
block|{
return|return
name|sessions
return|;
block|}
comment|/**      * @return the checkForDuplicates      */
specifier|public
name|boolean
name|isCheckForDuplicates
parameter_list|()
block|{
return|return
name|this
operator|.
name|checkForDuplicates
return|;
block|}
comment|/**      * @param checkForDuplicates the checkForDuplicates to set      */
specifier|public
name|void
name|setCheckForDuplicates
parameter_list|(
name|boolean
name|checkForDuplicates
parameter_list|)
block|{
name|this
operator|.
name|checkForDuplicates
operator|=
name|checkForDuplicates
expr_stmt|;
block|}
specifier|public
name|boolean
name|isTransactedIndividualAck
parameter_list|()
block|{
return|return
name|transactedIndividualAck
return|;
block|}
specifier|public
name|void
name|setTransactedIndividualAck
parameter_list|(
name|boolean
name|transactedIndividualAck
parameter_list|)
block|{
name|this
operator|.
name|transactedIndividualAck
operator|=
name|transactedIndividualAck
expr_stmt|;
block|}
specifier|public
name|boolean
name|isNonBlockingRedelivery
parameter_list|()
block|{
return|return
name|nonBlockingRedelivery
return|;
block|}
specifier|public
name|void
name|setNonBlockingRedelivery
parameter_list|(
name|boolean
name|nonBlockingRedelivery
parameter_list|)
block|{
name|this
operator|.
name|nonBlockingRedelivery
operator|=
name|nonBlockingRedelivery
expr_stmt|;
block|}
specifier|public
name|boolean
name|isRmIdFromConnectionId
parameter_list|()
block|{
return|return
name|rmIdFromConnectionId
return|;
block|}
specifier|public
name|void
name|setRmIdFromConnectionId
parameter_list|(
name|boolean
name|rmIdFromConnectionId
parameter_list|)
block|{
name|this
operator|.
name|rmIdFromConnectionId
operator|=
name|rmIdFromConnectionId
expr_stmt|;
block|}
comment|/**      * Removes any TempDestinations that this connection has cached, ignoring      * any exceptions generated because the destination is in use as they should      * not be removed.      * Used from a pooled connection, b/c it will not be explicitly closed.      */
specifier|public
name|void
name|cleanUpTempDestinations
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|activeTempDestinations
operator|==
literal|null
operator|||
name|this
operator|.
name|activeTempDestinations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|Iterator
argument_list|<
name|ConcurrentMap
operator|.
name|Entry
argument_list|<
name|ActiveMQTempDestination
argument_list|,
name|ActiveMQTempDestination
argument_list|>
argument_list|>
name|entries
init|=
name|this
operator|.
name|activeTempDestinations
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|entries
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ConcurrentMap
operator|.
name|Entry
argument_list|<
name|ActiveMQTempDestination
argument_list|,
name|ActiveMQTempDestination
argument_list|>
name|entry
init|=
name|entries
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Only delete this temp destination if it was created from this connection. The connection used
comment|// for the advisory consumer may also have a reference to this temp destination.
name|ActiveMQTempDestination
name|dest
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|thisConnectionId
init|=
operator|(
name|info
operator|.
name|getConnectionId
argument_list|()
operator|==
literal|null
operator|)
condition|?
literal|""
else|:
name|info
operator|.
name|getConnectionId
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|dest
operator|.
name|getConnectionId
argument_list|()
operator|!=
literal|null
operator|&&
name|dest
operator|.
name|getConnectionId
argument_list|()
operator|.
name|equals
argument_list|(
name|thisConnectionId
argument_list|)
condition|)
block|{
name|this
operator|.
name|deleteTempDestination
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
comment|// the temp dest is in use so it can not be deleted.
comment|// it is ok to leave it to connection tear down phase
block|}
block|}
block|}
comment|/**      * Sets the Connection wide RedeliveryPolicyMap for handling messages that are being rolled back.      * @param redeliveryPolicyMap the redeliveryPolicyMap to set      */
specifier|public
name|void
name|setRedeliveryPolicyMap
parameter_list|(
name|RedeliveryPolicyMap
name|redeliveryPolicyMap
parameter_list|)
block|{
name|this
operator|.
name|redeliveryPolicyMap
operator|=
name|redeliveryPolicyMap
expr_stmt|;
block|}
comment|/**      * Gets the Connection's configured RedeliveryPolicyMap which will be used by all the      * Consumers when dealing with transaction messages that have been rolled back.      *      * @return the redeliveryPolicyMap      */
specifier|public
name|RedeliveryPolicyMap
name|getRedeliveryPolicyMap
parameter_list|()
block|{
return|return
name|redeliveryPolicyMap
return|;
block|}
specifier|public
name|int
name|getMaxThreadPoolSize
parameter_list|()
block|{
return|return
name|maxThreadPoolSize
return|;
block|}
specifier|public
name|void
name|setMaxThreadPoolSize
parameter_list|(
name|int
name|maxThreadPoolSize
parameter_list|)
block|{
name|this
operator|.
name|maxThreadPoolSize
operator|=
name|maxThreadPoolSize
expr_stmt|;
block|}
comment|/**      * Enable enforcement of QueueConnection semantics.      *      * @return this object, useful for chaining      */
name|ActiveMQConnection
name|enforceQueueOnlyConnection
parameter_list|()
block|{
name|this
operator|.
name|queueOnlyConnection
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|RejectedExecutionHandler
name|getRejectedTaskHandler
parameter_list|()
block|{
return|return
name|rejectedTaskHandler
return|;
block|}
specifier|public
name|void
name|setRejectedTaskHandler
parameter_list|(
name|RejectedExecutionHandler
name|rejectedTaskHandler
parameter_list|)
block|{
name|this
operator|.
name|rejectedTaskHandler
operator|=
name|rejectedTaskHandler
expr_stmt|;
block|}
comment|/**      * Gets the configured time interval that is used to force all MessageConsumers that have optimizedAcknowledge enabled      * to send an ack for any outstanding Message Acks.  By default this value is set to zero meaning that the consumers      * will not do any background Message acknowledgment.      *      * @return the scheduledOptimizedAckInterval      */
specifier|public
name|long
name|getOptimizedAckScheduledAckInterval
parameter_list|()
block|{
return|return
name|optimizedAckScheduledAckInterval
return|;
block|}
comment|/**      * Sets the amount of time between scheduled sends of any outstanding Message Acks for consumers that      * have been configured with optimizeAcknowledge enabled.      *      * @param optimizedAckScheduledAckInterval the scheduledOptimizedAckInterval to set      */
specifier|public
name|void
name|setOptimizedAckScheduledAckInterval
parameter_list|(
name|long
name|optimizedAckScheduledAckInterval
parameter_list|)
block|{
name|this
operator|.
name|optimizedAckScheduledAckInterval
operator|=
name|optimizedAckScheduledAckInterval
expr_stmt|;
block|}
comment|/**      * @return true if MessageConsumer instance will check for expired messages before dispatch.      */
specifier|public
name|boolean
name|isConsumerExpiryCheckEnabled
parameter_list|()
block|{
return|return
name|consumerExpiryCheckEnabled
return|;
block|}
comment|/**      * Controls whether message expiration checking is done in each MessageConsumer      * prior to dispatching a message.  Disabling this check can lead to consumption      * of expired messages.      *      * @param consumerExpiryCheckEnabled      *        controls whether expiration checking is done prior to dispatch.      */
specifier|public
name|void
name|setConsumerExpiryCheckEnabled
parameter_list|(
name|boolean
name|consumerExpiryCheckEnabled
parameter_list|)
block|{
name|this
operator|.
name|consumerExpiryCheckEnabled
operator|=
name|consumerExpiryCheckEnabled
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getTrustedPackages
parameter_list|()
block|{
return|return
name|trustedPackages
return|;
block|}
specifier|public
name|void
name|setTrustedPackages
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|trustedPackages
parameter_list|)
block|{
name|this
operator|.
name|trustedPackages
operator|=
name|trustedPackages
expr_stmt|;
block|}
specifier|public
name|boolean
name|isTrustAllPackages
parameter_list|()
block|{
return|return
name|trustAllPackages
return|;
block|}
specifier|public
name|void
name|setTrustAllPackages
parameter_list|(
name|boolean
name|trustAllPackages
parameter_list|)
block|{
name|this
operator|.
name|trustAllPackages
operator|=
name|trustAllPackages
expr_stmt|;
block|}
specifier|public
name|int
name|getConnectResponseTimeout
parameter_list|()
block|{
return|return
name|connectResponseTimeout
return|;
block|}
specifier|public
name|void
name|setConnectResponseTimeout
parameter_list|(
name|int
name|connectResponseTimeout
parameter_list|)
block|{
name|this
operator|.
name|connectResponseTimeout
operator|=
name|connectResponseTimeout
expr_stmt|;
block|}
block|}
end_class

end_unit

