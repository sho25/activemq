begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  Licensed to the Apache Software Foundation (ASF) under one or more  *  contributor license agreements.  See the NOTICE file distributed with  *  this work for additional information regarding copyright ownership.  *  The ASF licenses this file to You under the Apache License, Version 2.0  *  (the "License"); you may not use this file except in compliance with  *  the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  */
end_comment

begin_comment
comment|/*  * This package is based on the work done by Timothy Gerard Endres  * (time@ice.com) to whom the Ant project is very grateful for his great code.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|console
operator|.
name|command
operator|.
name|store
operator|.
name|tar
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_comment
comment|/**  * The TarOutputStream writes a UNIX tar archive as an OutputStream.  * Methods are provided to put entries, and then write their contents  * by writing to this stream using write().  *  */
end_comment

begin_class
specifier|public
class|class
name|TarOutputStream
extends|extends
name|FilterOutputStream
block|{
comment|/** Fail if a long file name is required in the archive. */
specifier|public
specifier|static
specifier|final
name|int
name|LONGFILE_ERROR
init|=
literal|0
decl_stmt|;
comment|/** Long paths will be truncated in the archive. */
specifier|public
specifier|static
specifier|final
name|int
name|LONGFILE_TRUNCATE
init|=
literal|1
decl_stmt|;
comment|/** GNU tar extensions are used to store long file names in the archive. */
specifier|public
specifier|static
specifier|final
name|int
name|LONGFILE_GNU
init|=
literal|2
decl_stmt|;
comment|// CheckStyle:VisibilityModifier OFF - bc
specifier|protected
name|boolean
name|debug
decl_stmt|;
specifier|protected
name|long
name|currSize
decl_stmt|;
specifier|protected
name|String
name|currName
decl_stmt|;
specifier|protected
name|long
name|currBytes
decl_stmt|;
specifier|protected
name|byte
index|[]
name|oneBuf
decl_stmt|;
specifier|protected
name|byte
index|[]
name|recordBuf
decl_stmt|;
specifier|protected
name|int
name|assemLen
decl_stmt|;
specifier|protected
name|byte
index|[]
name|assemBuf
decl_stmt|;
specifier|protected
name|TarBuffer
name|buffer
decl_stmt|;
specifier|protected
name|int
name|longFileMode
init|=
name|LONGFILE_ERROR
decl_stmt|;
comment|// CheckStyle:VisibilityModifier ON
specifier|private
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
comment|/**      * Constructor for TarInputStream.      * @param os the output stream to use      */
specifier|public
name|TarOutputStream
parameter_list|(
name|OutputStream
name|os
parameter_list|)
block|{
name|this
argument_list|(
name|os
argument_list|,
name|TarBuffer
operator|.
name|DEFAULT_BLKSIZE
argument_list|,
name|TarBuffer
operator|.
name|DEFAULT_RCDSIZE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor for TarInputStream.      * @param os the output stream to use      * @param blockSize the block size to use      */
specifier|public
name|TarOutputStream
parameter_list|(
name|OutputStream
name|os
parameter_list|,
name|int
name|blockSize
parameter_list|)
block|{
name|this
argument_list|(
name|os
argument_list|,
name|blockSize
argument_list|,
name|TarBuffer
operator|.
name|DEFAULT_RCDSIZE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor for TarInputStream.      * @param os the output stream to use      * @param blockSize the block size to use      * @param recordSize the record size to use      */
specifier|public
name|TarOutputStream
parameter_list|(
name|OutputStream
name|os
parameter_list|,
name|int
name|blockSize
parameter_list|,
name|int
name|recordSize
parameter_list|)
block|{
name|super
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|this
operator|.
name|buffer
operator|=
operator|new
name|TarBuffer
argument_list|(
name|os
argument_list|,
name|blockSize
argument_list|,
name|recordSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|debug
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|assemLen
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|assemBuf
operator|=
operator|new
name|byte
index|[
name|recordSize
index|]
expr_stmt|;
name|this
operator|.
name|recordBuf
operator|=
operator|new
name|byte
index|[
name|recordSize
index|]
expr_stmt|;
name|this
operator|.
name|oneBuf
operator|=
operator|new
name|byte
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/**      * Set the long file mode.      * This can be LONGFILE_ERROR(0), LONGFILE_TRUNCATE(1) or LONGFILE_GNU(2).      * This specifies the treatment of long file names (names>= TarConstants.NAMELEN).      * Default is LONGFILE_ERROR.      * @param longFileMode the mode to use      */
specifier|public
name|void
name|setLongFileMode
parameter_list|(
name|int
name|longFileMode
parameter_list|)
block|{
name|this
operator|.
name|longFileMode
operator|=
name|longFileMode
expr_stmt|;
block|}
comment|/**      * Sets the debugging flag.      *      * @param debugF True to turn on debugging.      */
specifier|public
name|void
name|setDebug
parameter_list|(
name|boolean
name|debugF
parameter_list|)
block|{
name|this
operator|.
name|debug
operator|=
name|debugF
expr_stmt|;
block|}
comment|/**      * Sets the debugging flag in this stream's TarBuffer.      *      * @param debug True to turn on debugging.      */
specifier|public
name|void
name|setBufferDebug
parameter_list|(
name|boolean
name|debug
parameter_list|)
block|{
name|buffer
operator|.
name|setDebug
argument_list|(
name|debug
argument_list|)
expr_stmt|;
block|}
comment|/**      * Ends the TAR archive without closing the underlying OutputStream.      * The result is that the two EOF records of nulls are written.      * @throws IOException on error      */
specifier|public
name|void
name|finish
parameter_list|()
throws|throws
name|IOException
block|{
comment|// See Bugzilla 28776 for a discussion on this
comment|// http://issues.apache.org/bugzilla/show_bug.cgi?id=28776
name|writeEOFRecord
argument_list|()
expr_stmt|;
name|writeEOFRecord
argument_list|()
expr_stmt|;
name|buffer
operator|.
name|flushBlock
argument_list|()
expr_stmt|;
block|}
comment|/**      * Ends the TAR archive and closes the underlying OutputStream.      * This means that finish() is called followed by calling the      * TarBuffer's close().      * @throws IOException on error      */
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
name|finish
argument_list|()
expr_stmt|;
name|buffer
operator|.
name|close
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**      * Get the record size being used by this stream's TarBuffer.      *      * @return The TarBuffer record size.      */
specifier|public
name|int
name|getRecordSize
parameter_list|()
block|{
return|return
name|buffer
operator|.
name|getRecordSize
argument_list|()
return|;
block|}
comment|/**      * Put an entry on the output stream. This writes the entry's      * header record and positions the output stream for writing      * the contents of the entry. Once this method is called, the      * stream is ready for calls to write() to write the entry's      * contents. Once the contents are written, closeEntry()      *<B>MUST</B> be called to ensure that all buffered data      * is completely written to the output stream.      *      * @param entry The TarEntry to be written to the archive.      * @throws IOException on error      */
specifier|public
name|void
name|putNextEntry
parameter_list|(
name|TarEntry
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|entry
operator|.
name|getName
argument_list|()
operator|.
name|length
argument_list|()
operator|>=
name|TarConstants
operator|.
name|NAMELEN
condition|)
block|{
if|if
condition|(
name|longFileMode
operator|==
name|LONGFILE_GNU
condition|)
block|{
comment|// create a TarEntry for the LongLink, the contents
comment|// of which are the entry's name
name|TarEntry
name|longLinkEntry
init|=
operator|new
name|TarEntry
argument_list|(
name|TarConstants
operator|.
name|GNU_LONGLINK
argument_list|,
name|TarConstants
operator|.
name|LF_GNUTYPE_LONGNAME
argument_list|)
decl_stmt|;
name|longLinkEntry
operator|.
name|setSize
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|putNextEntry
argument_list|(
name|longLinkEntry
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|closeEntry
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|longFileMode
operator|!=
name|LONGFILE_TRUNCATE
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"file name '"
operator|+
name|entry
operator|.
name|getName
argument_list|()
operator|+
literal|"' is too long (> "
operator|+
name|TarConstants
operator|.
name|NAMELEN
operator|+
literal|" bytes)"
argument_list|)
throw|;
block|}
block|}
name|entry
operator|.
name|writeEntryHeader
argument_list|(
name|recordBuf
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|writeRecord
argument_list|(
name|recordBuf
argument_list|)
expr_stmt|;
name|currBytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|entry
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|currSize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|currSize
operator|=
name|entry
operator|.
name|getSize
argument_list|()
expr_stmt|;
block|}
name|currName
operator|=
name|entry
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
comment|/**      * Close an entry. This method MUST be called for all file      * entries that contain data. The reason is that we must      * buffer data written to the stream in order to satisfy      * the buffer's record based writes. Thus, there may be      * data fragments still being assembled that must be written      * to the output stream before this entry is closed and the      * next entry written.      * @throws IOException on error      */
specifier|public
name|void
name|closeEntry
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|assemLen
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|assemLen
init|;
name|i
operator|<
name|assemBuf
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|assemBuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|buffer
operator|.
name|writeRecord
argument_list|(
name|assemBuf
argument_list|)
expr_stmt|;
name|currBytes
operator|+=
name|assemLen
expr_stmt|;
name|assemLen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|currBytes
operator|<
name|currSize
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"entry '"
operator|+
name|currName
operator|+
literal|"' closed at '"
operator|+
name|currBytes
operator|+
literal|"' before the '"
operator|+
name|currSize
operator|+
literal|"' bytes specified in the header were written"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Writes a byte to the current tar archive entry.      *      * This method simply calls read( byte[], int, int ).      *      * @param b The byte written.      * @throws IOException on error      */
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|oneBuf
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
name|write
argument_list|(
name|oneBuf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes bytes to the current tar archive entry.      *      * This method simply calls write( byte[], int, int ).      *      * @param wBuf The buffer to write to the archive.      * @throws IOException on error      */
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|wBuf
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
name|wBuf
argument_list|,
literal|0
argument_list|,
name|wBuf
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes bytes to the current tar archive entry. This method      * is aware of the current entry and will throw an exception if      * you attempt to write bytes past the length specified for the      * current entry. The method is also (painfully) aware of the      * record buffering required by TarBuffer, and manages buffers      * that are not a multiple of recordsize in length, including      * assembling records from small buffers.      *      * @param wBuf The buffer to write to the archive.      * @param wOffset The offset in the buffer from which to get bytes.      * @param numToWrite The number of bytes to write.      * @throws IOException on error      */
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|wBuf
parameter_list|,
name|int
name|wOffset
parameter_list|,
name|int
name|numToWrite
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|currBytes
operator|+
name|numToWrite
operator|)
operator|>
name|currSize
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"request to write '"
operator|+
name|numToWrite
operator|+
literal|"' bytes exceeds size in header of '"
operator|+
name|currSize
operator|+
literal|"' bytes for entry '"
operator|+
name|currName
operator|+
literal|"'"
argument_list|)
throw|;
comment|//
comment|// We have to deal with assembly!!!
comment|// The programmer can be writing little 32 byte chunks for all
comment|// we know, and we must assemble complete records for writing.
comment|// REVIEW Maybe this should be in TarBuffer? Could that help to
comment|// eliminate some of the buffer copying.
comment|//
block|}
if|if
condition|(
name|assemLen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|assemLen
operator|+
name|numToWrite
operator|)
operator|>=
name|recordBuf
operator|.
name|length
condition|)
block|{
name|int
name|aLen
init|=
name|recordBuf
operator|.
name|length
operator|-
name|assemLen
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|assemBuf
argument_list|,
literal|0
argument_list|,
name|recordBuf
argument_list|,
literal|0
argument_list|,
name|assemLen
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|wBuf
argument_list|,
name|wOffset
argument_list|,
name|recordBuf
argument_list|,
name|assemLen
argument_list|,
name|aLen
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|writeRecord
argument_list|(
name|recordBuf
argument_list|)
expr_stmt|;
name|currBytes
operator|+=
name|recordBuf
operator|.
name|length
expr_stmt|;
name|wOffset
operator|+=
name|aLen
expr_stmt|;
name|numToWrite
operator|-=
name|aLen
expr_stmt|;
name|assemLen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|wBuf
argument_list|,
name|wOffset
argument_list|,
name|assemBuf
argument_list|,
name|assemLen
argument_list|,
name|numToWrite
argument_list|)
expr_stmt|;
name|wOffset
operator|+=
name|numToWrite
expr_stmt|;
name|assemLen
operator|+=
name|numToWrite
expr_stmt|;
name|numToWrite
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|//
comment|// When we get here we have EITHER:
comment|// o An empty "assemble" buffer.
comment|// o No bytes to write (numToWrite == 0)
comment|//
while|while
condition|(
name|numToWrite
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|numToWrite
operator|<
name|recordBuf
operator|.
name|length
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|wBuf
argument_list|,
name|wOffset
argument_list|,
name|assemBuf
argument_list|,
name|assemLen
argument_list|,
name|numToWrite
argument_list|)
expr_stmt|;
name|assemLen
operator|+=
name|numToWrite
expr_stmt|;
break|break;
block|}
name|buffer
operator|.
name|writeRecord
argument_list|(
name|wBuf
argument_list|,
name|wOffset
argument_list|)
expr_stmt|;
name|int
name|num
init|=
name|recordBuf
operator|.
name|length
decl_stmt|;
name|currBytes
operator|+=
name|num
expr_stmt|;
name|numToWrite
operator|-=
name|num
expr_stmt|;
name|wOffset
operator|+=
name|num
expr_stmt|;
block|}
block|}
comment|/**      * Write an EOF (end of archive) record to the tar archive.      * An EOF record consists of a record of all zeros.      */
specifier|private
name|void
name|writeEOFRecord
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|recordBuf
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|recordBuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|buffer
operator|.
name|writeRecord
argument_list|(
name|recordBuf
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

