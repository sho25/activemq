begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|kahadb
operator|.
name|page
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kahadb
operator|.
name|page
operator|.
name|PageFile
operator|.
name|PageWrite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kahadb
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * The class used to read/update a PageFile object.  Using a transaction allows you to  * do multiple update operations in a single unit of work.  */
end_comment

begin_class
specifier|public
class|class
name|Transaction
implements|implements
name|Iterable
argument_list|<
name|Page
argument_list|>
block|{
specifier|private
name|RandomAccessFile
name|tmpFile
decl_stmt|;
specifier|private
name|File
name|txFile
decl_stmt|;
specifier|private
name|int
name|nextLocation
init|=
literal|0
decl_stmt|;
comment|/**      * The PageOverflowIOException occurs when a page write is requested      * and it's data is larger than what would fit into a single page.      */
specifier|public
class|class
name|PageOverflowIOException
extends|extends
name|IOException
block|{
specifier|public
name|PageOverflowIOException
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * The InvalidPageIOException is thrown if try to load/store a a page      * with an invalid page id.      */
specifier|public
class|class
name|InvalidPageIOException
extends|extends
name|IOException
block|{
specifier|private
specifier|final
name|long
name|page
decl_stmt|;
specifier|public
name|InvalidPageIOException
parameter_list|(
name|String
name|message
parameter_list|,
name|long
name|page
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|this
operator|.
name|page
operator|=
name|page
expr_stmt|;
block|}
specifier|public
name|long
name|getPage
parameter_list|()
block|{
return|return
name|page
return|;
block|}
block|}
comment|/**      * This closure interface is intended for the end user implement callbacks for the Transaction.exectue() method.      *       * @param<T> The type of exceptions that operation will throw.      */
specifier|public
interface|interface
name|Closure
parameter_list|<
name|T
extends|extends
name|Throwable
parameter_list|>
block|{
specifier|public
name|void
name|execute
parameter_list|(
name|Transaction
name|tx
parameter_list|)
throws|throws
name|T
function_decl|;
block|}
comment|/**      * This closure interface is intended for the end user implement callbacks for the Transaction.exectue() method.      *       * @param<R> The type of result that the closure produces.      * @param<T> The type of exceptions that operation will throw.      */
specifier|public
interface|interface
name|CallableClosure
parameter_list|<
name|R
parameter_list|,
name|T
extends|extends
name|Throwable
parameter_list|>
block|{
specifier|public
name|R
name|execute
parameter_list|(
name|Transaction
name|tx
parameter_list|)
throws|throws
name|T
function_decl|;
block|}
comment|// The page file that this Transaction operates against.
specifier|private
specifier|final
name|PageFile
name|pageFile
decl_stmt|;
comment|// If this transaction is updating stuff.. this is the tx of
specifier|private
name|long
name|writeTransactionId
init|=
operator|-
literal|1
decl_stmt|;
comment|// List of pages that this transaction has modified.
specifier|private
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|PageWrite
argument_list|>
name|writes
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|PageWrite
argument_list|>
argument_list|()
decl_stmt|;
comment|// List of pages allocated in this transaction
specifier|private
specifier|final
name|SequenceSet
name|allocateList
init|=
operator|new
name|SequenceSet
argument_list|()
decl_stmt|;
comment|// List of pages freed in this transaction
specifier|private
specifier|final
name|SequenceSet
name|freeList
init|=
operator|new
name|SequenceSet
argument_list|()
decl_stmt|;
specifier|private
name|long
name|maxTransactionSize
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"maxKahaDBTxSize"
argument_list|,
literal|""
operator|+
literal|10485760
argument_list|)
argument_list|)
decl_stmt|;
specifier|private
name|long
name|size
init|=
literal|0
decl_stmt|;
name|Transaction
parameter_list|(
name|PageFile
name|pageFile
parameter_list|)
block|{
name|this
operator|.
name|pageFile
operator|=
name|pageFile
expr_stmt|;
block|}
comment|/**      * @return the page file that created this Transaction      */
specifier|public
name|PageFile
name|getPageFile
parameter_list|()
block|{
return|return
name|this
operator|.
name|pageFile
return|;
block|}
comment|/**       * Allocates a free page that you can write data to.      *       * @return a newly allocated page.        * @throws IOException      *         If an disk error occurred.      * @throws IllegalStateException      *         if the PageFile is not loaded      */
specifier|public
parameter_list|<
name|T
parameter_list|>
name|Page
argument_list|<
name|T
argument_list|>
name|allocate
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|allocate
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/**       * Allocates a block of free pages that you can write data to.      *       * @param count the number of sequential pages to allocate      * @return the first page of the sequential set.       * @throws IOException      *         If an disk error occurred.      * @throws IllegalStateException      *         if the PageFile is not loaded      */
specifier|public
parameter_list|<
name|T
parameter_list|>
name|Page
argument_list|<
name|T
argument_list|>
name|allocate
parameter_list|(
name|int
name|count
parameter_list|)
throws|throws
name|IOException
block|{
comment|// TODO: we need to track allocated pages so that they can be returned if the
comment|// transaction gets rolled back.
name|Page
argument_list|<
name|T
argument_list|>
name|rc
init|=
name|pageFile
operator|.
name|allocate
argument_list|(
name|count
argument_list|)
decl_stmt|;
name|allocateList
operator|.
name|add
argument_list|(
operator|new
name|Sequence
argument_list|(
name|rc
operator|.
name|getPageId
argument_list|()
argument_list|,
name|rc
operator|.
name|getPageId
argument_list|()
operator|+
name|count
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
comment|/**      * Frees up a previously allocated page so that it can be re-allocated again.      *       * @param pageId the page to free up      * @throws IOException      *         If an disk error occurred.      * @throws IllegalStateException      *         if the PageFile is not loaded      */
specifier|public
name|void
name|free
parameter_list|(
name|long
name|pageId
parameter_list|)
throws|throws
name|IOException
block|{
name|free
argument_list|(
name|load
argument_list|(
name|pageId
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Frees up a previously allocated sequence of pages so that it can be re-allocated again.      *       * @param pageId the initial page of the sequence that will be getting freed      * @param count the number of pages in the sequence      *       * @throws IOException      *         If an disk error occurred.      * @throws IllegalStateException      *         if the PageFile is not loaded      */
specifier|public
name|void
name|free
parameter_list|(
name|long
name|pageId
parameter_list|,
name|int
name|count
parameter_list|)
throws|throws
name|IOException
block|{
name|free
argument_list|(
name|load
argument_list|(
name|pageId
argument_list|,
literal|null
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
comment|/**      * Frees up a previously allocated sequence of pages so that it can be re-allocated again.      *       * @param page the initial page of the sequence that will be getting freed      * @param count the number of pages in the sequence      *       * @throws IOException      *         If an disk error occurred.      * @throws IllegalStateException      *         if the PageFile is not loaded      */
specifier|public
parameter_list|<
name|T
parameter_list|>
name|void
name|free
parameter_list|(
name|Page
argument_list|<
name|T
argument_list|>
name|page
parameter_list|,
name|int
name|count
parameter_list|)
throws|throws
name|IOException
block|{
name|pageFile
operator|.
name|assertLoaded
argument_list|()
expr_stmt|;
name|long
name|offsetPage
init|=
name|page
operator|.
name|getPageId
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|page
operator|==
literal|null
condition|)
block|{
name|page
operator|=
name|load
argument_list|(
name|offsetPage
operator|+
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|page
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**      * Frees up a previously allocated page so that it can be re-allocated again.      *       * @param page the page to free up      * @throws IOException      *         If an disk error occurred.      * @throws IllegalStateException      *         if the PageFile is not loaded      */
specifier|public
parameter_list|<
name|T
parameter_list|>
name|void
name|free
parameter_list|(
name|Page
argument_list|<
name|T
argument_list|>
name|page
parameter_list|)
throws|throws
name|IOException
block|{
name|pageFile
operator|.
name|assertLoaded
argument_list|()
expr_stmt|;
comment|// We may need loop to free up a page chain.
while|while
condition|(
name|page
operator|!=
literal|null
condition|)
block|{
comment|// Is it already free??
if|if
condition|(
name|page
operator|.
name|getType
argument_list|()
operator|==
name|Page
operator|.
name|PAGE_FREE_TYPE
condition|)
block|{
return|return;
block|}
name|Page
argument_list|<
name|T
argument_list|>
name|next
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|page
operator|.
name|getType
argument_list|()
operator|==
name|Page
operator|.
name|PAGE_PART_TYPE
condition|)
block|{
name|next
operator|=
name|load
argument_list|(
name|page
operator|.
name|getNext
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|page
operator|.
name|makeFree
argument_list|(
name|getWriteTransactionId
argument_list|()
argument_list|)
expr_stmt|;
comment|// ensure free page is visible while write is pending
name|pageFile
operator|.
name|addToCache
argument_list|(
name|page
operator|.
name|copy
argument_list|()
argument_list|)
expr_stmt|;
name|DataByteArrayOutputStream
name|out
init|=
operator|new
name|DataByteArrayOutputStream
argument_list|(
name|pageFile
operator|.
name|getPageSize
argument_list|()
argument_list|)
decl_stmt|;
name|page
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|page
argument_list|,
name|out
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
name|freeList
operator|.
name|add
argument_list|(
name|page
operator|.
name|getPageId
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/**      *       * @param page      *        the page to write. The Page object must be fully populated with a valid pageId, type, and data.      * @param marshaller      *        the marshaler to use to load the data portion of the Page, may be null if you do not wish to write the data.      * @param overflow      *        If true, then if the page data marshalls to a bigger size than can fit in one page, then additional       *        overflow pages are automatically allocated and chained to this page to store all the data.  If false,      *        and the overflow condition would occur, then the PageOverflowIOException is thrown.       * @throws IOException      *         If an disk error occurred.      * @throws PageOverflowIOException      *         If the page data marshalls to size larger than maximum page size and overflow was false.      * @throws IllegalStateException      *         if the PageFile is not loaded      */
specifier|public
parameter_list|<
name|T
parameter_list|>
name|void
name|store
parameter_list|(
name|Page
argument_list|<
name|T
argument_list|>
name|page
parameter_list|,
name|Marshaller
argument_list|<
name|T
argument_list|>
name|marshaller
parameter_list|,
specifier|final
name|boolean
name|overflow
parameter_list|)
throws|throws
name|IOException
block|{
name|DataByteArrayOutputStream
name|out
init|=
operator|(
name|DataByteArrayOutputStream
operator|)
name|openOutputStream
argument_list|(
name|page
argument_list|,
name|overflow
argument_list|)
decl_stmt|;
if|if
condition|(
name|marshaller
operator|!=
literal|null
condition|)
block|{
name|marshaller
operator|.
name|writePayload
argument_list|(
name|page
operator|.
name|get
argument_list|()
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**      * @throws IOException      */
specifier|public
name|OutputStream
name|openOutputStream
parameter_list|(
name|Page
name|page
parameter_list|,
specifier|final
name|boolean
name|overflow
parameter_list|)
throws|throws
name|IOException
block|{
name|pageFile
operator|.
name|assertLoaded
argument_list|()
expr_stmt|;
comment|// Copy to protect against the end user changing
comment|// the page instance while we are doing a write.
specifier|final
name|Page
name|copy
init|=
name|page
operator|.
name|copy
argument_list|()
decl_stmt|;
name|pageFile
operator|.
name|addToCache
argument_list|(
name|copy
argument_list|)
expr_stmt|;
comment|//
comment|// To support writing VERY large data, we override the output stream so
comment|// that we
comment|// we do the page writes incrementally while the data is being
comment|// marshalled.
name|DataByteArrayOutputStream
name|out
init|=
operator|new
name|DataByteArrayOutputStream
argument_list|(
name|pageFile
operator|.
name|getPageSize
argument_list|()
operator|*
literal|2
argument_list|)
block|{
name|Page
name|current
init|=
name|copy
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|protected
name|void
name|onWrite
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Are we at an overflow condition?
specifier|final
name|int
name|pageSize
init|=
name|pageFile
operator|.
name|getPageSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
name|pageSize
condition|)
block|{
comment|// If overflow is allowed
if|if
condition|(
name|overflow
condition|)
block|{
name|Page
name|next
decl_stmt|;
if|if
condition|(
name|current
operator|.
name|getType
argument_list|()
operator|==
name|Page
operator|.
name|PAGE_PART_TYPE
condition|)
block|{
name|next
operator|=
name|load
argument_list|(
name|current
operator|.
name|getNext
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|allocate
argument_list|()
expr_stmt|;
block|}
name|next
operator|.
name|txId
operator|=
name|current
operator|.
name|txId
expr_stmt|;
comment|// Write the page header
name|int
name|oldPos
init|=
name|pos
decl_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|current
operator|.
name|makePagePart
argument_list|(
name|next
operator|.
name|getPageId
argument_list|()
argument_list|,
name|getWriteTransactionId
argument_list|()
argument_list|)
expr_stmt|;
name|current
operator|.
name|write
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Do the page write..
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
name|pageSize
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|pageSize
argument_list|)
expr_stmt|;
name|Transaction
operator|.
name|this
operator|.
name|write
argument_list|(
name|current
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|// Reset for the next page chunk
name|pos
operator|=
literal|0
expr_stmt|;
comment|// The page header marshalled after the data is written.
name|skip
argument_list|(
name|Page
operator|.
name|PAGE_HEADER_SIZE
argument_list|)
expr_stmt|;
comment|// Move the overflow data after the header.
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
name|pageSize
argument_list|,
name|buf
argument_list|,
name|pos
argument_list|,
name|oldPos
operator|-
name|pageSize
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|oldPos
operator|-
name|pageSize
expr_stmt|;
name|current
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|PageOverflowIOException
argument_list|(
literal|"Page overflow."
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// We need to free up the rest of the page chain..
if|if
condition|(
name|current
operator|.
name|getType
argument_list|()
operator|==
name|Page
operator|.
name|PAGE_PART_TYPE
condition|)
block|{
name|free
argument_list|(
name|current
operator|.
name|getNext
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|current
operator|.
name|makePageEnd
argument_list|(
name|pos
argument_list|,
name|getWriteTransactionId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Write the header..
name|pos
operator|=
literal|0
expr_stmt|;
name|current
operator|.
name|write
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|Transaction
operator|.
name|this
operator|.
name|write
argument_list|(
name|current
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|// The page header marshaled after the data is written.
name|out
operator|.
name|skip
argument_list|(
name|Page
operator|.
name|PAGE_HEADER_SIZE
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
comment|/**      * Loads a page from disk.      *       * @param pageId       *        the id of the page to load      * @param marshaller      *        the marshaler to use to load the data portion of the Page, may be null if you do not wish to load the data.      * @return The page with the given id      * @throws IOException      *         If an disk error occurred.      * @throws IllegalStateException      *         if the PageFile is not loaded      */
specifier|public
parameter_list|<
name|T
parameter_list|>
name|Page
argument_list|<
name|T
argument_list|>
name|load
parameter_list|(
name|long
name|pageId
parameter_list|,
name|Marshaller
argument_list|<
name|T
argument_list|>
name|marshaller
parameter_list|)
throws|throws
name|IOException
block|{
name|pageFile
operator|.
name|assertLoaded
argument_list|()
expr_stmt|;
name|Page
argument_list|<
name|T
argument_list|>
name|page
init|=
operator|new
name|Page
argument_list|<
name|T
argument_list|>
argument_list|(
name|pageId
argument_list|)
decl_stmt|;
name|load
argument_list|(
name|page
argument_list|,
name|marshaller
argument_list|)
expr_stmt|;
return|return
name|page
return|;
block|}
comment|/**      * Loads a page from disk.      *       * @param page - The pageId field must be properly set       * @param marshaller      *        the marshaler to use to load the data portion of the Page, may be null if you do not wish to load the data.      * @throws IOException      *         If an disk error occurred.      * @throws InvalidPageIOException      *         If the page is is not valid.            * @throws IllegalStateException      *         if the PageFile is not loaded      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|void
name|load
parameter_list|(
name|Page
argument_list|<
name|T
argument_list|>
name|page
parameter_list|,
name|Marshaller
argument_list|<
name|T
argument_list|>
name|marshaller
parameter_list|)
throws|throws
name|IOException
block|{
name|pageFile
operator|.
name|assertLoaded
argument_list|()
expr_stmt|;
comment|// Can't load invalid offsets...
name|long
name|pageId
init|=
name|page
operator|.
name|getPageId
argument_list|()
decl_stmt|;
if|if
condition|(
name|pageId
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|InvalidPageIOException
argument_list|(
literal|"Page id is not valid"
argument_list|,
name|pageId
argument_list|)
throw|;
block|}
comment|// It might be a page this transaction has modified...
name|PageWrite
name|update
init|=
name|writes
operator|.
name|get
argument_list|(
name|pageId
argument_list|)
decl_stmt|;
if|if
condition|(
name|update
operator|!=
literal|null
condition|)
block|{
name|page
operator|.
name|copy
argument_list|(
name|update
operator|.
name|getPage
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// We may be able to get it from the cache...
name|Page
argument_list|<
name|T
argument_list|>
name|t
init|=
name|pageFile
operator|.
name|getFromCache
argument_list|(
name|pageId
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|page
operator|.
name|copy
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|marshaller
operator|!=
literal|null
condition|)
block|{
comment|// Full page read..
name|InputStream
name|is
init|=
name|openInputStream
argument_list|(
name|page
argument_list|)
decl_stmt|;
name|DataInputStream
name|dataIn
init|=
operator|new
name|DataInputStream
argument_list|(
name|is
argument_list|)
decl_stmt|;
name|page
operator|.
name|set
argument_list|(
name|marshaller
operator|.
name|readPayload
argument_list|(
name|dataIn
argument_list|)
argument_list|)
expr_stmt|;
name|is
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Page header read.
name|DataByteArrayInputStream
name|in
init|=
operator|new
name|DataByteArrayInputStream
argument_list|(
operator|new
name|byte
index|[
name|Page
operator|.
name|PAGE_HEADER_SIZE
index|]
argument_list|)
decl_stmt|;
name|pageFile
operator|.
name|readPage
argument_list|(
name|pageId
argument_list|,
name|in
operator|.
name|getRawData
argument_list|()
argument_list|)
expr_stmt|;
name|page
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|page
operator|.
name|set
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// Cache it.
if|if
condition|(
name|marshaller
operator|!=
literal|null
condition|)
block|{
name|pageFile
operator|.
name|addToCache
argument_list|(
name|page
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @see org.apache.kahadb.page.Transaction#load(org.apache.kahadb.page.Page,      *      org.apache.kahadb.util.Marshaller)      */
specifier|public
name|InputStream
name|openInputStream
parameter_list|(
specifier|final
name|Page
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|InputStream
argument_list|()
block|{
specifier|private
name|ByteSequence
name|chunk
init|=
operator|new
name|ByteSequence
argument_list|(
operator|new
name|byte
index|[
name|pageFile
operator|.
name|getPageSize
argument_list|()
index|]
argument_list|)
decl_stmt|;
specifier|private
name|Page
name|page
init|=
name|readPage
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|private
name|int
name|pageCount
init|=
literal|1
decl_stmt|;
specifier|private
name|Page
name|markPage
decl_stmt|;
specifier|private
name|ByteSequence
name|markChunk
decl_stmt|;
specifier|private
name|Page
name|readPage
parameter_list|(
name|Page
name|page
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Read the page data
name|pageFile
operator|.
name|readPage
argument_list|(
name|page
operator|.
name|getPageId
argument_list|()
argument_list|,
name|chunk
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
name|chunk
operator|.
name|setOffset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|chunk
operator|.
name|setLength
argument_list|(
name|pageFile
operator|.
name|getPageSize
argument_list|()
argument_list|)
expr_stmt|;
name|DataByteArrayInputStream
name|in
init|=
operator|new
name|DataByteArrayInputStream
argument_list|(
name|chunk
argument_list|)
decl_stmt|;
name|page
operator|.
name|read
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|chunk
operator|.
name|setOffset
argument_list|(
name|Page
operator|.
name|PAGE_HEADER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|.
name|getType
argument_list|()
operator|==
name|Page
operator|.
name|PAGE_END_TYPE
condition|)
block|{
name|chunk
operator|.
name|setLength
argument_list|(
call|(
name|int
call|)
argument_list|(
name|page
operator|.
name|getNext
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|page
operator|.
name|getType
argument_list|()
operator|==
name|Page
operator|.
name|PAGE_FREE_TYPE
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"Chunk stream does not exist, page: "
operator|+
name|page
operator|.
name|getPageId
argument_list|()
operator|+
literal|" is marked free"
argument_list|)
throw|;
block|}
return|return
name|page
return|;
block|}
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|atEOF
argument_list|()
condition|)
block|{
return|return
name|chunk
operator|.
name|data
index|[
name|chunk
operator|.
name|offset
operator|++
index|]
operator|&
literal|0xff
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
specifier|private
name|boolean
name|atEOF
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|chunk
operator|.
name|offset
operator|<
name|chunk
operator|.
name|length
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|page
operator|.
name|getType
argument_list|()
operator|==
name|Page
operator|.
name|PAGE_END_TYPE
condition|)
block|{
return|return
literal|true
return|;
block|}
name|fill
argument_list|()
expr_stmt|;
return|return
name|chunk
operator|.
name|offset
operator|>=
name|chunk
operator|.
name|length
return|;
block|}
specifier|private
name|void
name|fill
parameter_list|()
throws|throws
name|IOException
block|{
name|page
operator|=
name|readPage
argument_list|(
operator|new
name|Page
argument_list|(
name|page
operator|.
name|getNext
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pageCount
operator|++
expr_stmt|;
block|}
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|read
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
return|;
block|}
specifier|public
name|int
name|read
parameter_list|(
name|byte
name|b
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|atEOF
argument_list|()
condition|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|atEOF
argument_list|()
operator|&&
name|rc
operator|<
name|len
condition|)
block|{
name|len
operator|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|chunk
operator|.
name|length
operator|-
name|chunk
operator|.
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|chunk
operator|.
name|data
argument_list|,
name|chunk
operator|.
name|offset
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|chunk
operator|.
name|offset
operator|+=
name|len
expr_stmt|;
block|}
name|rc
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|atEOF
argument_list|()
condition|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|atEOF
argument_list|()
operator|&&
name|rc
operator|<
name|len
condition|)
block|{
name|len
operator|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|chunk
operator|.
name|length
operator|-
name|chunk
operator|.
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|chunk
operator|.
name|offset
operator|+=
name|len
expr_stmt|;
block|}
name|rc
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
specifier|public
name|int
name|available
parameter_list|()
block|{
return|return
name|chunk
operator|.
name|length
operator|-
name|chunk
operator|.
name|offset
return|;
block|}
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|void
name|mark
parameter_list|(
name|int
name|markpos
parameter_list|)
block|{
name|markPage
operator|=
name|page
expr_stmt|;
name|byte
name|data
index|[]
init|=
operator|new
name|byte
index|[
name|pageFile
operator|.
name|getPageSize
argument_list|()
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|chunk
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|pageFile
operator|.
name|getPageSize
argument_list|()
argument_list|)
expr_stmt|;
name|markChunk
operator|=
operator|new
name|ByteSequence
argument_list|(
name|data
argument_list|,
name|chunk
operator|.
name|getOffset
argument_list|()
argument_list|,
name|chunk
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|page
operator|=
name|markPage
expr_stmt|;
name|chunk
operator|=
name|markChunk
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**      * Allows you to iterate through all active Pages in this object.  Pages with type Page.FREE_TYPE are       * not included in this iteration.       *       * Pages removed with Iterator.remove() will not actually get removed until the transaction commits.      *       * @throws IllegalStateException      *         if the PageFile is not loaded      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Iterator
argument_list|<
name|Page
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|(
name|Iterator
argument_list|<
name|Page
argument_list|>
operator|)
name|iterator
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/**      * Allows you to iterate through all active Pages in this object.  You can optionally include free pages in the pages      * iterated.      *       * @param includeFreePages - if true, free pages are included in the iteration      * @throws IllegalStateException      *         if the PageFile is not loaded      */
specifier|public
name|Iterator
argument_list|<
name|Page
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|boolean
name|includeFreePages
parameter_list|)
block|{
name|pageFile
operator|.
name|assertLoaded
argument_list|()
expr_stmt|;
return|return
operator|new
name|Iterator
argument_list|<
name|Page
argument_list|>
argument_list|()
block|{
name|long
name|nextId
decl_stmt|;
name|Page
name|nextPage
decl_stmt|;
name|Page
name|lastPage
decl_stmt|;
specifier|private
name|void
name|findNextPage
parameter_list|()
block|{
if|if
condition|(
operator|!
name|pageFile
operator|.
name|isLoaded
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot iterate the pages when the page file is not loaded"
argument_list|)
throw|;
block|}
if|if
condition|(
name|nextPage
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
try|try
block|{
while|while
condition|(
name|nextId
operator|<
name|pageFile
operator|.
name|getPageCount
argument_list|()
condition|)
block|{
name|Page
name|page
init|=
name|load
argument_list|(
name|nextId
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|includeFreePages
operator|||
name|page
operator|.
name|getType
argument_list|()
operator|!=
name|Page
operator|.
name|PAGE_FREE_TYPE
condition|)
block|{
name|nextPage
operator|=
name|page
expr_stmt|;
return|return;
block|}
else|else
block|{
name|nextId
operator|++
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{                 }
block|}
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
name|findNextPage
argument_list|()
expr_stmt|;
return|return
name|nextPage
operator|!=
literal|null
return|;
block|}
specifier|public
name|Page
name|next
parameter_list|()
block|{
name|findNextPage
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextPage
operator|!=
literal|null
condition|)
block|{
name|lastPage
operator|=
name|nextPage
expr_stmt|;
name|nextPage
operator|=
literal|null
expr_stmt|;
name|nextId
operator|++
expr_stmt|;
return|return
name|lastPage
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|lastPage
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
try|try
block|{
name|free
argument_list|(
name|lastPage
argument_list|)
expr_stmt|;
name|lastPage
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
comment|///////////////////////////////////////////////////////////////////
comment|// Commit / Rollback related methods..
comment|///////////////////////////////////////////////////////////////////
comment|/**      * Commits the transaction to the PageFile as a single 'Unit of Work'. Either all page updates associated      * with the transaction are written to disk or none will.      */
specifier|public
name|void
name|commit
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|writeTransactionId
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Actually do the page writes...
name|pageFile
operator|.
name|write
argument_list|(
name|writes
operator|.
name|entrySet
argument_list|()
argument_list|)
expr_stmt|;
comment|// Release the pages that were freed up in the transaction..
name|freePages
argument_list|(
name|freeList
argument_list|)
expr_stmt|;
name|freeList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|allocateList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|writes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|writeTransactionId
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|tmpFile
operator|!=
literal|null
condition|)
block|{
name|tmpFile
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getTempFile
argument_list|()
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't delete temporary KahaDB transaction file:"
operator|+
name|getTempFile
argument_list|()
argument_list|)
throw|;
block|}
name|tmpFile
operator|=
literal|null
expr_stmt|;
name|txFile
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|size
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Rolls back the transaction.      */
specifier|public
name|void
name|rollback
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|writeTransactionId
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// Release the pages that were allocated in the transaction...
name|freePages
argument_list|(
name|allocateList
argument_list|)
expr_stmt|;
name|freeList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|allocateList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|writes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|writeTransactionId
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|tmpFile
operator|!=
literal|null
condition|)
block|{
name|tmpFile
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|getTempFile
argument_list|()
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't delete temporary KahaDB transaction file:"
operator|+
name|getTempFile
argument_list|()
argument_list|)
throw|;
block|}
name|tmpFile
operator|=
literal|null
expr_stmt|;
name|txFile
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|size
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
name|long
name|getWriteTransactionId
parameter_list|()
block|{
if|if
condition|(
name|writeTransactionId
operator|==
operator|-
literal|1
condition|)
block|{
name|writeTransactionId
operator|=
name|pageFile
operator|.
name|getNextWriteTransactionId
argument_list|()
expr_stmt|;
block|}
return|return
name|writeTransactionId
return|;
block|}
specifier|protected
name|File
name|getTempFile
parameter_list|()
block|{
if|if
condition|(
name|txFile
operator|==
literal|null
condition|)
block|{
name|txFile
operator|=
operator|new
name|File
argument_list|(
name|getPageFile
argument_list|()
operator|.
name|getDirectory
argument_list|()
argument_list|,
name|IOHelper
operator|.
name|toFileSystemSafeName
argument_list|(
literal|"tx-"
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|getWriteTransactionId
argument_list|()
argument_list|)
operator|+
literal|"-"
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
operator|+
literal|".tmp"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|txFile
return|;
block|}
comment|/**      * Queues up a page write that should get done when commit() gets called.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|void
name|write
parameter_list|(
specifier|final
name|Page
name|page
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|Long
name|key
init|=
name|page
operator|.
name|getPageId
argument_list|()
decl_stmt|;
name|size
operator|+=
name|data
operator|.
name|length
expr_stmt|;
name|PageWrite
name|write
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|maxTransactionSize
condition|)
block|{
if|if
condition|(
name|tmpFile
operator|==
literal|null
condition|)
block|{
name|tmpFile
operator|=
operator|new
name|RandomAccessFile
argument_list|(
name|getTempFile
argument_list|()
argument_list|,
literal|"rw"
argument_list|)
expr_stmt|;
block|}
name|int
name|location
init|=
name|nextLocation
decl_stmt|;
name|tmpFile
operator|.
name|seek
argument_list|(
name|nextLocation
argument_list|)
expr_stmt|;
name|tmpFile
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|nextLocation
operator|=
name|location
operator|+
name|data
operator|.
name|length
expr_stmt|;
name|write
operator|=
operator|new
name|PageWrite
argument_list|(
name|page
argument_list|,
name|location
argument_list|,
name|data
operator|.
name|length
argument_list|,
name|getTempFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write
operator|=
operator|new
name|PageWrite
argument_list|(
name|page
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|writes
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|write
argument_list|)
expr_stmt|;
block|}
comment|/**      * @param list      * @throws RuntimeException      */
specifier|private
name|void
name|freePages
parameter_list|(
name|SequenceSet
name|list
parameter_list|)
throws|throws
name|RuntimeException
block|{
name|Sequence
name|seq
init|=
name|list
operator|.
name|getHead
argument_list|()
decl_stmt|;
while|while
condition|(
name|seq
operator|!=
literal|null
condition|)
block|{
name|seq
operator|.
name|each
argument_list|(
operator|new
name|Sequence
operator|.
name|Closure
argument_list|<
name|RuntimeException
argument_list|>
argument_list|()
block|{
specifier|public
name|void
name|execute
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|pageFile
operator|.
name|freePage
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|seq
operator|=
name|seq
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * @return true if there are no uncommitted page file updates associated with this transaction.      */
specifier|public
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
name|writeTransactionId
operator|==
operator|-
literal|1
return|;
block|}
comment|///////////////////////////////////////////////////////////////////
comment|// Transaction closure helpers...
comment|///////////////////////////////////////////////////////////////////
comment|/**      * Executes a closure and if it does not throw any exceptions, then it commits the transaction.      * If the closure throws an Exception, then the transaction is rolled back.      *       * @param<T>      * @param closure - the work to get exectued.      * @throws T if the closure throws it      * @throws IOException If the commit fails.      */
specifier|public
parameter_list|<
name|T
extends|extends
name|Throwable
parameter_list|>
name|void
name|execute
parameter_list|(
name|Closure
argument_list|<
name|T
argument_list|>
name|closure
parameter_list|)
throws|throws
name|T
throws|,
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|closure
operator|.
name|execute
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|commit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rollback
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Executes a closure and if it does not throw any exceptions, then it commits the transaction.      * If the closure throws an Exception, then the transaction is rolled back.      *       * @param<T>      * @param closure - the work to get exectued.      * @throws T if the closure throws it      * @throws IOException If the commit fails.      */
specifier|public
parameter_list|<
name|R
parameter_list|,
name|T
extends|extends
name|Throwable
parameter_list|>
name|R
name|execute
parameter_list|(
name|CallableClosure
argument_list|<
name|R
argument_list|,
name|T
argument_list|>
name|closure
parameter_list|)
throws|throws
name|T
throws|,
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|R
name|rc
init|=
name|closure
operator|.
name|execute
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|rc
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|commit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|rollback
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

