begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|///Copyright 2003-2005 Arthur van Hoff, Rick Blair
end_comment

begin_comment
comment|//Licensed under Apache License version 2.0
end_comment

begin_comment
comment|//Original license LGPL
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|jmdns
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|DatagramPacket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MulticastSocket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|logging
operator|.
name|Logger
import|;
end_import

begin_comment
comment|// REMIND: multiple IP addresses
end_comment

begin_comment
comment|/**  * mDNS implementation in Java.  *  * @version %I%, %G%  * @author	Arthur van Hoff, Rick Blair, Jeff Sonstein,  * Werner Randelshofer, Pierre Frisch, Scott Lewis  */
end_comment

begin_class
specifier|public
class|class
name|JmDNS
block|{
specifier|private
specifier|static
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|JmDNS
operator|.
name|class
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * The version of JmDNS.      */
specifier|public
specifier|static
name|String
name|VERSION
init|=
literal|"2.0"
decl_stmt|;
comment|/**      * This is the multicast group, we are listening to for multicast DNS messages.      */
specifier|private
name|InetAddress
name|group
decl_stmt|;
comment|/**      * This is our multicast socket.      */
specifier|private
name|MulticastSocket
name|socket
decl_stmt|;
comment|/**      * Used to fix live lock problem on unregester.      */
specifier|protected
name|boolean
name|closed
init|=
literal|false
decl_stmt|;
comment|/**      * Holds instances of JmDNS.DNSListener.      * Must by a synchronized collection, because it is updated from      * concurrent threads.      */
specifier|private
name|List
name|listeners
decl_stmt|;
comment|/**      * Holds instances of ServiceListener's.      * Keys are Strings holding a fully qualified service type.      * Values are LinkedList's of ServiceListener's.      */
specifier|private
name|Map
name|serviceListeners
decl_stmt|;
comment|/**      * Holds instances of ServiceTypeListener's.      */
specifier|private
name|List
name|typeListeners
decl_stmt|;
comment|/**      * Cache for DNSEntry's.      */
specifier|private
name|DNSCache
name|cache
decl_stmt|;
comment|/**      * This hashtable holds the services that have been registered.      * Keys are instances of String which hold an all lower-case version of the      * fully qualified service name.      * Values are instances of ServiceInfo.      */
name|Map
name|services
decl_stmt|;
comment|/**      * This hashtable holds the service types that have been registered or      * that have been received in an incoming datagram.      * Keys are instances of String which hold an all lower-case version of the      * fully qualified service type.      * Values hold the fully qualified service type.      */
name|Map
name|serviceTypes
decl_stmt|;
comment|/**      * This is the shutdown hook, we registered with the java runtime.      */
specifier|private
name|Thread
name|shutdown
decl_stmt|;
comment|/**      * Handle on the local host      */
name|HostInfo
name|localHost
decl_stmt|;
specifier|private
name|Thread
name|incomingListener
init|=
literal|null
decl_stmt|;
comment|/**      * Throttle count.      * This is used to count the overall number of probes sent by JmDNS.      * When the last throttle increment happened .      */
specifier|private
name|int
name|throttle
decl_stmt|;
comment|/**      * Last throttle increment.      */
specifier|private
name|long
name|lastThrottleIncrement
decl_stmt|;
comment|/**      * The timer is used to dispatch all outgoing messages of JmDNS.      * It is also used to dispatch maintenance tasks for the DNS cache.      */
specifier|private
name|Timer
name|timer
decl_stmt|;
comment|/**      * The source for random values.      * This is used to introduce random delays in responses. This reduces the      * potential for collisions on the network.      */
specifier|private
specifier|final
specifier|static
name|Random
name|random
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
comment|/**      * This lock is used to coordinate processing of incoming and outgoing      * messages. This is needed, because the Rendezvous Conformance Test      * does not forgive race conditions.      */
specifier|private
name|Object
name|ioLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|/**      * If an incoming package which needs an answer is truncated, we store it      * here. We add more incoming DNSRecords to it, until the JmDNS.Responder      * timer picks it up.      * Remind: This does not work well with multiple planned answers for packages      * that came in from different clients.      */
specifier|private
name|DNSIncoming
name|plannedAnswer
decl_stmt|;
comment|// State machine
comment|/**      * The state of JmDNS.      *<p/>      * For proper handling of concurrency, this variable must be      * changed only using methods advanceState(), revertState() and cancel().      */
specifier|private
name|DNSState
name|state
init|=
name|DNSState
operator|.
name|PROBING_1
decl_stmt|;
comment|/**      * Timer task associated to the host name.      * This is used to prevent from having multiple tasks associated to the host      * name at the same time.      */
name|TimerTask
name|task
decl_stmt|;
comment|/**      * This hashtable is used to maintain a list of service types being collected      * by this JmDNS instance.      * The key of the hashtable is a service type name, the value is an instance      * of JmDNS.ServiceCollector.      *      * @see #list      */
specifier|private
name|HashMap
name|serviceCollectors
init|=
operator|new
name|HashMap
argument_list|()
decl_stmt|;
comment|/**      * Create an instance of JmDNS.      */
specifier|public
name|JmDNS
parameter_list|()
throws|throws
name|IOException
block|{
name|logger
operator|.
name|finer
argument_list|(
literal|"JmDNS instance created"
argument_list|)
expr_stmt|;
try|try
block|{
name|InetAddress
name|addr
init|=
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
decl_stmt|;
name|init
argument_list|(
name|addr
operator|.
name|isLoopbackAddress
argument_list|()
condition|?
literal|null
else|:
name|addr
argument_list|,
name|addr
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
comment|// [PJYF Oct 14 2004] Why do we disallow the loopback address?
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|init
argument_list|(
literal|null
argument_list|,
literal|"computer"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Create an instance of JmDNS and bind it to a      * specific network interface given its IP-address.      */
specifier|public
name|JmDNS
parameter_list|(
name|InetAddress
name|addr
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|init
argument_list|(
name|addr
argument_list|,
name|addr
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|init
argument_list|(
literal|null
argument_list|,
literal|"computer"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Initialize everything.      *      * @param address The interface to which JmDNS binds to.      * @param name    The host name of the interface.      */
specifier|private
name|void
name|init
parameter_list|(
name|InetAddress
name|address
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
comment|// A host name with "." is illegal. so strip off everything and append .local.
name|int
name|idx
init|=
name|name
operator|.
name|indexOf
argument_list|(
literal|"."
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
name|name
operator|+=
literal|".local."
expr_stmt|;
comment|// localHost to IP address binding
name|localHost
operator|=
operator|new
name|HostInfo
argument_list|(
name|address
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|new
name|DNSCache
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|listeners
operator|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|ArrayList
argument_list|()
argument_list|)
expr_stmt|;
name|serviceListeners
operator|=
operator|new
name|HashMap
argument_list|()
expr_stmt|;
name|typeListeners
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
name|services
operator|=
operator|new
name|Hashtable
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|serviceTypes
operator|=
operator|new
name|Hashtable
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|timer
operator|=
operator|new
name|Timer
argument_list|(
literal|"JmDNS.Timer"
argument_list|)
expr_stmt|;
operator|new
name|RecordReaper
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
name|shutdown
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|Shutdown
argument_list|()
argument_list|,
literal|"JmDNS.Shutdown"
argument_list|)
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|addShutdownHook
argument_list|(
name|shutdown
argument_list|)
expr_stmt|;
name|incomingListener
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|SocketListener
argument_list|()
argument_list|,
literal|"JmDNS.SocketListener"
argument_list|)
expr_stmt|;
comment|// Bind to multicast socket
name|openMulticastSocket
argument_list|(
name|localHost
argument_list|)
expr_stmt|;
name|start
argument_list|(
name|services
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|start
parameter_list|(
name|Collection
name|serviceInfos
parameter_list|)
block|{
name|state
operator|=
name|DNSState
operator|.
name|PROBING_1
expr_stmt|;
name|incomingListener
operator|.
name|start
argument_list|()
expr_stmt|;
operator|new
name|Prober
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
name|iterator
init|=
name|serviceInfos
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
try|try
block|{
name|registerService
argument_list|(
operator|new
name|ServiceInfo
argument_list|(
operator|(
name|ServiceInfo
operator|)
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|exception
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"start() Registration exception "
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|openMulticastSocket
parameter_list|(
name|HostInfo
name|hostInfo
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|group
operator|==
literal|null
condition|)
block|{
name|group
operator|=
name|InetAddress
operator|.
name|getByName
argument_list|(
name|DNSConstants
operator|.
name|MDNS_GROUP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|socket
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|closeMulticastSocket
argument_list|()
expr_stmt|;
block|}
name|socket
operator|=
operator|new
name|MulticastSocket
argument_list|(
name|DNSConstants
operator|.
name|MDNS_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hostInfo
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|localHost
operator|.
name|getInterface
argument_list|()
operator|!=
literal|null
operator|)
condition|)
block|{
name|socket
operator|.
name|setNetworkInterface
argument_list|(
name|hostInfo
operator|.
name|getInterface
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|socket
operator|.
name|setTimeToLive
argument_list|(
literal|255
argument_list|)
expr_stmt|;
name|socket
operator|.
name|joinGroup
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|closeMulticastSocket
parameter_list|()
block|{
name|logger
operator|.
name|finer
argument_list|(
literal|"closeMulticastSocket()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|socket
operator|!=
literal|null
condition|)
block|{
comment|// close socket
try|try
block|{
name|socket
operator|.
name|leaveGroup
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|socket
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|incomingListener
operator|!=
literal|null
condition|)
block|{
name|incomingListener
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|exception
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"closeMulticastSocket() Close socket exception "
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
name|socket
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// State machine
comment|/**      * Sets the state and notifies all objects that wait on JmDNS.      */
specifier|synchronized
name|void
name|advanceState
parameter_list|()
block|{
name|state
operator|=
name|state
operator|.
name|advance
argument_list|()
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|/**      * Sets the state and notifies all objects that wait on JmDNS.      */
specifier|synchronized
name|void
name|revertState
parameter_list|()
block|{
name|state
operator|=
name|state
operator|.
name|revert
argument_list|()
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|/**      * Sets the state and notifies all objects that wait on JmDNS.      */
specifier|synchronized
name|void
name|cancel
parameter_list|()
block|{
name|state
operator|=
name|DNSState
operator|.
name|CANCELED
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns the current state of this info.      */
name|DNSState
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
comment|/**      * Return the DNSCache associated with the cache variable      */
name|DNSCache
name|getCache
parameter_list|()
block|{
return|return
name|cache
return|;
block|}
comment|/**      * Return the HostName associated with this JmDNS instance.      * Note: May not be the same as what started.  The host name is subject to      * negotiation.      */
specifier|public
name|String
name|getHostName
parameter_list|()
block|{
return|return
name|localHost
operator|.
name|getName
argument_list|()
return|;
block|}
specifier|public
name|HostInfo
name|getLocalHost
parameter_list|()
block|{
return|return
name|localHost
return|;
block|}
comment|/**      * Return the address of the interface to which this instance of JmDNS is      * bound.      */
specifier|public
name|InetAddress
name|getInterface
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|socket
operator|.
name|getInterface
argument_list|()
return|;
block|}
comment|/**      * Get service information. If the information is not cached, the method      * will block until updated information is received.      *<p/>      * Usage note: Do not call this method from the AWT event dispatcher thread.      * You will make the user interface unresponsive.      *      * @param type fully qualified service type, such as<code>_http._tcp.local.</code> .      * @param name unqualified service name, such as<code>foobar</code> .      * @return null if the service information cannot be obtained      */
specifier|public
name|ServiceInfo
name|getServiceInfo
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|getServiceInfo
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|3
operator|*
literal|1000
argument_list|)
return|;
block|}
comment|/**      * Get service information. If the information is not cached, the method      * will block for the given timeout until updated information is received.      *<p/>      * Usage note: If you call this method from the AWT event dispatcher thread,      * use a small timeout, or you will make the user interface unresponsive.      *      * @param type    full qualified service type, such as<code>_http._tcp.local.</code> .      * @param name    unqualified service name, such as<code>foobar</code> .      * @param timeout timeout in milliseconds      * @return null if the service information cannot be obtained      */
specifier|public
name|ServiceInfo
name|getServiceInfo
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|name
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|ServiceInfo
name|info
init|=
operator|new
name|ServiceInfo
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
operator|new
name|ServiceInfoResolver
argument_list|(
name|info
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|end
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|timeout
decl_stmt|;
name|long
name|delay
decl_stmt|;
synchronized|synchronized
init|(
name|info
init|)
block|{
while|while
condition|(
operator|!
name|info
operator|.
name|hasData
argument_list|()
operator|&&
operator|(
name|delay
operator|=
name|end
operator|-
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
name|info
operator|.
name|wait
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// empty
block|}
return|return
operator|(
name|info
operator|.
name|hasData
argument_list|()
operator|)
condition|?
name|info
else|:
literal|null
return|;
block|}
comment|/**      * Request service information. The information about the service is      * requested and the ServiceListener.resolveService method is called as soon      * as it is available.      *<p/>      * Usage note: Do not call this method from the AWT event dispatcher thread.      * You will make the user interface unresponsive.      *      * @param type full qualified service type, such as<code>_http._tcp.local.</code> .      * @param name unqualified service name, such as<code>foobar</code> .      */
specifier|public
name|void
name|requestServiceInfo
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|requestServiceInfo
argument_list|(
name|type
argument_list|,
name|name
argument_list|,
literal|3
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/**      * Request service information. The information about the service is requested      * and the ServiceListener.resolveService method is called as soon as it is available.      *      * @param type    full qualified service type, such as<code>_http._tcp.local.</code> .      * @param name    unqualified service name, such as<code>foobar</code> .      * @param timeout timeout in milliseconds      */
specifier|public
name|void
name|requestServiceInfo
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|name
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|registerServiceType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|ServiceInfo
name|info
init|=
operator|new
name|ServiceInfo
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
operator|new
name|ServiceInfoResolver
argument_list|(
name|info
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
name|long
name|end
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|timeout
decl_stmt|;
name|long
name|delay
decl_stmt|;
synchronized|synchronized
init|(
name|info
init|)
block|{
while|while
condition|(
operator|!
name|info
operator|.
name|hasData
argument_list|()
operator|&&
operator|(
name|delay
operator|=
name|end
operator|-
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
name|info
operator|.
name|wait
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// empty
block|}
block|}
name|void
name|handleServiceResolved
parameter_list|(
name|ServiceInfo
name|info
parameter_list|)
block|{
name|List
name|list
init|=
operator|(
name|List
operator|)
name|serviceListeners
operator|.
name|get
argument_list|(
name|info
operator|.
name|type
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
name|ServiceEvent
name|event
init|=
operator|new
name|ServiceEvent
argument_list|(
name|this
argument_list|,
name|info
operator|.
name|type
argument_list|,
name|info
operator|.
name|getName
argument_list|()
argument_list|,
name|info
argument_list|)
decl_stmt|;
comment|// Iterate on a copy in case listeners will modify it
specifier|final
name|ArrayList
name|listCopy
init|=
operator|new
name|ArrayList
argument_list|(
name|list
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|iterator
init|=
name|listCopy
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
operator|(
operator|(
name|ServiceListener
operator|)
name|iterator
operator|.
name|next
argument_list|()
operator|)
operator|.
name|serviceResolved
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Listen for service types.      *      * @param listener listener for service types      */
specifier|public
name|void
name|addServiceTypeListener
parameter_list|(
name|ServiceTypeListener
name|listener
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|typeListeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|typeListeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|// report cached service types
for|for
control|(
name|Iterator
name|iterator
init|=
name|serviceTypes
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|listener
operator|.
name|serviceTypeAdded
argument_list|(
operator|new
name|ServiceEvent
argument_list|(
name|this
argument_list|,
operator|(
name|String
operator|)
name|iterator
operator|.
name|next
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|new
name|TypeResolver
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**      * Remove listener for service types.      *      * @param listener listener for service types      */
specifier|public
name|void
name|removeServiceTypeListener
parameter_list|(
name|ServiceTypeListener
name|listener
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|typeListeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Listen for services of a given type. The type has to be a fully qualified      * type name such as<code>_http._tcp.local.</code>.      *      * @param type     full qualified service type, such as<code>_http._tcp.local.</code>.      * @param listener listener for service updates      */
specifier|public
name|void
name|addServiceListener
parameter_list|(
name|String
name|type
parameter_list|,
name|ServiceListener
name|listener
parameter_list|)
block|{
name|String
name|lotype
init|=
name|type
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|removeServiceListener
argument_list|(
name|lotype
argument_list|,
name|listener
argument_list|)
expr_stmt|;
name|List
name|list
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|list
operator|=
operator|(
name|List
operator|)
name|serviceListeners
operator|.
name|get
argument_list|(
name|lotype
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
name|list
operator|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|LinkedList
argument_list|()
argument_list|)
expr_stmt|;
name|serviceListeners
operator|.
name|put
argument_list|(
name|lotype
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|// report cached service types
for|for
control|(
name|Iterator
name|i
init|=
name|cache
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
for|for
control|(
name|DNSCache
operator|.
name|CacheNode
name|n
init|=
operator|(
name|DNSCache
operator|.
name|CacheNode
operator|)
name|i
operator|.
name|next
argument_list|()
init|;
name|n
operator|!=
literal|null
condition|;
name|n
operator|=
name|n
operator|.
name|next
argument_list|()
control|)
block|{
name|DNSRecord
name|rec
init|=
operator|(
name|DNSRecord
operator|)
name|n
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|rec
operator|.
name|type
operator|==
name|DNSConstants
operator|.
name|TYPE_SRV
condition|)
block|{
if|if
condition|(
name|rec
operator|.
name|name
operator|.
name|endsWith
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|listener
operator|.
name|serviceAdded
argument_list|(
operator|new
name|ServiceEvent
argument_list|(
name|this
argument_list|,
name|type
argument_list|,
name|toUnqualifiedName
argument_list|(
name|type
argument_list|,
name|rec
operator|.
name|name
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
operator|new
name|ServiceResolver
argument_list|(
name|type
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**      * Remove listener for services of a given type.      *      * @param listener listener for service updates      */
specifier|public
name|void
name|removeServiceListener
parameter_list|(
name|String
name|type
parameter_list|,
name|ServiceListener
name|listener
parameter_list|)
block|{
name|type
operator|=
name|type
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|List
name|list
init|=
operator|(
name|List
operator|)
name|serviceListeners
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|list
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|serviceListeners
operator|.
name|remove
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Register a service. The service is registered for access by other jmdns clients.      * The name of the service may be changed to make it unique.      */
specifier|public
name|void
name|registerService
parameter_list|(
name|ServiceInfo
name|info
parameter_list|)
throws|throws
name|IOException
block|{
name|registerServiceType
argument_list|(
name|info
operator|.
name|type
argument_list|)
expr_stmt|;
comment|// bind the service to this address
name|info
operator|.
name|server
operator|=
name|localHost
operator|.
name|getName
argument_list|()
expr_stmt|;
name|info
operator|.
name|addr
operator|=
name|localHost
operator|.
name|getAddress
argument_list|()
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|makeServiceNameUnique
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|services
operator|.
name|put
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
operator|new
comment|/*Service*/
name|Prober
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|info
init|)
block|{
while|while
condition|(
name|info
operator|.
name|getState
argument_list|()
operator|.
name|compareTo
argument_list|(
name|DNSState
operator|.
name|ANNOUNCED
argument_list|)
operator|<
literal|0
condition|)
block|{
name|info
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|//empty
block|}
name|logger
operator|.
name|fine
argument_list|(
literal|"registerService() JmDNS registered service as "
operator|+
name|info
argument_list|)
expr_stmt|;
block|}
comment|/**      * Unregister a service. The service should have been registered.      */
specifier|public
name|void
name|unregisterService
parameter_list|(
name|ServiceInfo
name|info
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|services
operator|.
name|remove
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|cancel
argument_list|()
expr_stmt|;
comment|// Note: We use this lock object to synchronize on it.
comment|//       Synchronizing on another object (e.g. the ServiceInfo) does
comment|//       not make sense, because the sole purpose of the lock is to
comment|//       wait until the canceler has finished. If we synchronized on
comment|//       the ServiceInfo or on the Canceler, we would block all
comment|//       accesses to synchronized methods on that object. This is not
comment|//       what we want!
name|Object
name|lock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
operator|new
name|Canceler
argument_list|(
name|info
argument_list|,
name|lock
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Remind: We get a deadlock here, if the Canceler does not run!
try|try
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|lock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// empty
block|}
block|}
comment|/**      * Unregister all services.      */
specifier|public
name|void
name|unregisterAllServices
parameter_list|()
block|{
name|logger
operator|.
name|finer
argument_list|(
literal|"unregisterAllServices()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|services
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|Collection
name|list
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|list
operator|=
operator|new
name|LinkedList
argument_list|(
name|services
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|services
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|iterator
init|=
name|list
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
operator|(
operator|(
name|ServiceInfo
operator|)
name|iterator
operator|.
name|next
argument_list|()
operator|)
operator|.
name|cancel
argument_list|()
expr_stmt|;
block|}
name|Object
name|lock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
operator|new
name|Canceler
argument_list|(
name|list
argument_list|,
name|lock
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Remind: We get a livelock here, if the Canceler does not run!
try|try
block|{
synchronized|synchronized
init|(
name|lock
init|)
block|{
if|if
condition|(
operator|!
name|closed
condition|)
block|{
name|lock
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// empty
block|}
block|}
comment|/**      * Register a service type. If this service type was not already known,      * all service listeners will be notified of the new service type. Service types      * are automatically registered as they are discovered.      */
specifier|public
name|void
name|registerServiceType
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|String
name|name
init|=
name|type
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
name|serviceTypes
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|type
operator|.
name|indexOf
argument_list|(
literal|"._mdns._udp."
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|!
name|type
operator|.
name|endsWith
argument_list|(
literal|".in-addr.arpa."
argument_list|)
condition|)
block|{
name|Collection
name|list
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|serviceTypes
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|list
operator|=
operator|new
name|LinkedList
argument_list|(
name|typeListeners
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|iterator
init|=
name|list
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
operator|(
operator|(
name|ServiceTypeListener
operator|)
name|iterator
operator|.
name|next
argument_list|()
operator|)
operator|.
name|serviceTypeAdded
argument_list|(
operator|new
name|ServiceEvent
argument_list|(
name|this
argument_list|,
name|type
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Generate a possibly unique name for a host using the information we      * have in the cache.      *      * @return returns true, if the name of the host had to be changed.      */
specifier|private
name|boolean
name|makeHostNameUnique
parameter_list|(
name|DNSRecord
operator|.
name|Address
name|host
parameter_list|)
block|{
name|String
name|originalName
init|=
name|host
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|boolean
name|collision
decl_stmt|;
do|do
block|{
name|collision
operator|=
literal|false
expr_stmt|;
comment|// Check for collision in cache
for|for
control|(
name|DNSCache
operator|.
name|CacheNode
name|j
init|=
name|cache
operator|.
name|find
argument_list|(
name|host
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
init|;
name|j
operator|!=
literal|null
condition|;
name|j
operator|=
name|j
operator|.
name|next
argument_list|()
control|)
block|{
name|DNSRecord
name|a
init|=
operator|(
name|DNSRecord
operator|)
name|j
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
literal|false
condition|)
block|{
name|host
operator|.
name|name
operator|=
name|incrementName
argument_list|(
name|host
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|collision
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|collision
condition|)
do|;
if|if
condition|(
name|originalName
operator|.
name|equals
argument_list|(
name|host
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**      * Generate a possibly unique name for a service using the information we      * have in the cache.      *      * @return returns true, if the name of the service info had to be changed.      */
specifier|private
name|boolean
name|makeServiceNameUnique
parameter_list|(
name|ServiceInfo
name|info
parameter_list|)
block|{
name|String
name|originalQualifiedName
init|=
name|info
operator|.
name|getQualifiedName
argument_list|()
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|boolean
name|collision
decl_stmt|;
do|do
block|{
name|collision
operator|=
literal|false
expr_stmt|;
comment|// Check for collision in cache
for|for
control|(
name|DNSCache
operator|.
name|CacheNode
name|j
init|=
name|cache
operator|.
name|find
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
init|;
name|j
operator|!=
literal|null
condition|;
name|j
operator|=
name|j
operator|.
name|next
argument_list|()
control|)
block|{
name|DNSRecord
name|a
init|=
operator|(
name|DNSRecord
operator|)
name|j
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|.
name|type
operator|==
name|DNSConstants
operator|.
name|TYPE_SRV
operator|)
operator|&&
operator|!
name|a
operator|.
name|isExpired
argument_list|(
name|now
argument_list|)
condition|)
block|{
name|DNSRecord
operator|.
name|Service
name|s
init|=
operator|(
name|DNSRecord
operator|.
name|Service
operator|)
name|a
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|port
operator|!=
name|info
operator|.
name|port
operator|||
operator|!
name|s
operator|.
name|server
operator|.
name|equals
argument_list|(
name|localHost
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|logger
operator|.
name|finer
argument_list|(
literal|"makeServiceNameUnique() JmDNS.makeServiceNameUnique srv collision:"
operator|+
name|a
operator|+
literal|" s.server="
operator|+
name|s
operator|.
name|server
operator|+
literal|" "
operator|+
name|localHost
operator|.
name|getName
argument_list|()
operator|+
literal|" equals:"
operator|+
operator|(
name|s
operator|.
name|server
operator|.
name|equals
argument_list|(
name|localHost
operator|.
name|getName
argument_list|()
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|setName
argument_list|(
name|incrementName
argument_list|(
name|info
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|collision
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// Check for collision with other service infos published by JmDNS
name|Object
name|selfService
init|=
name|services
operator|.
name|get
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|selfService
operator|!=
literal|null
operator|&&
name|selfService
operator|!=
name|info
condition|)
block|{
name|info
operator|.
name|setName
argument_list|(
name|incrementName
argument_list|(
name|info
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|collision
operator|=
literal|true
expr_stmt|;
block|}
block|}
do|while
condition|(
name|collision
condition|)
do|;
return|return
operator|!
operator|(
name|originalQualifiedName
operator|.
name|equals
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
operator|)
return|;
block|}
name|String
name|incrementName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
try|try
block|{
name|int
name|l
init|=
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'('
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|')'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|l
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|l
operator|<
name|r
operator|)
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|l
argument_list|)
operator|+
literal|"("
operator|+
operator|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|l
operator|+
literal|1
argument_list|,
name|r
argument_list|)
argument_list|)
operator|+
literal|1
operator|)
operator|+
literal|")"
expr_stmt|;
block|}
else|else
block|{
name|name
operator|+=
literal|" (2)"
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|name
operator|+=
literal|" (2)"
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
comment|/**      * Add a listener for a question. The listener will receive updates      * of answers to the question as they arrive, or from the cache if they      * are already available.      */
name|void
name|addListener
parameter_list|(
name|DNSListener
name|listener
parameter_list|,
name|DNSQuestion
name|question
parameter_list|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// add the new listener
synchronized|synchronized
init|(
name|this
init|)
block|{
name|listeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|// report existing matched records
if|if
condition|(
name|question
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|DNSCache
operator|.
name|CacheNode
name|i
init|=
name|cache
operator|.
name|find
argument_list|(
name|question
operator|.
name|name
argument_list|)
init|;
name|i
operator|!=
literal|null
condition|;
name|i
operator|=
name|i
operator|.
name|next
argument_list|()
control|)
block|{
name|DNSRecord
name|c
init|=
operator|(
name|DNSRecord
operator|)
name|i
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|question
operator|.
name|answeredBy
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|c
operator|.
name|isExpired
argument_list|(
name|now
argument_list|)
condition|)
block|{
name|listener
operator|.
name|updateRecord
argument_list|(
name|this
argument_list|,
name|now
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Remove a listener from all outstanding questions. The listener will no longer      * receive any updates.      */
name|void
name|removeListener
parameter_list|(
name|DNSListener
name|listener
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|listeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Remind: Method updateRecord should receive a better name.
comment|/**      * Notify all listeners that a record was updated.      */
name|void
name|updateRecord
parameter_list|(
name|long
name|now
parameter_list|,
name|DNSRecord
name|rec
parameter_list|)
block|{
comment|// We do not want to block the entire DNS while we are updating the record for each listener (service info)
name|List
name|listenerList
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|listenerList
operator|=
operator|new
name|ArrayList
argument_list|(
name|listeners
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|iterator
init|=
name|listenerList
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DNSListener
name|listener
init|=
operator|(
name|DNSListener
operator|)
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|listener
operator|.
name|updateRecord
argument_list|(
name|this
argument_list|,
name|now
argument_list|,
name|rec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rec
operator|.
name|type
operator|==
name|DNSConstants
operator|.
name|TYPE_PTR
operator|||
name|rec
operator|.
name|type
operator|==
name|DNSConstants
operator|.
name|TYPE_SRV
condition|)
block|{
name|List
name|serviceListenerList
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|serviceListenerList
operator|=
operator|(
name|List
operator|)
name|serviceListeners
operator|.
name|get
argument_list|(
name|rec
operator|.
name|name
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
comment|// Iterate on a copy in case listeners will modify it
if|if
condition|(
name|serviceListenerList
operator|!=
literal|null
condition|)
block|{
name|serviceListenerList
operator|=
operator|new
name|ArrayList
argument_list|(
name|serviceListenerList
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|serviceListenerList
operator|!=
literal|null
condition|)
block|{
name|boolean
name|expired
init|=
name|rec
operator|.
name|isExpired
argument_list|(
name|now
argument_list|)
decl_stmt|;
name|String
name|type
init|=
name|rec
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|name
init|=
operator|(
operator|(
name|DNSRecord
operator|.
name|Pointer
operator|)
name|rec
operator|)
operator|.
name|getAlias
argument_list|()
decl_stmt|;
comment|// DNSRecord old = (DNSRecord)services.get(name.toLowerCase());
if|if
condition|(
operator|!
name|expired
condition|)
block|{
comment|// new record
name|ServiceEvent
name|event
init|=
operator|new
name|ServiceEvent
argument_list|(
name|this
argument_list|,
name|type
argument_list|,
name|toUnqualifiedName
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|iterator
init|=
name|serviceListenerList
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
operator|(
operator|(
name|ServiceListener
operator|)
name|iterator
operator|.
name|next
argument_list|()
operator|)
operator|.
name|serviceAdded
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// expire record
name|ServiceEvent
name|event
init|=
operator|new
name|ServiceEvent
argument_list|(
name|this
argument_list|,
name|type
argument_list|,
name|toUnqualifiedName
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|iterator
init|=
name|serviceListenerList
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
operator|(
operator|(
name|ServiceListener
operator|)
name|iterator
operator|.
name|next
argument_list|()
operator|)
operator|.
name|serviceRemoved
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Handle an incoming response. Cache answers, and pass them on to      * the appropriate questions.      */
specifier|private
name|void
name|handleResponse
parameter_list|(
name|DNSIncoming
name|msg
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|boolean
name|hostConflictDetected
init|=
literal|false
decl_stmt|;
name|boolean
name|serviceConflictDetected
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|msg
operator|.
name|answers
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|boolean
name|isInformative
init|=
literal|false
decl_stmt|;
name|DNSRecord
name|rec
init|=
operator|(
name|DNSRecord
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|boolean
name|expired
init|=
name|rec
operator|.
name|isExpired
argument_list|(
name|now
argument_list|)
decl_stmt|;
comment|// update the cache
name|DNSRecord
name|c
init|=
operator|(
name|DNSRecord
operator|)
name|cache
operator|.
name|get
argument_list|(
name|rec
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|expired
condition|)
block|{
name|isInformative
operator|=
literal|true
expr_stmt|;
name|cache
operator|.
name|remove
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|.
name|resetTTL
argument_list|(
name|rec
argument_list|)
expr_stmt|;
name|rec
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|expired
condition|)
block|{
name|isInformative
operator|=
literal|true
expr_stmt|;
name|cache
operator|.
name|add
argument_list|(
name|rec
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|rec
operator|.
name|type
condition|)
block|{
case|case
name|DNSConstants
operator|.
name|TYPE_PTR
case|:
comment|// handle _mdns._udp records
if|if
condition|(
name|rec
operator|.
name|getName
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|"._mdns._udp."
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|expired
operator|&&
name|rec
operator|.
name|name
operator|.
name|startsWith
argument_list|(
literal|"_services._mdns._udp."
argument_list|)
condition|)
block|{
name|isInformative
operator|=
literal|true
expr_stmt|;
name|registerServiceType
argument_list|(
operator|(
operator|(
name|DNSRecord
operator|.
name|Pointer
operator|)
name|rec
operator|)
operator|.
name|alias
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|registerServiceType
argument_list|(
name|rec
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|rec
operator|.
name|getType
argument_list|()
operator|==
name|DNSConstants
operator|.
name|TYPE_A
operator|)
operator|||
operator|(
name|rec
operator|.
name|getType
argument_list|()
operator|==
name|DNSConstants
operator|.
name|TYPE_AAAA
operator|)
condition|)
block|{
name|hostConflictDetected
operator||=
name|rec
operator|.
name|handleResponse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|serviceConflictDetected
operator||=
name|rec
operator|.
name|handleResponse
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// notify the listeners
if|if
condition|(
name|isInformative
condition|)
block|{
name|updateRecord
argument_list|(
name|now
argument_list|,
name|rec
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hostConflictDetected
operator|||
name|serviceConflictDetected
condition|)
block|{
operator|new
name|Prober
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Handle an incoming query. See if we can answer any part of it      * given our service infos.      */
specifier|private
name|void
name|handleQuery
parameter_list|(
name|DNSIncoming
name|in
parameter_list|,
name|InetAddress
name|addr
parameter_list|,
name|int
name|port
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Track known answers
name|boolean
name|hostConflictDetected
init|=
literal|false
decl_stmt|;
name|boolean
name|serviceConflictDetected
init|=
literal|false
decl_stmt|;
name|long
name|expirationTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|DNSConstants
operator|.
name|KNOWN_ANSWER_TTL
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|in
operator|.
name|answers
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DNSRecord
name|answer
init|=
operator|(
name|DNSRecord
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|answer
operator|.
name|getType
argument_list|()
operator|==
name|DNSConstants
operator|.
name|TYPE_A
operator|)
operator|||
operator|(
name|answer
operator|.
name|getType
argument_list|()
operator|==
name|DNSConstants
operator|.
name|TYPE_AAAA
operator|)
condition|)
block|{
name|hostConflictDetected
operator||=
name|answer
operator|.
name|handleQuery
argument_list|(
name|this
argument_list|,
name|expirationTime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|serviceConflictDetected
operator||=
name|answer
operator|.
name|handleQuery
argument_list|(
name|this
argument_list|,
name|expirationTime
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|plannedAnswer
operator|!=
literal|null
condition|)
block|{
name|plannedAnswer
operator|.
name|append
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|in
operator|.
name|isTruncated
argument_list|()
condition|)
block|{
name|plannedAnswer
operator|=
name|in
expr_stmt|;
block|}
operator|new
name|Responder
argument_list|(
name|in
argument_list|,
name|addr
argument_list|,
name|port
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|hostConflictDetected
operator|||
name|serviceConflictDetected
condition|)
block|{
operator|new
name|Prober
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Add an answer to a question. Deal with the case when the      * outgoing packet overflows      */
name|DNSOutgoing
name|addAnswer
parameter_list|(
name|DNSIncoming
name|in
parameter_list|,
name|InetAddress
name|addr
parameter_list|,
name|int
name|port
parameter_list|,
name|DNSOutgoing
name|out
parameter_list|,
name|DNSRecord
name|rec
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|DNSOutgoing
argument_list|(
name|DNSConstants
operator|.
name|FLAGS_QR_RESPONSE
operator||
name|DNSConstants
operator|.
name|FLAGS_AA
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|out
operator|.
name|addAnswer
argument_list|(
name|in
argument_list|,
name|rec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|out
operator|.
name|flags
operator||=
name|DNSConstants
operator|.
name|FLAGS_TC
expr_stmt|;
name|out
operator|.
name|id
operator|=
name|in
operator|.
name|id
expr_stmt|;
name|out
operator|.
name|finish
argument_list|()
expr_stmt|;
name|send
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|=
operator|new
name|DNSOutgoing
argument_list|(
name|DNSConstants
operator|.
name|FLAGS_QR_RESPONSE
operator||
name|DNSConstants
operator|.
name|FLAGS_AA
argument_list|)
expr_stmt|;
name|out
operator|.
name|addAnswer
argument_list|(
name|in
argument_list|,
name|rec
argument_list|)
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
comment|/**      * Send an outgoing multicast DNS message.      */
specifier|private
name|void
name|send
parameter_list|(
name|DNSOutgoing
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|finish
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|out
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|DatagramPacket
name|packet
init|=
operator|new
name|DatagramPacket
argument_list|(
name|out
operator|.
name|data
argument_list|,
name|out
operator|.
name|off
argument_list|,
name|group
argument_list|,
name|DNSConstants
operator|.
name|MDNS_PORT
argument_list|)
decl_stmt|;
try|try
block|{
name|DNSIncoming
name|msg
init|=
operator|new
name|DNSIncoming
argument_list|(
name|packet
argument_list|)
decl_stmt|;
name|logger
operator|.
name|finest
argument_list|(
literal|"send() JmDNS out:"
operator|+
name|msg
operator|.
name|print
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|throwing
argument_list|(
name|getClass
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
literal|"send(DNSOutgoing) - JmDNS can not parse what it sends!!!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|socket
operator|.
name|send
argument_list|(
name|packet
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Listen for multicast packets.      */
class|class
name|SocketListener
implements|implements
name|Runnable
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|byte
name|buf
index|[]
init|=
operator|new
name|byte
index|[
name|DNSConstants
operator|.
name|MAX_MSG_ABSOLUTE
index|]
decl_stmt|;
name|DatagramPacket
name|packet
init|=
operator|new
name|DatagramPacket
argument_list|(
name|buf
argument_list|,
name|buf
operator|.
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|state
operator|!=
name|DNSState
operator|.
name|CANCELED
condition|)
block|{
name|packet
operator|.
name|setLength
argument_list|(
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|socket
operator|.
name|receive
argument_list|(
name|packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|DNSState
operator|.
name|CANCELED
condition|)
block|{
break|break;
block|}
try|try
block|{
if|if
condition|(
name|localHost
operator|.
name|shouldIgnorePacket
argument_list|(
name|packet
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|DNSIncoming
name|msg
init|=
operator|new
name|DNSIncoming
argument_list|(
name|packet
argument_list|)
decl_stmt|;
name|logger
operator|.
name|finest
argument_list|(
literal|"SocketListener.run() JmDNS in:"
operator|+
name|msg
operator|.
name|print
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|ioLock
init|)
block|{
if|if
condition|(
name|msg
operator|.
name|isQuery
argument_list|()
condition|)
block|{
if|if
condition|(
name|packet
operator|.
name|getPort
argument_list|()
operator|!=
name|DNSConstants
operator|.
name|MDNS_PORT
condition|)
block|{
name|handleQuery
argument_list|(
name|msg
argument_list|,
name|packet
operator|.
name|getAddress
argument_list|()
argument_list|,
name|packet
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|handleQuery
argument_list|(
name|msg
argument_list|,
name|group
argument_list|,
name|DNSConstants
operator|.
name|MDNS_PORT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|handleResponse
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"run() exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|DNSState
operator|.
name|CANCELED
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"run() exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Periodicaly removes expired entries from the cache.      */
specifier|private
class|class
name|RecordReaper
extends|extends
name|TimerTask
block|{
specifier|public
name|void
name|start
parameter_list|()
block|{
name|timer
operator|.
name|schedule
argument_list|(
name|this
argument_list|,
name|DNSConstants
operator|.
name|RECORD_REAPER_INTERVAL
argument_list|,
name|DNSConstants
operator|.
name|RECORD_REAPER_INTERVAL
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
synchronized|synchronized
init|(
name|JmDNS
operator|.
name|this
init|)
block|{
if|if
condition|(
name|state
operator|==
name|DNSState
operator|.
name|CANCELED
condition|)
block|{
return|return;
block|}
name|logger
operator|.
name|finest
argument_list|(
literal|"run() JmDNS reaping cache"
argument_list|)
expr_stmt|;
comment|// Remove expired answers from the cache
comment|// -------------------------------------
comment|// To prevent race conditions, we defensively copy all cache
comment|// entries into a list.
name|List
name|list
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|cache
init|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|cache
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
for|for
control|(
name|DNSCache
operator|.
name|CacheNode
name|n
init|=
operator|(
name|DNSCache
operator|.
name|CacheNode
operator|)
name|i
operator|.
name|next
argument_list|()
init|;
name|n
operator|!=
literal|null
condition|;
name|n
operator|=
name|n
operator|.
name|next
argument_list|()
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|n
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Now, we remove them.
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|list
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DNSRecord
name|c
init|=
operator|(
name|DNSRecord
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|isExpired
argument_list|(
name|now
argument_list|)
condition|)
block|{
name|updateRecord
argument_list|(
name|now
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|cache
operator|.
name|remove
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * The Prober sends three consecutive probes for all service infos      * that needs probing as well as for the host name.      * The state of each service info of the host name is advanced, when a probe has      * been sent for it.      * When the prober has run three times, it launches an Announcer.      *<p/>      * If a conflict during probes occurs, the affected service infos (and affected      * host name) are taken away from the prober. This eventually causes the prober      * tho cancel itself.      */
specifier|private
class|class
name|Prober
extends|extends
name|TimerTask
block|{
comment|/**          * The state of the prober.          */
name|DNSState
name|taskState
init|=
name|DNSState
operator|.
name|PROBING_1
decl_stmt|;
specifier|public
name|Prober
parameter_list|()
block|{
comment|// Associate the host name to this, if it needs probing
if|if
condition|(
name|state
operator|==
name|DNSState
operator|.
name|PROBING_1
condition|)
block|{
name|task
operator|=
name|this
expr_stmt|;
block|}
comment|// Associate services to this, if they need probing
synchronized|synchronized
init|(
name|JmDNS
operator|.
name|this
init|)
block|{
for|for
control|(
name|Iterator
name|iterator
init|=
name|services
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ServiceInfo
name|info
init|=
operator|(
name|ServiceInfo
operator|)
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|getState
argument_list|()
operator|==
name|DNSState
operator|.
name|PROBING_1
condition|)
block|{
name|info
operator|.
name|task
operator|=
name|this
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|void
name|start
parameter_list|()
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|-
name|lastThrottleIncrement
operator|<
name|DNSConstants
operator|.
name|PROBE_THROTTLE_COUNT_INTERVAL
condition|)
block|{
name|throttle
operator|++
expr_stmt|;
block|}
else|else
block|{
name|throttle
operator|=
literal|1
expr_stmt|;
block|}
name|lastThrottleIncrement
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|DNSState
operator|.
name|ANNOUNCED
operator|&&
name|throttle
operator|<
name|DNSConstants
operator|.
name|PROBE_THROTTLE_COUNT
condition|)
block|{
name|timer
operator|.
name|schedule
argument_list|(
name|this
argument_list|,
name|random
operator|.
name|nextInt
argument_list|(
literal|1
operator|+
name|DNSConstants
operator|.
name|PROBE_WAIT_INTERVAL
argument_list|)
argument_list|,
name|DNSConstants
operator|.
name|PROBE_WAIT_INTERVAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timer
operator|.
name|schedule
argument_list|(
name|this
argument_list|,
name|DNSConstants
operator|.
name|PROBE_CONFLICT_INTERVAL
argument_list|,
name|DNSConstants
operator|.
name|PROBE_CONFLICT_INTERVAL
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|cancel
parameter_list|()
block|{
comment|// Remove association from host name to this
if|if
condition|(
name|task
operator|==
name|this
condition|)
block|{
name|task
operator|=
literal|null
expr_stmt|;
block|}
comment|// Remove associations from services to this
synchronized|synchronized
init|(
name|JmDNS
operator|.
name|this
init|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|services
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ServiceInfo
name|info
init|=
operator|(
name|ServiceInfo
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|task
operator|==
name|this
condition|)
block|{
name|info
operator|.
name|task
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
return|return
name|super
operator|.
name|cancel
argument_list|()
return|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
synchronized|synchronized
init|(
name|ioLock
init|)
block|{
name|DNSOutgoing
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// send probes for JmDNS itself
if|if
condition|(
name|state
operator|==
name|taskState
operator|&&
name|task
operator|==
name|this
condition|)
block|{
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|DNSOutgoing
argument_list|(
name|DNSConstants
operator|.
name|FLAGS_QR_QUERY
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|addQuestion
argument_list|(
operator|new
name|DNSQuestion
argument_list|(
name|localHost
operator|.
name|getName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_ANY
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|)
argument_list|)
expr_stmt|;
name|DNSRecord
name|answer
init|=
name|localHost
operator|.
name|getDNS4AddressRecord
argument_list|()
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|addAuthorativeAnswer
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
name|answer
operator|=
name|localHost
operator|.
name|getDNS6AddressRecord
argument_list|()
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|addAuthorativeAnswer
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
name|advanceState
argument_list|()
expr_stmt|;
block|}
comment|// send probes for services
comment|// Defensively copy the services into a local list,
comment|// to prevent race conditions with methods registerService
comment|// and unregisterService.
name|List
name|list
decl_stmt|;
synchronized|synchronized
init|(
name|JmDNS
operator|.
name|this
init|)
block|{
name|list
operator|=
operator|new
name|LinkedList
argument_list|(
name|services
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|list
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ServiceInfo
name|info
init|=
operator|(
name|ServiceInfo
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|info
init|)
block|{
if|if
condition|(
name|info
operator|.
name|getState
argument_list|()
operator|==
name|taskState
operator|&&
name|info
operator|.
name|task
operator|==
name|this
condition|)
block|{
name|info
operator|.
name|advanceState
argument_list|()
expr_stmt|;
name|logger
operator|.
name|fine
argument_list|(
literal|"run() JmDNS probing "
operator|+
name|info
operator|.
name|getQualifiedName
argument_list|()
operator|+
literal|" state "
operator|+
name|info
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|DNSOutgoing
argument_list|(
name|DNSConstants
operator|.
name|FLAGS_QR_QUERY
argument_list|)
expr_stmt|;
name|out
operator|.
name|addQuestion
argument_list|(
operator|new
name|DNSQuestion
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_ANY
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|addAuthorativeAnswer
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Service
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_SRV
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|priority
argument_list|,
name|info
operator|.
name|weight
argument_list|,
name|info
operator|.
name|port
argument_list|,
name|localHost
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|finer
argument_list|(
literal|"run() JmDNS probing #"
operator|+
name|taskState
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If we have nothing to send, another timer taskState ahead
comment|// of us has done the job for us. We can cancel.
name|cancel
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"run() exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|taskState
operator|=
name|taskState
operator|.
name|advance
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|taskState
operator|.
name|isProbing
argument_list|()
condition|)
block|{
name|cancel
argument_list|()
expr_stmt|;
operator|new
name|Announcer
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * The Announcer sends an accumulated query of all announces, and advances      * the state of all serviceInfos, for which it has sent an announce.      * The Announcer also sends announcements and advances the state of JmDNS itself.      *<p/>      * When the announcer has run two times, it finishes.      */
specifier|private
class|class
name|Announcer
extends|extends
name|TimerTask
block|{
comment|/**          * The state of the announcer.          */
name|DNSState
name|taskState
init|=
name|DNSState
operator|.
name|ANNOUNCING_1
decl_stmt|;
specifier|public
name|Announcer
parameter_list|()
block|{
comment|// Associate host to this, if it needs announcing
if|if
condition|(
name|state
operator|==
name|DNSState
operator|.
name|ANNOUNCING_1
condition|)
block|{
name|task
operator|=
name|this
expr_stmt|;
block|}
comment|// Associate services to this, if they need announcing
synchronized|synchronized
init|(
name|JmDNS
operator|.
name|this
init|)
block|{
for|for
control|(
name|Iterator
name|s
init|=
name|services
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|s
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ServiceInfo
name|info
init|=
operator|(
name|ServiceInfo
operator|)
name|s
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|getState
argument_list|()
operator|==
name|DNSState
operator|.
name|ANNOUNCING_1
condition|)
block|{
name|info
operator|.
name|task
operator|=
name|this
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|void
name|start
parameter_list|()
block|{
name|timer
operator|.
name|schedule
argument_list|(
name|this
argument_list|,
name|DNSConstants
operator|.
name|ANNOUNCE_WAIT_INTERVAL
argument_list|,
name|DNSConstants
operator|.
name|ANNOUNCE_WAIT_INTERVAL
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|cancel
parameter_list|()
block|{
comment|// Remove association from host to this
if|if
condition|(
name|task
operator|==
name|this
condition|)
block|{
name|task
operator|=
literal|null
expr_stmt|;
block|}
comment|// Remove associations from services to this
synchronized|synchronized
init|(
name|JmDNS
operator|.
name|this
init|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|services
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ServiceInfo
name|info
init|=
operator|(
name|ServiceInfo
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|task
operator|==
name|this
condition|)
block|{
name|info
operator|.
name|task
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
return|return
name|super
operator|.
name|cancel
argument_list|()
return|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
name|DNSOutgoing
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// send probes for JmDNS itself
if|if
condition|(
name|state
operator|==
name|taskState
condition|)
block|{
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|DNSOutgoing
argument_list|(
name|DNSConstants
operator|.
name|FLAGS_QR_RESPONSE
operator||
name|DNSConstants
operator|.
name|FLAGS_AA
argument_list|)
expr_stmt|;
block|}
name|DNSRecord
name|answer
init|=
name|localHost
operator|.
name|getDNS4AddressRecord
argument_list|()
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|addAnswer
argument_list|(
name|answer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|answer
operator|=
name|localHost
operator|.
name|getDNS6AddressRecord
argument_list|()
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|addAnswer
argument_list|(
name|answer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|advanceState
argument_list|()
expr_stmt|;
block|}
comment|// send announces for services
comment|// Defensively copy the services into a local list,
comment|// to prevent race conditions with methods registerService
comment|// and unregisterService.
name|List
name|list
decl_stmt|;
synchronized|synchronized
init|(
name|JmDNS
operator|.
name|this
init|)
block|{
name|list
operator|=
operator|new
name|ArrayList
argument_list|(
name|services
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|list
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ServiceInfo
name|info
init|=
operator|(
name|ServiceInfo
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|info
init|)
block|{
if|if
condition|(
name|info
operator|.
name|getState
argument_list|()
operator|==
name|taskState
operator|&&
name|info
operator|.
name|task
operator|==
name|this
condition|)
block|{
name|info
operator|.
name|advanceState
argument_list|()
expr_stmt|;
name|logger
operator|.
name|finer
argument_list|(
literal|"run() JmDNS announcing "
operator|+
name|info
operator|.
name|getQualifiedName
argument_list|()
operator|+
literal|" state "
operator|+
name|info
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|DNSOutgoing
argument_list|(
name|DNSConstants
operator|.
name|FLAGS_QR_RESPONSE
operator||
name|DNSConstants
operator|.
name|FLAGS_AA
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|addAnswer
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Pointer
argument_list|(
name|info
operator|.
name|type
argument_list|,
name|DNSConstants
operator|.
name|TYPE_PTR
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
operator|.
name|addAnswer
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Service
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_SRV
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|priority
argument_list|,
name|info
operator|.
name|weight
argument_list|,
name|info
operator|.
name|port
argument_list|,
name|localHost
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
operator|.
name|addAnswer
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Text
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_TXT
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|finer
argument_list|(
literal|"run() JmDNS announcing #"
operator|+
name|taskState
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If we have nothing to send, another timer taskState ahead
comment|// of us has done the job for us. We can cancel.
name|cancel
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"run() exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|taskState
operator|=
name|taskState
operator|.
name|advance
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|taskState
operator|.
name|isAnnouncing
argument_list|()
condition|)
block|{
name|cancel
argument_list|()
expr_stmt|;
operator|new
name|Renewer
argument_list|()
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * The Renewer is there to send renewal announcment when the record expire for ours infos.      */
specifier|private
class|class
name|Renewer
extends|extends
name|TimerTask
block|{
comment|/**          * The state of the announcer.          */
name|DNSState
name|taskState
init|=
name|DNSState
operator|.
name|ANNOUNCED
decl_stmt|;
specifier|public
name|Renewer
parameter_list|()
block|{
comment|// Associate host to this, if it needs renewal
if|if
condition|(
name|state
operator|==
name|DNSState
operator|.
name|ANNOUNCED
condition|)
block|{
name|task
operator|=
name|this
expr_stmt|;
block|}
comment|// Associate services to this, if they need renewal
synchronized|synchronized
init|(
name|JmDNS
operator|.
name|this
init|)
block|{
for|for
control|(
name|Iterator
name|s
init|=
name|services
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|s
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ServiceInfo
name|info
init|=
operator|(
name|ServiceInfo
operator|)
name|s
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|getState
argument_list|()
operator|==
name|DNSState
operator|.
name|ANNOUNCED
condition|)
block|{
name|info
operator|.
name|task
operator|=
name|this
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|void
name|start
parameter_list|()
block|{
name|timer
operator|.
name|schedule
argument_list|(
name|this
argument_list|,
name|DNSConstants
operator|.
name|ANNOUNCED_RENEWAL_TTL_INTERVAL
argument_list|,
name|DNSConstants
operator|.
name|ANNOUNCED_RENEWAL_TTL_INTERVAL
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|cancel
parameter_list|()
block|{
comment|// Remove association from host to this
if|if
condition|(
name|task
operator|==
name|this
condition|)
block|{
name|task
operator|=
literal|null
expr_stmt|;
block|}
comment|// Remove associations from services to this
synchronized|synchronized
init|(
name|JmDNS
operator|.
name|this
init|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|services
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ServiceInfo
name|info
init|=
operator|(
name|ServiceInfo
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|task
operator|==
name|this
condition|)
block|{
name|info
operator|.
name|task
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
return|return
name|super
operator|.
name|cancel
argument_list|()
return|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
name|DNSOutgoing
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// send probes for JmDNS itself
if|if
condition|(
name|state
operator|==
name|taskState
condition|)
block|{
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|DNSOutgoing
argument_list|(
name|DNSConstants
operator|.
name|FLAGS_QR_RESPONSE
operator||
name|DNSConstants
operator|.
name|FLAGS_AA
argument_list|)
expr_stmt|;
block|}
name|DNSRecord
name|answer
init|=
name|localHost
operator|.
name|getDNS4AddressRecord
argument_list|()
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|addAnswer
argument_list|(
name|answer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|answer
operator|=
name|localHost
operator|.
name|getDNS6AddressRecord
argument_list|()
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|addAnswer
argument_list|(
name|answer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|advanceState
argument_list|()
expr_stmt|;
block|}
comment|// send announces for services
comment|// Defensively copy the services into a local list,
comment|// to prevent race conditions with methods registerService
comment|// and unregisterService.
name|List
name|list
decl_stmt|;
synchronized|synchronized
init|(
name|JmDNS
operator|.
name|this
init|)
block|{
name|list
operator|=
operator|new
name|ArrayList
argument_list|(
name|services
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|list
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ServiceInfo
name|info
init|=
operator|(
name|ServiceInfo
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|info
init|)
block|{
if|if
condition|(
name|info
operator|.
name|getState
argument_list|()
operator|==
name|taskState
operator|&&
name|info
operator|.
name|task
operator|==
name|this
condition|)
block|{
name|info
operator|.
name|advanceState
argument_list|()
expr_stmt|;
name|logger
operator|.
name|finer
argument_list|(
literal|"run() JmDNS announced "
operator|+
name|info
operator|.
name|getQualifiedName
argument_list|()
operator|+
literal|" state "
operator|+
name|info
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|DNSOutgoing
argument_list|(
name|DNSConstants
operator|.
name|FLAGS_QR_RESPONSE
operator||
name|DNSConstants
operator|.
name|FLAGS_AA
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|addAnswer
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Pointer
argument_list|(
name|info
operator|.
name|type
argument_list|,
name|DNSConstants
operator|.
name|TYPE_PTR
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
operator|.
name|addAnswer
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Service
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_SRV
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|priority
argument_list|,
name|info
operator|.
name|weight
argument_list|,
name|info
operator|.
name|port
argument_list|,
name|localHost
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
operator|.
name|addAnswer
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Text
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_TXT
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|finer
argument_list|(
literal|"run() JmDNS announced"
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If we have nothing to send, another timer taskState ahead
comment|// of us has done the job for us. We can cancel.
name|cancel
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"run() exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
name|taskState
operator|=
name|taskState
operator|.
name|advance
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|taskState
operator|.
name|isAnnounced
argument_list|()
condition|)
block|{
name|cancel
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * The Responder sends a single answer for the specified service infos      * and for the host name.      */
specifier|private
class|class
name|Responder
extends|extends
name|TimerTask
block|{
specifier|private
name|DNSIncoming
name|in
decl_stmt|;
specifier|private
name|InetAddress
name|addr
decl_stmt|;
specifier|private
name|int
name|port
decl_stmt|;
specifier|public
name|Responder
parameter_list|(
name|DNSIncoming
name|in
parameter_list|,
name|InetAddress
name|addr
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|this
operator|.
name|port
operator|=
name|port
expr_stmt|;
block|}
specifier|public
name|void
name|start
parameter_list|()
block|{
comment|// According to draft-cheshire-dnsext-multicastdns.txt
comment|// chapter "8 Responding":
comment|// We respond immediately if we know for sure, that we are
comment|// the only one who can respond to the query.
comment|// In all other cases, we respond within 20-120 ms.
comment|//
comment|// According to draft-cheshire-dnsext-multicastdns.txt
comment|// chapter "7.2 Multi-Packet Known Answer Suppression":
comment|// We respond after 20-120 ms if the query is truncated.
name|boolean
name|iAmTheOnlyOne
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|in
operator|.
name|questions
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DNSEntry
name|entry
init|=
operator|(
name|DNSEntry
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|instanceof
name|DNSQuestion
condition|)
block|{
name|DNSQuestion
name|q
init|=
operator|(
name|DNSQuestion
operator|)
name|entry
decl_stmt|;
name|logger
operator|.
name|finest
argument_list|(
literal|"start() question="
operator|+
name|q
argument_list|)
expr_stmt|;
name|iAmTheOnlyOne
operator|&=
operator|(
name|q
operator|.
name|type
operator|==
name|DNSConstants
operator|.
name|TYPE_SRV
operator|||
name|q
operator|.
name|type
operator|==
name|DNSConstants
operator|.
name|TYPE_TXT
operator|||
name|q
operator|.
name|type
operator|==
name|DNSConstants
operator|.
name|TYPE_A
operator|||
name|q
operator|.
name|type
operator|==
name|DNSConstants
operator|.
name|TYPE_AAAA
operator|||
name|localHost
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|q
operator|.
name|name
argument_list|)
operator|||
name|services
operator|.
name|containsKey
argument_list|(
name|q
operator|.
name|name
operator|.
name|toLowerCase
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|iAmTheOnlyOne
condition|)
block|{
break|break;
block|}
block|}
block|}
name|int
name|delay
init|=
operator|(
name|iAmTheOnlyOne
operator|&&
operator|!
name|in
operator|.
name|isTruncated
argument_list|()
operator|)
condition|?
literal|0
else|:
name|DNSConstants
operator|.
name|RESPONSE_MIN_WAIT_INTERVAL
operator|+
name|random
operator|.
name|nextInt
argument_list|(
name|DNSConstants
operator|.
name|RESPONSE_MAX_WAIT_INTERVAL
operator|-
name|DNSConstants
operator|.
name|RESPONSE_MIN_WAIT_INTERVAL
operator|+
literal|1
argument_list|)
operator|-
name|in
operator|.
name|elapseSinceArrival
argument_list|()
decl_stmt|;
if|if
condition|(
name|delay
operator|<
literal|0
condition|)
block|{
name|delay
operator|=
literal|0
expr_stmt|;
block|}
name|logger
operator|.
name|finest
argument_list|(
literal|"start() Responder chosen delay="
operator|+
name|delay
argument_list|)
expr_stmt|;
name|timer
operator|.
name|schedule
argument_list|(
name|this
argument_list|,
name|delay
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
synchronized|synchronized
init|(
name|ioLock
init|)
block|{
if|if
condition|(
name|plannedAnswer
operator|==
name|in
condition|)
block|{
name|plannedAnswer
operator|=
literal|null
expr_stmt|;
block|}
comment|// We use these sets to prevent duplicate records
comment|// FIXME - This should be moved into DNSOutgoing
name|HashSet
name|questions
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
name|HashSet
name|answers
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|DNSState
operator|.
name|ANNOUNCED
condition|)
block|{
try|try
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|expirationTime
init|=
name|now
operator|+
literal|1
decl_stmt|;
comment|//=now+DNSConstants.KNOWN_ANSWER_TTL;
name|boolean
name|isUnicast
init|=
operator|(
name|port
operator|!=
name|DNSConstants
operator|.
name|MDNS_PORT
operator|)
decl_stmt|;
comment|// Answer questions
for|for
control|(
name|Iterator
name|iterator
init|=
name|in
operator|.
name|questions
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DNSEntry
name|entry
init|=
operator|(
name|DNSEntry
operator|)
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|instanceof
name|DNSQuestion
condition|)
block|{
name|DNSQuestion
name|q
init|=
operator|(
name|DNSQuestion
operator|)
name|entry
decl_stmt|;
comment|// for unicast responses the question must be included
if|if
condition|(
name|isUnicast
condition|)
block|{
comment|//out.addQuestion(q);
name|questions
operator|.
name|add
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|int
name|type
init|=
name|q
operator|.
name|type
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|DNSConstants
operator|.
name|TYPE_ANY
operator|||
name|type
operator|==
name|DNSConstants
operator|.
name|TYPE_SRV
condition|)
block|{
comment|// I ama not sure of why there is a special case here [PJYF Oct 15 2004]
if|if
condition|(
name|localHost
operator|.
name|getName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|q
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|// type = DNSConstants.TYPE_A;
name|DNSRecord
name|answer
init|=
name|localHost
operator|.
name|getDNS4AddressRecord
argument_list|()
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|answers
operator|.
name|add
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
name|answer
operator|=
name|localHost
operator|.
name|getDNS6AddressRecord
argument_list|()
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|answers
operator|.
name|add
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|DNSConstants
operator|.
name|TYPE_IGNORE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|serviceTypes
operator|.
name|containsKey
argument_list|(
name|q
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
name|type
operator|=
name|DNSConstants
operator|.
name|TYPE_PTR
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DNSConstants
operator|.
name|TYPE_A
case|:
block|{
comment|// Answer a query for a domain name
comment|//out = addAnswer( in, addr, port, out, host );
name|DNSRecord
name|answer
init|=
name|localHost
operator|.
name|getDNS4AddressRecord
argument_list|()
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|answers
operator|.
name|add
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DNSConstants
operator|.
name|TYPE_AAAA
case|:
block|{
comment|// Answer a query for a domain name
name|DNSRecord
name|answer
init|=
name|localHost
operator|.
name|getDNS6AddressRecord
argument_list|()
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|answers
operator|.
name|add
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DNSConstants
operator|.
name|TYPE_PTR
case|:
block|{
comment|// Answer a query for services of a given type
comment|// find matching services
for|for
control|(
name|Iterator
name|serviceIterator
init|=
name|services
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|serviceIterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ServiceInfo
name|info
init|=
operator|(
name|ServiceInfo
operator|)
name|serviceIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|getState
argument_list|()
operator|==
name|DNSState
operator|.
name|ANNOUNCED
condition|)
block|{
if|if
condition|(
name|q
operator|.
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
name|info
operator|.
name|type
argument_list|)
condition|)
block|{
name|DNSRecord
name|answer
init|=
name|localHost
operator|.
name|getDNS4AddressRecord
argument_list|()
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|answers
operator|.
name|add
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
name|answer
operator|=
name|localHost
operator|.
name|getDNS6AddressRecord
argument_list|()
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|answers
operator|.
name|add
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
name|answers
operator|.
name|add
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Pointer
argument_list|(
name|info
operator|.
name|type
argument_list|,
name|DNSConstants
operator|.
name|TYPE_PTR
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|answers
operator|.
name|add
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Service
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_SRV
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
operator||
name|DNSConstants
operator|.
name|CLASS_UNIQUE
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|priority
argument_list|,
name|info
operator|.
name|weight
argument_list|,
name|info
operator|.
name|port
argument_list|,
name|localHost
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|answers
operator|.
name|add
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Text
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_TXT
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
operator||
name|DNSConstants
operator|.
name|CLASS_UNIQUE
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|q
operator|.
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"_services._mdns._udp.local."
argument_list|)
condition|)
block|{
for|for
control|(
name|Iterator
name|serviceTypeIterator
init|=
name|serviceTypes
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|serviceTypeIterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|answers
operator|.
name|add
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Pointer
argument_list|(
literal|"_services._mdns._udp.local."
argument_list|,
name|DNSConstants
operator|.
name|TYPE_PTR
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
operator|(
name|String
operator|)
name|serviceTypeIterator
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|DNSConstants
operator|.
name|TYPE_SRV
case|:
case|case
name|DNSConstants
operator|.
name|TYPE_ANY
case|:
case|case
name|DNSConstants
operator|.
name|TYPE_TXT
case|:
block|{
name|ServiceInfo
name|info
init|=
operator|(
name|ServiceInfo
operator|)
name|services
operator|.
name|get
argument_list|(
name|q
operator|.
name|name
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|getState
argument_list|()
operator|==
name|DNSState
operator|.
name|ANNOUNCED
condition|)
block|{
name|DNSRecord
name|answer
init|=
name|localHost
operator|.
name|getDNS4AddressRecord
argument_list|()
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|answers
operator|.
name|add
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
name|answer
operator|=
name|localHost
operator|.
name|getDNS6AddressRecord
argument_list|()
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|answers
operator|.
name|add
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
name|answers
operator|.
name|add
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Pointer
argument_list|(
name|info
operator|.
name|type
argument_list|,
name|DNSConstants
operator|.
name|TYPE_PTR
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|answers
operator|.
name|add
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Service
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_SRV
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
operator||
name|DNSConstants
operator|.
name|CLASS_UNIQUE
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|priority
argument_list|,
name|info
operator|.
name|weight
argument_list|,
name|info
operator|.
name|port
argument_list|,
name|localHost
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|answers
operator|.
name|add
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Text
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_TXT
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
operator||
name|DNSConstants
operator|.
name|CLASS_UNIQUE
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default :
block|{
comment|//System.out.println("JmDNSResponder.unhandled query:"+q);
break|break;
block|}
block|}
block|}
block|}
comment|// remove known answers, if the ttl is at least half of
comment|// the correct value. (See Draft Cheshire chapter 7.1.).
for|for
control|(
name|Iterator
name|i
init|=
name|in
operator|.
name|answers
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DNSRecord
name|knownAnswer
init|=
operator|(
name|DNSRecord
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|knownAnswer
operator|.
name|ttl
operator|>
name|DNSConstants
operator|.
name|DNS_TTL
operator|/
literal|2
operator|&&
name|answers
operator|.
name|remove
argument_list|(
name|knownAnswer
argument_list|)
condition|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|FINER
argument_list|,
literal|"JmDNS Responder Known Answer Removed"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// responde if we have answers
if|if
condition|(
name|answers
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|logger
operator|.
name|finer
argument_list|(
literal|"run() JmDNS responding"
argument_list|)
expr_stmt|;
name|DNSOutgoing
name|out
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isUnicast
condition|)
block|{
name|out
operator|=
operator|new
name|DNSOutgoing
argument_list|(
name|DNSConstants
operator|.
name|FLAGS_QR_RESPONSE
operator||
name|DNSConstants
operator|.
name|FLAGS_AA
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|questions
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|out
operator|.
name|addQuestion
argument_list|(
operator|(
name|DNSQuestion
operator|)
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|answers
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|out
operator|=
name|addAnswer
argument_list|(
name|in
argument_list|,
name|addr
argument_list|,
name|port
argument_list|,
name|out
argument_list|,
operator|(
name|DNSRecord
operator|)
name|i
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|send
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|cancel
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"run() exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Helper class to resolve service types.      *<p/>      * The TypeResolver queries three times consecutively for service types, and then      * removes itself from the timer.      *<p/>      * The TypeResolver will run only if JmDNS is in state ANNOUNCED.      */
specifier|private
class|class
name|TypeResolver
extends|extends
name|TimerTask
block|{
specifier|public
name|void
name|start
parameter_list|()
block|{
name|timer
operator|.
name|schedule
argument_list|(
name|this
argument_list|,
name|DNSConstants
operator|.
name|QUERY_WAIT_INTERVAL
argument_list|,
name|DNSConstants
operator|.
name|QUERY_WAIT_INTERVAL
argument_list|)
expr_stmt|;
block|}
comment|/**          * Counts the number of queries that were sent.          */
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|state
operator|==
name|DNSState
operator|.
name|ANNOUNCED
condition|)
block|{
if|if
condition|(
operator|++
name|count
operator|<
literal|3
condition|)
block|{
name|logger
operator|.
name|finer
argument_list|(
literal|"run() JmDNS querying type"
argument_list|)
expr_stmt|;
name|DNSOutgoing
name|out
init|=
operator|new
name|DNSOutgoing
argument_list|(
name|DNSConstants
operator|.
name|FLAGS_QR_QUERY
argument_list|)
decl_stmt|;
name|out
operator|.
name|addQuestion
argument_list|(
operator|new
name|DNSQuestion
argument_list|(
literal|"_services._mdns._udp.local."
argument_list|,
name|DNSConstants
operator|.
name|TYPE_PTR
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|iterator
init|=
name|serviceTypes
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|out
operator|.
name|addAnswer
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Pointer
argument_list|(
literal|"_services._mdns._udp.local."
argument_list|,
name|DNSConstants
operator|.
name|TYPE_PTR
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
operator|(
name|String
operator|)
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|send
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// After three queries, we can quit.
name|cancel
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|state
operator|==
name|DNSState
operator|.
name|CANCELED
condition|)
block|{
name|cancel
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"run() exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * The ServiceResolver queries three times consecutively for services of      * a given type, and then removes itself from the timer.      *<p/>      * The ServiceResolver will run only if JmDNS is in state ANNOUNCED.      * REMIND: Prevent having multiple service resolvers for the same type in the      * timer queue.      */
specifier|private
class|class
name|ServiceResolver
extends|extends
name|TimerTask
block|{
comment|/**          * Counts the number of queries being sent.          */
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|private
name|String
name|type
decl_stmt|;
specifier|public
name|ServiceResolver
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
specifier|public
name|void
name|start
parameter_list|()
block|{
name|timer
operator|.
name|schedule
argument_list|(
name|this
argument_list|,
name|DNSConstants
operator|.
name|QUERY_WAIT_INTERVAL
argument_list|,
name|DNSConstants
operator|.
name|QUERY_WAIT_INTERVAL
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|state
operator|==
name|DNSState
operator|.
name|ANNOUNCED
condition|)
block|{
if|if
condition|(
name|count
operator|++
operator|<
literal|3
condition|)
block|{
name|logger
operator|.
name|finer
argument_list|(
literal|"run() JmDNS querying service"
argument_list|)
expr_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|DNSOutgoing
name|out
init|=
operator|new
name|DNSOutgoing
argument_list|(
name|DNSConstants
operator|.
name|FLAGS_QR_QUERY
argument_list|)
decl_stmt|;
name|out
operator|.
name|addQuestion
argument_list|(
operator|new
name|DNSQuestion
argument_list|(
name|type
argument_list|,
name|DNSConstants
operator|.
name|TYPE_PTR
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|s
init|=
name|services
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|s
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
specifier|final
name|ServiceInfo
name|info
init|=
operator|(
name|ServiceInfo
operator|)
name|s
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|out
operator|.
name|addAnswer
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Pointer
argument_list|(
name|info
operator|.
name|type
argument_list|,
name|DNSConstants
operator|.
name|TYPE_PTR
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|DNSConstants
operator|.
name|DNS_TTL
argument_list|,
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ee
parameter_list|)
block|{
break|break;
block|}
block|}
name|send
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// After three queries, we can quit.
name|cancel
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|state
operator|==
name|DNSState
operator|.
name|CANCELED
condition|)
block|{
name|cancel
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"run() exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * The ServiceInfoResolver queries up to three times consecutively for      * a service info, and then removes itself from the timer.      *<p/>      * The ServiceInfoResolver will run only if JmDNS is in state ANNOUNCED.      * REMIND: Prevent having multiple service resolvers for the same info in the      * timer queue.      */
specifier|private
class|class
name|ServiceInfoResolver
extends|extends
name|TimerTask
block|{
comment|/**          * Counts the number of queries being sent.          */
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|private
name|ServiceInfo
name|info
decl_stmt|;
specifier|public
name|ServiceInfoResolver
parameter_list|(
name|ServiceInfo
name|info
parameter_list|)
block|{
name|this
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|info
operator|.
name|dns
operator|=
name|JmDNS
operator|.
name|this
expr_stmt|;
name|addListener
argument_list|(
name|info
argument_list|,
operator|new
name|DNSQuestion
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_ANY
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|start
parameter_list|()
block|{
name|timer
operator|.
name|schedule
argument_list|(
name|this
argument_list|,
name|DNSConstants
operator|.
name|QUERY_WAIT_INTERVAL
argument_list|,
name|DNSConstants
operator|.
name|QUERY_WAIT_INTERVAL
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|state
operator|==
name|DNSState
operator|.
name|ANNOUNCED
condition|)
block|{
if|if
condition|(
name|count
operator|++
operator|<
literal|3
operator|&&
operator|!
name|info
operator|.
name|hasData
argument_list|()
condition|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|DNSOutgoing
name|out
init|=
operator|new
name|DNSOutgoing
argument_list|(
name|DNSConstants
operator|.
name|FLAGS_QR_QUERY
argument_list|)
decl_stmt|;
name|out
operator|.
name|addQuestion
argument_list|(
operator|new
name|DNSQuestion
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_SRV
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|addQuestion
argument_list|(
operator|new
name|DNSQuestion
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_TXT
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|server
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|addQuestion
argument_list|(
operator|new
name|DNSQuestion
argument_list|(
name|info
operator|.
name|server
argument_list|,
name|DNSConstants
operator|.
name|TYPE_A
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|addAnswer
argument_list|(
operator|(
name|DNSRecord
operator|)
name|cache
operator|.
name|get
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_SRV
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|)
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|out
operator|.
name|addAnswer
argument_list|(
operator|(
name|DNSRecord
operator|)
name|cache
operator|.
name|get
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_TXT
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|)
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|server
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|addAnswer
argument_list|(
operator|(
name|DNSRecord
operator|)
name|cache
operator|.
name|get
argument_list|(
name|info
operator|.
name|server
argument_list|,
name|DNSConstants
operator|.
name|TYPE_A
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|)
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
name|send
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// After three queries, we can quit.
name|cancel
argument_list|()
expr_stmt|;
name|removeListener
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|state
operator|==
name|DNSState
operator|.
name|CANCELED
condition|)
block|{
name|cancel
argument_list|()
expr_stmt|;
name|removeListener
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"run() exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * The Canceler sends two announces with TTL=0 for the specified services.      */
specifier|private
class|class
name|Canceler
extends|extends
name|TimerTask
block|{
comment|/**          * Counts the number of announces being sent.          */
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/**          * The services that need cancelling.          * Note: We have to use a local variable here, because the services          * that are canceled, are removed immediately from variable JmDNS.services.          */
specifier|private
name|ServiceInfo
index|[]
name|infos
decl_stmt|;
comment|/**          * We call notifyAll() on the lock object, when we have canceled the          * service infos.          * This is used by method JmDNS.unregisterService() and          * JmDNS.unregisterAllServices, to ensure that the JmDNS          * socket stays open until the Canceler has canceled all services.          *<p/>          * Note: We need this lock, because ServiceInfos do the transition from          * state ANNOUNCED to state CANCELED before we get here. We could get          * rid of this lock, if we added a state named CANCELLING to DNSState.          */
specifier|private
name|Object
name|lock
decl_stmt|;
name|int
name|ttl
init|=
literal|0
decl_stmt|;
specifier|public
name|Canceler
parameter_list|(
name|ServiceInfo
name|info
parameter_list|,
name|Object
name|lock
parameter_list|)
block|{
name|this
operator|.
name|infos
operator|=
operator|new
name|ServiceInfo
index|[]
block|{
name|info
block|}
expr_stmt|;
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
name|addListener
argument_list|(
name|info
argument_list|,
operator|new
name|DNSQuestion
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_ANY
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Canceler
parameter_list|(
name|ServiceInfo
index|[]
name|infos
parameter_list|,
name|Object
name|lock
parameter_list|)
block|{
name|this
operator|.
name|infos
operator|=
name|infos
expr_stmt|;
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
block|}
specifier|public
name|Canceler
parameter_list|(
name|Collection
name|infos
parameter_list|,
name|Object
name|lock
parameter_list|)
block|{
name|this
operator|.
name|infos
operator|=
operator|(
name|ServiceInfo
index|[]
operator|)
name|infos
operator|.
name|toArray
argument_list|(
operator|new
name|ServiceInfo
index|[
name|infos
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
block|}
specifier|public
name|void
name|start
parameter_list|()
block|{
name|timer
operator|.
name|schedule
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
name|DNSConstants
operator|.
name|ANNOUNCE_WAIT_INTERVAL
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
operator|++
name|count
operator|<
literal|3
condition|)
block|{
name|logger
operator|.
name|finer
argument_list|(
literal|"run() JmDNS canceling service"
argument_list|)
expr_stmt|;
comment|// announce the service
comment|//long now = System.currentTimeMillis();
name|DNSOutgoing
name|out
init|=
operator|new
name|DNSOutgoing
argument_list|(
name|DNSConstants
operator|.
name|FLAGS_QR_RESPONSE
operator||
name|DNSConstants
operator|.
name|FLAGS_AA
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|infos
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ServiceInfo
name|info
init|=
name|infos
index|[
name|i
index|]
decl_stmt|;
name|out
operator|.
name|addAnswer
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Pointer
argument_list|(
name|info
operator|.
name|type
argument_list|,
name|DNSConstants
operator|.
name|TYPE_PTR
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|ttl
argument_list|,
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
operator|.
name|addAnswer
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Service
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_SRV
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|ttl
argument_list|,
name|info
operator|.
name|priority
argument_list|,
name|info
operator|.
name|weight
argument_list|,
name|info
operator|.
name|port
argument_list|,
name|localHost
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
operator|.
name|addAnswer
argument_list|(
operator|new
name|DNSRecord
operator|.
name|Text
argument_list|(
name|info
operator|.
name|getQualifiedName
argument_list|()
argument_list|,
name|DNSConstants
operator|.
name|TYPE_TXT
argument_list|,
name|DNSConstants
operator|.
name|CLASS_IN
argument_list|,
name|ttl
argument_list|,
name|info
operator|.
name|text
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DNSRecord
name|answer
init|=
name|localHost
operator|.
name|getDNS4AddressRecord
argument_list|()
decl_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|addAnswer
argument_list|(
name|answer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|answer
operator|=
name|localHost
operator|.
name|getDNS6AddressRecord
argument_list|()
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|addAnswer
argument_list|(
name|answer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|send
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// After three successful announcements, we are finished.
synchronized|synchronized
init|(
name|lock
init|)
block|{
name|closed
operator|=
literal|true
expr_stmt|;
name|lock
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
name|cancel
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"run() exception "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// REMIND: Why is this not an anonymous inner class?
comment|/**      * Shutdown operations.      */
specifier|private
class|class
name|Shutdown
implements|implements
name|Runnable
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
name|shutdown
operator|=
literal|null
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Recover jmdns when there is an error.      */
specifier|protected
name|void
name|recover
parameter_list|()
block|{
name|logger
operator|.
name|finer
argument_list|(
literal|"recover()"
argument_list|)
expr_stmt|;
comment|// We have an IO error so lets try to recover if anything happens lets close it.
comment|// This should cover the case of the IP address changing under our feet
if|if
condition|(
name|DNSState
operator|.
name|CANCELED
operator|!=
name|state
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Synchronize only if we are not already in process to prevent dead locks
comment|//
name|logger
operator|.
name|finer
argument_list|(
literal|"recover() Cleanning up"
argument_list|)
expr_stmt|;
comment|// Stop JmDNS
name|state
operator|=
name|DNSState
operator|.
name|CANCELED
expr_stmt|;
comment|// This protects against recursive calls
comment|// We need to keep a copy for reregistration
name|Collection
name|oldServiceInfos
init|=
operator|new
name|ArrayList
argument_list|(
name|services
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
comment|// Cancel all services
name|unregisterAllServices
argument_list|()
expr_stmt|;
name|disposeServiceCollectors
argument_list|()
expr_stmt|;
comment|//
comment|// close multicast socket
name|closeMulticastSocket
argument_list|()
expr_stmt|;
comment|//
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|logger
operator|.
name|finer
argument_list|(
literal|"recover() All is clean"
argument_list|)
expr_stmt|;
comment|//
comment|// All is clear now start the services
comment|//
try|try
block|{
name|openMulticastSocket
argument_list|(
name|localHost
argument_list|)
expr_stmt|;
name|start
argument_list|(
name|oldServiceInfos
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|exception
parameter_list|)
block|{
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"recover() Start services exception "
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|log
argument_list|(
name|Level
operator|.
name|WARNING
argument_list|,
literal|"recover() We are back!"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Close down jmdns. Release all resources and unregister all services.      */
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|state
operator|!=
name|DNSState
operator|.
name|CANCELED
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Synchronize only if we are not already in process to prevent dead locks
comment|// Stop JmDNS
name|state
operator|=
name|DNSState
operator|.
name|CANCELED
expr_stmt|;
comment|// This protects against recursive calls
name|unregisterAllServices
argument_list|()
expr_stmt|;
name|disposeServiceCollectors
argument_list|()
expr_stmt|;
comment|// close socket
name|closeMulticastSocket
argument_list|()
expr_stmt|;
comment|// Stop the timer
name|timer
operator|.
name|cancel
argument_list|()
expr_stmt|;
comment|// remove the shutdown hook
if|if
condition|(
name|shutdown
operator|!=
literal|null
condition|)
block|{
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|removeShutdownHook
argument_list|(
name|shutdown
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * List cache entries, for debugging only.      */
name|void
name|print
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"---- cache ----"
argument_list|)
expr_stmt|;
name|cache
operator|.
name|print
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|/**      * List Services and serviceTypes.      * Debugging Only      */
specifier|public
name|void
name|printServices
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|aLog
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|aLog
operator|.
name|append
argument_list|(
literal|"\t---- Services -----"
argument_list|)
expr_stmt|;
if|if
condition|(
name|services
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
name|k
init|=
name|services
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|key
init|=
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
name|aLog
operator|.
name|append
argument_list|(
literal|"\n\t\tService: "
operator|+
name|key
operator|+
literal|": "
operator|+
name|services
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|aLog
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|aLog
operator|.
name|append
argument_list|(
literal|"\t---- Types ----"
argument_list|)
expr_stmt|;
if|if
condition|(
name|serviceTypes
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
name|k
init|=
name|serviceTypes
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|key
init|=
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
name|aLog
operator|.
name|append
argument_list|(
literal|"\n\t\tType: "
operator|+
name|key
operator|+
literal|": "
operator|+
name|serviceTypes
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|aLog
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|aLog
operator|.
name|append
argument_list|(
name|cache
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|aLog
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|aLog
operator|.
name|append
argument_list|(
literal|"\t---- Service Collectors ----"
argument_list|)
expr_stmt|;
if|if
condition|(
name|serviceCollectors
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|serviceCollectors
init|)
block|{
for|for
control|(
name|Iterator
name|k
init|=
name|serviceCollectors
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|key
init|=
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
name|aLog
operator|.
name|append
argument_list|(
literal|"\n\t\tService Collector: "
operator|+
name|key
operator|+
literal|": "
operator|+
name|serviceCollectors
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|serviceCollectors
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|aLog
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Returns a list of service infos of the specified type.      *      * @param type Service type name, such as<code>_http._tcp.local.</code>.      * @return An array of service instance names.      */
specifier|public
name|ServiceInfo
index|[]
name|list
parameter_list|(
name|String
name|type
parameter_list|)
block|{
comment|// Implementation note: The first time a list for a given type is
comment|// requested, a ServiceCollector is created which collects service
comment|// infos. This greatly speeds up the performance of subsequent calls
comment|// to this method. The caveats are, that 1) the first call to this method
comment|// for a given type is slow, and 2) we spawn a ServiceCollector
comment|// instance for each service type which increases network traffic a
comment|// little.
name|ServiceCollector
name|collector
decl_stmt|;
name|boolean
name|newCollectorCreated
decl_stmt|;
synchronized|synchronized
init|(
name|serviceCollectors
init|)
block|{
name|collector
operator|=
operator|(
name|ServiceCollector
operator|)
name|serviceCollectors
operator|.
name|get
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|collector
operator|==
literal|null
condition|)
block|{
name|collector
operator|=
operator|new
name|ServiceCollector
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|serviceCollectors
operator|.
name|put
argument_list|(
name|type
argument_list|,
name|collector
argument_list|)
expr_stmt|;
name|addServiceListener
argument_list|(
name|type
argument_list|,
name|collector
argument_list|)
expr_stmt|;
name|newCollectorCreated
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|newCollectorCreated
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// After creating a new ServiceCollector, we collect service infos for
comment|// 200 milliseconds. This should be enough time, to get some service
comment|// infos from the network.
if|if
condition|(
name|newCollectorCreated
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{             }
block|}
return|return
name|collector
operator|.
name|list
argument_list|()
return|;
block|}
comment|/**      * This method disposes all ServiceCollector instances which have been      * created by calls to method<code>list(type)</code>.      *      * @see #list      */
specifier|private
name|void
name|disposeServiceCollectors
parameter_list|()
block|{
name|logger
operator|.
name|finer
argument_list|(
literal|"disposeServiceCollectors()"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|serviceCollectors
init|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|serviceCollectors
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ServiceCollector
name|collector
init|=
operator|(
name|ServiceCollector
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|removeServiceListener
argument_list|(
name|collector
operator|.
name|type
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
name|serviceCollectors
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Instances of ServiceCollector are used internally to speed up the      * performance of method<code>list(type)</code>.      *      * @see #list      */
specifier|private
specifier|static
class|class
name|ServiceCollector
implements|implements
name|ServiceListener
block|{
specifier|private
specifier|static
name|Logger
name|logger
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|ServiceCollector
operator|.
name|class
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|/**          * A set of collected service instance names.          */
specifier|private
name|Map
name|infos
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|HashMap
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
name|String
name|type
decl_stmt|;
specifier|public
name|ServiceCollector
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
comment|/**          * A service has been added.          */
specifier|public
name|void
name|serviceAdded
parameter_list|(
name|ServiceEvent
name|event
parameter_list|)
block|{
synchronized|synchronized
init|(
name|infos
init|)
block|{
name|event
operator|.
name|getDNS
argument_list|()
operator|.
name|requestServiceInfo
argument_list|(
name|event
operator|.
name|getType
argument_list|()
argument_list|,
name|event
operator|.
name|getName
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * A service has been removed.          */
specifier|public
name|void
name|serviceRemoved
parameter_list|(
name|ServiceEvent
name|event
parameter_list|)
block|{
synchronized|synchronized
init|(
name|infos
init|)
block|{
name|infos
operator|.
name|remove
argument_list|(
name|event
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * A service hase been resolved. Its details are now available in the          * ServiceInfo record.          */
specifier|public
name|void
name|serviceResolved
parameter_list|(
name|ServiceEvent
name|event
parameter_list|)
block|{
synchronized|synchronized
init|(
name|infos
init|)
block|{
name|infos
operator|.
name|put
argument_list|(
name|event
operator|.
name|getName
argument_list|()
argument_list|,
name|event
operator|.
name|getInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Returns an array of all service infos which have been collected by this          * ServiceCollector.          */
specifier|public
name|ServiceInfo
index|[]
name|list
parameter_list|()
block|{
synchronized|synchronized
init|(
name|infos
init|)
block|{
return|return
operator|(
name|ServiceInfo
index|[]
operator|)
name|infos
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|ServiceInfo
index|[
name|infos
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|aLog
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|infos
init|)
block|{
for|for
control|(
name|Iterator
name|k
init|=
name|infos
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|key
init|=
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
name|aLog
operator|.
name|append
argument_list|(
literal|"\n\t\tService: "
operator|+
name|key
operator|+
literal|": "
operator|+
name|infos
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|aLog
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
empty_stmt|;
specifier|private
specifier|static
name|String
name|toUnqualifiedName
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|qualifiedName
parameter_list|)
block|{
if|if
condition|(
name|qualifiedName
operator|.
name|endsWith
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
name|qualifiedName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|qualifiedName
operator|.
name|length
argument_list|()
operator|-
name|type
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|qualifiedName
return|;
block|}
block|}
block|}
end_class

end_unit

