begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *   http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|amqp
operator|.
name|message
package|;
end_package

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|transport
operator|.
name|amqp
operator|.
name|AmqpProtocolException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|amqp
operator|.
name|Binary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|qpid
operator|.
name|proton
operator|.
name|amqp
operator|.
name|UnsignedLong
import|;
end_import

begin_comment
comment|/**  * Helper class for identifying and converting message-id and correlation-id values between  * the AMQP types and the Strings values used by JMS.  *  *<p>AMQP messages allow for 4 types of message-id/correlation-id: message-id-string, message-id-binary,  * message-id-uuid, or message-id-ulong. In order to accept or return a string representation of these  * for interoperability with other AMQP clients, the following encoding can be used after removing or  * before adding the "ID:" prefix used for a JMSMessageID value:<br>  *  * {@literal "AMQP_BINARY:<hex representation of binary content>"}<br>  * {@literal "AMQP_UUID:<string representation of uuid>"}<br>  * {@literal "AMQP_ULONG:<string representation of ulong>"}<br>  * {@literal "AMQP_STRING:<string>"}<br>  *  *<p>The AMQP_STRING encoding exists only for escaping message-id-string values that happen to begin  * with one of the encoding prefixes (including AMQP_STRING itself). It MUST NOT be used otherwise.  *  *<p>When provided a string for conversion which attempts to identify itself as an encoded binary, uuid, or  * ulong but can't be converted into the indicated format, an exception will be thrown.  */
end_comment

begin_class
specifier|public
class|class
name|AMQPMessageIdHelper
block|{
specifier|public
specifier|static
specifier|final
name|AMQPMessageIdHelper
name|INSTANCE
init|=
operator|new
name|AMQPMessageIdHelper
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|AMQP_STRING_PREFIX
init|=
literal|"AMQP_STRING:"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|AMQP_UUID_PREFIX
init|=
literal|"AMQP_UUID:"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|AMQP_ULONG_PREFIX
init|=
literal|"AMQP_ULONG:"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|AMQP_BINARY_PREFIX
init|=
literal|"AMQP_BINARY:"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|AMQP_UUID_PREFIX_LENGTH
init|=
name|AMQP_UUID_PREFIX
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|AMQP_ULONG_PREFIX_LENGTH
init|=
name|AMQP_ULONG_PREFIX
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|AMQP_STRING_PREFIX_LENGTH
init|=
name|AMQP_STRING_PREFIX
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|AMQP_BINARY_PREFIX_LENGTH
init|=
name|AMQP_BINARY_PREFIX
operator|.
name|length
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
index|[]
name|HEX_CHARS
init|=
literal|"0123456789ABCDEF"
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
comment|/**      * Takes the provided AMQP messageId style object, and convert it to a base string.      * Encodes type information as a prefix where necessary to convey or escape the type      * of the provided object.      *      * @param messageId      *      the raw messageId object to process      *      * @return the base string to be used in creating the actual id.      */
specifier|public
name|String
name|toBaseMessageIdString
parameter_list|(
name|Object
name|messageId
parameter_list|)
block|{
if|if
condition|(
name|messageId
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|messageId
operator|instanceof
name|String
condition|)
block|{
name|String
name|stringId
init|=
operator|(
name|String
operator|)
name|messageId
decl_stmt|;
comment|// If the given string has a type encoding prefix,
comment|// we need to escape it as an encoded string (even if
comment|// the existing encoding prefix was also for string)
if|if
condition|(
name|hasTypeEncodingPrefix
argument_list|(
name|stringId
argument_list|)
condition|)
block|{
return|return
name|AMQP_STRING_PREFIX
operator|+
name|stringId
return|;
block|}
else|else
block|{
return|return
name|stringId
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|messageId
operator|instanceof
name|UUID
condition|)
block|{
return|return
name|AMQP_UUID_PREFIX
operator|+
name|messageId
operator|.
name|toString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|messageId
operator|instanceof
name|UnsignedLong
condition|)
block|{
return|return
name|AMQP_ULONG_PREFIX
operator|+
name|messageId
operator|.
name|toString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|messageId
operator|instanceof
name|Binary
condition|)
block|{
name|ByteBuffer
name|dup
init|=
operator|(
operator|(
name|Binary
operator|)
name|messageId
operator|)
operator|.
name|asByteBuffer
argument_list|()
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|dup
operator|.
name|remaining
argument_list|()
index|]
decl_stmt|;
name|dup
operator|.
name|get
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|String
name|hex
init|=
name|convertBinaryToHexString
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
return|return
name|AMQP_BINARY_PREFIX
operator|+
name|hex
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unsupported type provided: "
operator|+
name|messageId
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Takes the provided base id string and return the appropriate amqp messageId style object.      * Converts the type based on any relevant encoding information found as a prefix.      *      * @param baseId      *      the object to be converted to an AMQP MessageId value.      *      * @return the AMQP messageId style object      *      * @throws AmqpProtocolException if the provided baseId String indicates an encoded type but can't be converted to that type.      */
specifier|public
name|Object
name|toIdObject
parameter_list|(
name|String
name|baseId
parameter_list|)
throws|throws
name|AmqpProtocolException
block|{
if|if
condition|(
name|baseId
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
if|if
condition|(
name|hasAmqpUuidPrefix
argument_list|(
name|baseId
argument_list|)
condition|)
block|{
name|String
name|uuidString
init|=
name|strip
argument_list|(
name|baseId
argument_list|,
name|AMQP_UUID_PREFIX_LENGTH
argument_list|)
decl_stmt|;
return|return
name|UUID
operator|.
name|fromString
argument_list|(
name|uuidString
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|hasAmqpUlongPrefix
argument_list|(
name|baseId
argument_list|)
condition|)
block|{
name|String
name|longString
init|=
name|strip
argument_list|(
name|baseId
argument_list|,
name|AMQP_ULONG_PREFIX_LENGTH
argument_list|)
decl_stmt|;
return|return
name|UnsignedLong
operator|.
name|valueOf
argument_list|(
name|longString
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|hasAmqpStringPrefix
argument_list|(
name|baseId
argument_list|)
condition|)
block|{
return|return
name|strip
argument_list|(
name|baseId
argument_list|,
name|AMQP_STRING_PREFIX_LENGTH
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|hasAmqpBinaryPrefix
argument_list|(
name|baseId
argument_list|)
condition|)
block|{
name|String
name|hexString
init|=
name|strip
argument_list|(
name|baseId
argument_list|,
name|AMQP_BINARY_PREFIX_LENGTH
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
name|convertHexStringToBinary
argument_list|(
name|hexString
argument_list|)
decl_stmt|;
return|return
operator|new
name|Binary
argument_list|(
name|bytes
argument_list|)
return|;
block|}
else|else
block|{
comment|// We have a string without any type prefix, transmit it as-is.
return|return
name|baseId
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AmqpProtocolException
argument_list|(
literal|"Unable to convert ID value"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Convert the provided hex-string into a binary representation where each byte represents      * two characters of the hex string.      *      * The hex characters may be upper or lower case.      *      * @param hexString      *      string to convert to a binary value.      *      * @return a byte array containing the binary representation      *      * @throws IllegalArgumentException if the provided String is a non-even length or contains      *                                  non-hex characters      */
specifier|public
name|byte
index|[]
name|convertHexStringToBinary
parameter_list|(
name|String
name|hexString
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|int
name|length
init|=
name|hexString
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// As each byte needs two characters in the hex encoding, the string must be an even length.
if|if
condition|(
name|length
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The provided hex String must be an even length, but was of length "
operator|+
name|length
operator|+
literal|": "
operator|+
name|hexString
argument_list|)
throw|;
block|}
name|byte
index|[]
name|binary
init|=
operator|new
name|byte
index|[
name|length
operator|/
literal|2
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|char
name|highBitsChar
init|=
name|hexString
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|char
name|lowBitsChar
init|=
name|hexString
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|highBits
init|=
name|hexCharToInt
argument_list|(
name|highBitsChar
argument_list|,
name|hexString
argument_list|)
operator|<<
literal|4
decl_stmt|;
name|int
name|lowBits
init|=
name|hexCharToInt
argument_list|(
name|lowBitsChar
argument_list|,
name|hexString
argument_list|)
decl_stmt|;
name|binary
index|[
name|i
operator|/
literal|2
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|highBits
operator|+
name|lowBits
argument_list|)
expr_stmt|;
block|}
return|return
name|binary
return|;
block|}
comment|/**      * Convert the provided binary into a hex-string representation where each character      * represents 4 bits of the provided binary, i.e each byte requires two characters.      *      * The returned hex characters are upper-case.      *      * @param bytes      *      the binary value to convert to a hex String instance.      *      * @return a String containing a hex representation of the bytes      */
specifier|public
name|String
name|convertBinaryToHexString
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
block|{
comment|// Each byte is represented as 2 chars
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|bytes
operator|.
name|length
operator|*
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
name|b
range|:
name|bytes
control|)
block|{
comment|// The byte will be expanded to int before shifting, replicating the
comment|// sign bit, so mask everything beyond the first 4 bits afterwards
name|int
name|highBitsInt
init|=
operator|(
name|b
operator|>>
literal|4
operator|)
operator|&
literal|0xF
decl_stmt|;
comment|// We only want the first 4 bits
name|int
name|lowBitsInt
init|=
name|b
operator|&
literal|0xF
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|HEX_CHARS
index|[
name|highBitsInt
index|]
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|HEX_CHARS
index|[
name|lowBitsInt
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|//----- Internal implementation ------------------------------------------//
specifier|private
name|boolean
name|hasTypeEncodingPrefix
parameter_list|(
name|String
name|stringId
parameter_list|)
block|{
return|return
name|hasAmqpBinaryPrefix
argument_list|(
name|stringId
argument_list|)
operator|||
name|hasAmqpUuidPrefix
argument_list|(
name|stringId
argument_list|)
operator|||
name|hasAmqpUlongPrefix
argument_list|(
name|stringId
argument_list|)
operator|||
name|hasAmqpStringPrefix
argument_list|(
name|stringId
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|hasAmqpStringPrefix
parameter_list|(
name|String
name|stringId
parameter_list|)
block|{
return|return
name|stringId
operator|.
name|startsWith
argument_list|(
name|AMQP_STRING_PREFIX
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|hasAmqpUlongPrefix
parameter_list|(
name|String
name|stringId
parameter_list|)
block|{
return|return
name|stringId
operator|.
name|startsWith
argument_list|(
name|AMQP_ULONG_PREFIX
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|hasAmqpUuidPrefix
parameter_list|(
name|String
name|stringId
parameter_list|)
block|{
return|return
name|stringId
operator|.
name|startsWith
argument_list|(
name|AMQP_UUID_PREFIX
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|hasAmqpBinaryPrefix
parameter_list|(
name|String
name|stringId
parameter_list|)
block|{
return|return
name|stringId
operator|.
name|startsWith
argument_list|(
name|AMQP_BINARY_PREFIX
argument_list|)
return|;
block|}
specifier|private
name|String
name|strip
parameter_list|(
name|String
name|id
parameter_list|,
name|int
name|numChars
parameter_list|)
block|{
return|return
name|id
operator|.
name|substring
argument_list|(
name|numChars
argument_list|)
return|;
block|}
specifier|private
name|int
name|hexCharToInt
parameter_list|(
name|char
name|ch
parameter_list|,
name|String
name|orig
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
block|{
comment|// subtract '0' to get difference in position as an int
return|return
name|ch
operator|-
literal|'0'
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
block|{
comment|// subtract 'A' to get difference in position as an int
comment|// and then add 10 for the offset of 'A'
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
block|{
comment|// subtract 'a' to get difference in position as an int
comment|// and then add 10 for the offset of 'a'
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The provided hex string contains non-hex character '"
operator|+
name|ch
operator|+
literal|"': "
operator|+
name|orig
argument_list|)
throw|;
block|}
block|}
end_class

end_unit

