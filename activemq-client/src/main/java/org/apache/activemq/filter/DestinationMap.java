begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|filter
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|activemq
operator|.
name|command
operator|.
name|ActiveMQDestination
import|;
end_import

begin_comment
comment|/**  * A Map-like data structure allowing values to be indexed by  * {@link ActiveMQDestination} and retrieved by destination - supporting both *  * and&gt; style of wildcard as well as composite destinations.<br>  * This class assumes that the index changes rarely but that fast lookup into  * the index is required. So this class maintains a pre-calculated index for  * destination steps. So looking up the values for "TEST.*" or "*.TEST" will be  * pretty fast.<br>  * Looking up of a value could return a single value or a List of matching  * values if a wildcard or composite destination is used.  */
end_comment

begin_class
specifier|public
class|class
name|DestinationMap
block|{
specifier|protected
specifier|static
specifier|final
name|String
name|ANY_DESCENDENT
init|=
name|DestinationFilter
operator|.
name|ANY_DESCENDENT
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|ANY_CHILD
init|=
name|DestinationFilter
operator|.
name|ANY_CHILD
decl_stmt|;
specifier|private
name|DestinationMapNode
name|queueRootNode
init|=
operator|new
name|DestinationMapNode
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|private
name|DestinationMapNode
name|tempQueueRootNode
init|=
operator|new
name|DestinationMapNode
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|private
name|DestinationMapNode
name|topicRootNode
init|=
operator|new
name|DestinationMapNode
argument_list|(
literal|null
argument_list|)
decl_stmt|;
specifier|private
name|DestinationMapNode
name|tempTopicRootNode
init|=
operator|new
name|DestinationMapNode
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|/**      * Looks up the value(s) matching the given Destination key. For simple      * destinations this is typically a List of one single value, for wildcards      * or composite destinations this will typically be a List of matching      * values.      *      * @param key the destination to lookup      * @return a List of matching values or an empty list if there are no      *         matching values.      */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|public
name|Set
name|get
parameter_list|(
name|ActiveMQDestination
name|key
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
return|return
name|unsynchronizedGet
argument_list|(
name|key
argument_list|)
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|public
name|Set
name|unsynchronizedGet
parameter_list|(
name|ActiveMQDestination
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|.
name|isComposite
argument_list|()
condition|)
block|{
name|ActiveMQDestination
index|[]
name|destinations
init|=
name|key
operator|.
name|getCompositeDestinations
argument_list|()
decl_stmt|;
name|Set
name|answer
init|=
operator|new
name|HashSet
argument_list|(
name|destinations
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|destinations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ActiveMQDestination
name|childDestination
init|=
name|destinations
index|[
name|i
index|]
decl_stmt|;
name|Object
name|value
init|=
name|unsynchronizedGet
argument_list|(
name|childDestination
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Set
condition|)
block|{
name|answer
operator|.
name|addAll
argument_list|(
operator|(
name|Set
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|answer
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|answer
return|;
block|}
return|return
name|findWildcardMatches
argument_list|(
name|key
argument_list|)
return|;
block|}
specifier|public
name|void
name|put
parameter_list|(
name|ActiveMQDestination
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|unsynchronizedPut
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|unsynchronizedPut
parameter_list|(
name|ActiveMQDestination
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|.
name|isComposite
argument_list|()
condition|)
block|{
name|ActiveMQDestination
index|[]
name|destinations
init|=
name|key
operator|.
name|getCompositeDestinations
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|destinations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ActiveMQDestination
name|childDestination
init|=
name|destinations
index|[
name|i
index|]
decl_stmt|;
name|put
argument_list|(
name|childDestination
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|String
index|[]
name|paths
init|=
name|key
operator|.
name|getDestinationPaths
argument_list|()
decl_stmt|;
name|getRootNode
argument_list|(
name|key
argument_list|)
operator|.
name|add
argument_list|(
name|paths
argument_list|,
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the value from the associated destination      */
specifier|public
name|void
name|remove
parameter_list|(
name|ActiveMQDestination
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|unsynchronizedRemove
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|unsynchronizedRemove
parameter_list|(
name|ActiveMQDestination
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|.
name|isComposite
argument_list|()
condition|)
block|{
name|ActiveMQDestination
index|[]
name|destinations
init|=
name|key
operator|.
name|getCompositeDestinations
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|destinations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ActiveMQDestination
name|childDestination
init|=
name|destinations
index|[
name|i
index|]
decl_stmt|;
name|remove
argument_list|(
name|childDestination
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|String
index|[]
name|paths
init|=
name|key
operator|.
name|getDestinationPaths
argument_list|()
decl_stmt|;
name|getRootNode
argument_list|(
name|key
argument_list|)
operator|.
name|remove
argument_list|(
name|paths
argument_list|,
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|getTopicRootChildCount
parameter_list|()
block|{
return|return
name|topicRootNode
operator|.
name|getChildCount
argument_list|()
return|;
block|}
specifier|public
name|int
name|getQueueRootChildCount
parameter_list|()
block|{
return|return
name|queueRootNode
operator|.
name|getChildCount
argument_list|()
return|;
block|}
specifier|public
name|DestinationMapNode
name|getQueueRootNode
parameter_list|()
block|{
return|return
name|queueRootNode
return|;
block|}
specifier|public
name|DestinationMapNode
name|getTopicRootNode
parameter_list|()
block|{
return|return
name|topicRootNode
return|;
block|}
specifier|public
name|DestinationMapNode
name|getTempQueueRootNode
parameter_list|()
block|{
return|return
name|tempQueueRootNode
return|;
block|}
specifier|public
name|DestinationMapNode
name|getTempTopicRootNode
parameter_list|()
block|{
return|return
name|tempTopicRootNode
return|;
block|}
comment|// Implementation methods
comment|// -------------------------------------------------------------------------
comment|/**      * A helper method to allow the destination map to be populated from a      * dependency injection framework such as Spring      */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|}
argument_list|)
specifier|protected
name|void
name|setEntries
parameter_list|(
name|List
argument_list|<
name|DestinationMapEntry
argument_list|>
name|entries
parameter_list|)
block|{
for|for
control|(
name|Object
name|element
range|:
name|entries
control|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|DestinationMapEntry
argument_list|>
name|type
init|=
name|getEntryClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isInstance
argument_list|(
name|element
argument_list|)
condition|)
block|{
name|DestinationMapEntry
name|entry
init|=
operator|(
name|DestinationMapEntry
operator|)
name|element
decl_stmt|;
name|put
argument_list|(
name|entry
operator|.
name|getDestination
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Each entry must be an instance of type: "
operator|+
name|type
operator|.
name|getName
argument_list|()
operator|+
literal|" but was: "
operator|+
name|element
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Returns the type of the allowed entries which can be set via the      * {@link #setEntries(List)} method. This allows derived classes to further      * restrict the type of allowed entries to make a type safe destination map      * for custom policies.      */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|}
argument_list|)
specifier|protected
name|Class
argument_list|<
name|?
extends|extends
name|DestinationMapEntry
argument_list|>
name|getEntryClass
parameter_list|()
block|{
return|return
name|DestinationMapEntry
operator|.
name|class
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|protected
name|Set
name|findWildcardMatches
parameter_list|(
name|ActiveMQDestination
name|key
parameter_list|)
block|{
return|return
name|findWildcardMatches
argument_list|(
name|key
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|protected
name|Set
name|findWildcardMatches
parameter_list|(
name|ActiveMQDestination
name|key
parameter_list|,
name|boolean
name|deep
parameter_list|)
block|{
name|String
index|[]
name|paths
init|=
name|key
operator|.
name|getDestinationPaths
argument_list|()
decl_stmt|;
name|Set
name|answer
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
name|getRootNode
argument_list|(
name|key
argument_list|)
operator|.
name|appendMatchingValues
argument_list|(
name|answer
argument_list|,
name|paths
argument_list|,
literal|0
argument_list|,
name|deep
argument_list|)
expr_stmt|;
return|return
name|answer
return|;
block|}
comment|/**      * @param key      * @return      */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|public
name|Set
name|removeAll
parameter_list|(
name|ActiveMQDestination
name|key
parameter_list|)
block|{
name|Set
name|rc
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|isComposite
argument_list|()
condition|)
block|{
name|ActiveMQDestination
index|[]
name|destinations
init|=
name|key
operator|.
name|getCompositeDestinations
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|destinations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|.
name|add
argument_list|(
name|removeAll
argument_list|(
name|destinations
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
name|String
index|[]
name|paths
init|=
name|key
operator|.
name|getDestinationPaths
argument_list|()
decl_stmt|;
name|getRootNode
argument_list|(
name|key
argument_list|)
operator|.
name|removeAll
argument_list|(
name|rc
argument_list|,
name|paths
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
comment|/**      * Returns the value which matches the given destination or null if there is      * no matching value. If there are multiple values, the results are sorted      * and the last item (the biggest) is returned.      *      * @param destination the destination to find the value for      * @return the largest matching value or null if no value matches      */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
specifier|public
name|DestinationMapEntry
name|chooseValue
parameter_list|(
specifier|final
name|ActiveMQDestination
name|destination
parameter_list|)
block|{
name|Set
argument_list|<
name|DestinationMapEntry
argument_list|>
name|set
init|=
name|get
argument_list|(
name|destination
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|==
literal|null
operator|||
name|set
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//Comparator to sort in order - we want to pick the exact match by destination or the
comment|//closest parent that applies
specifier|final
name|Comparator
argument_list|<
name|DestinationMapEntry
argument_list|>
name|comparator
init|=
operator|new
name|Comparator
argument_list|<
name|DestinationMapEntry
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|DestinationMapEntry
name|entry1
parameter_list|,
name|DestinationMapEntry
name|entry2
parameter_list|)
block|{
return|return
name|destination
operator|.
name|equals
argument_list|(
name|entry1
operator|.
name|destination
argument_list|)
condition|?
operator|-
literal|1
else|:
operator|(
name|destination
operator|.
name|equals
argument_list|(
name|entry2
operator|.
name|destination
argument_list|)
condition|?
literal|1
else|:
name|entry1
operator|.
name|compareTo
argument_list|(
name|entry2
argument_list|)
operator|)
return|;
block|}
block|}
decl_stmt|;
comment|//Sort and filter out any children and non matching entries
specifier|final
name|SortedSet
argument_list|<
name|DestinationMapEntry
argument_list|>
name|sortedSet
init|=
name|set
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|entry
lambda|->
name|isMatchOrParent
argument_list|(
name|destination
argument_list|,
operator|(
name|DestinationMapEntry
operator|)
name|entry
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toCollection
argument_list|(
parameter_list|()
lambda|->
operator|new
name|TreeSet
argument_list|<
name|DestinationMapEntry
argument_list|>
argument_list|(
name|comparator
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|sortedSet
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|?
name|sortedSet
operator|.
name|first
argument_list|()
else|:
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
comment|//Used to filter out any child/unmatching entries
specifier|private
name|boolean
name|isMatchOrParent
parameter_list|(
specifier|final
name|ActiveMQDestination
name|destination
parameter_list|,
specifier|final
name|DestinationMapEntry
name|entry
parameter_list|)
block|{
comment|//If destination not set then do not filter out
if|if
condition|(
name|entry
operator|.
name|getDestination
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|final
name|DestinationFilter
name|filter
init|=
name|DestinationFilter
operator|.
name|parseFilter
argument_list|(
name|entry
operator|.
name|getDestination
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|destination
operator|.
name|equals
argument_list|(
name|entry
operator|.
name|getDestination
argument_list|()
argument_list|)
operator|||
name|filter
operator|.
name|matches
argument_list|(
name|destination
argument_list|)
return|;
block|}
comment|/**      * Returns the root node for the given destination type      */
specifier|protected
name|DestinationMapNode
name|getRootNode
parameter_list|(
name|ActiveMQDestination
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|.
name|isTemporary
argument_list|()
condition|)
block|{
if|if
condition|(
name|key
operator|.
name|isQueue
argument_list|()
condition|)
block|{
return|return
name|tempQueueRootNode
return|;
block|}
else|else
block|{
return|return
name|tempTopicRootNode
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|key
operator|.
name|isQueue
argument_list|()
condition|)
block|{
return|return
name|queueRootNode
return|;
block|}
else|else
block|{
return|return
name|topicRootNode
return|;
block|}
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|queueRootNode
operator|=
operator|new
name|DestinationMapNode
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|tempQueueRootNode
operator|=
operator|new
name|DestinationMapNode
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|topicRootNode
operator|=
operator|new
name|DestinationMapNode
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|tempTopicRootNode
operator|=
operator|new
name|DestinationMapNode
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|queueRootNode
operator|.
name|isEmpty
argument_list|()
operator|&&
name|topicRootNode
operator|.
name|isEmpty
argument_list|()
operator|&&
name|tempQueueRootNode
operator|.
name|isEmpty
argument_list|()
operator|&&
name|tempTopicRootNode
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|Set
name|union
parameter_list|(
name|Set
name|existing
parameter_list|,
name|Set
name|candidates
parameter_list|)
block|{
if|if
condition|(
name|candidates
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|existing
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Object
argument_list|>
name|iterator
init|=
name|existing
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|toMatch
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|candidates
operator|.
name|contains
argument_list|(
name|toMatch
argument_list|)
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|existing
operator|=
name|candidates
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|existing
operator|!=
literal|null
condition|)
block|{
name|existing
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
name|existing
return|;
block|}
block|}
end_class

end_unit

