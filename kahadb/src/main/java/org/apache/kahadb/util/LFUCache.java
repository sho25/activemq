begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|kahadb
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * LFU cache implementation based on http://dhruvbird.com/lfu.pdf, with some notable differences:  *<ul>  *<li>  * Frequency list is stored as an array with no next/prev pointers between nodes: looping over the array should be faster and more CPU-cache friendly than  * using an ad-hoc linked-pointers structure.  *</li>  *<li>  * The max frequency is capped at the cache size to avoid creating more and more frequency list entries, and all elements residing in the max frequency entry  * are re-positioned in the frequency entry linked set in order to put most recently accessed elements ahead of less recently ones,  * which will be collected sooner.  *</li>  *<li>  * The eviction factor determines how many elements (more specifically, the percentage of) will be evicted.  *</li>  *</ul>  * As a consequence, this cache runs in *amortized* O(1) time (considering the worst case of having the lowest frequency at 0 and having to evict all  * elements).  *  * @author Sergio Bossa  */
end_comment

begin_class
specifier|public
class|class
name|LFUCache
parameter_list|<
name|Key
parameter_list|,
name|Value
parameter_list|>
implements|implements
name|Map
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
block|{
specifier|private
specifier|final
name|Map
argument_list|<
name|Key
argument_list|,
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
name|cache
decl_stmt|;
specifier|private
specifier|final
name|LinkedHashSet
index|[]
name|frequencyList
decl_stmt|;
specifier|private
name|int
name|lowestFrequency
decl_stmt|;
specifier|private
name|int
name|maxFrequency
decl_stmt|;
comment|//
specifier|private
specifier|final
name|int
name|maxCacheSize
decl_stmt|;
specifier|private
specifier|final
name|float
name|evictionFactor
decl_stmt|;
specifier|public
name|LFUCache
parameter_list|(
name|int
name|maxCacheSize
parameter_list|,
name|float
name|evictionFactor
parameter_list|)
block|{
if|if
condition|(
name|evictionFactor
operator|<=
literal|0
operator|||
name|evictionFactor
operator|>=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Eviction factor must be greater than 0 and lesser than or equal to 1"
argument_list|)
throw|;
block|}
name|this
operator|.
name|cache
operator|=
operator|new
name|HashMap
argument_list|<
name|Key
argument_list|,
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
argument_list|(
name|maxCacheSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|frequencyList
operator|=
operator|new
name|LinkedHashSet
index|[
name|maxCacheSize
index|]
expr_stmt|;
name|this
operator|.
name|lowestFrequency
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|maxFrequency
operator|=
name|maxCacheSize
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|maxCacheSize
operator|=
name|maxCacheSize
expr_stmt|;
name|this
operator|.
name|evictionFactor
operator|=
name|evictionFactor
expr_stmt|;
name|initFrequencyList
argument_list|()
expr_stmt|;
block|}
specifier|public
name|Value
name|put
parameter_list|(
name|Key
name|k
parameter_list|,
name|Value
name|v
parameter_list|)
block|{
name|Value
name|oldValue
init|=
literal|null
decl_stmt|;
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
name|currentNode
init|=
name|cache
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentNode
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|cache
operator|.
name|size
argument_list|()
operator|==
name|maxCacheSize
condition|)
block|{
name|doEviction
argument_list|()
expr_stmt|;
block|}
name|LinkedHashSet
argument_list|<
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
name|nodes
init|=
name|frequencyList
index|[
literal|0
index|]
decl_stmt|;
name|currentNode
operator|=
operator|new
name|CacheNode
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|currentNode
argument_list|)
expr_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|k
argument_list|,
name|currentNode
argument_list|)
expr_stmt|;
name|lowestFrequency
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|oldValue
operator|=
name|currentNode
operator|.
name|v
expr_stmt|;
name|currentNode
operator|.
name|v
operator|=
name|v
expr_stmt|;
block|}
return|return
name|oldValue
return|;
block|}
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|Key
argument_list|,
name|?
extends|extends
name|Value
argument_list|>
name|map
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
extends|extends
name|Key
argument_list|,
name|?
extends|extends
name|Value
argument_list|>
name|me
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|put
argument_list|(
name|me
operator|.
name|getKey
argument_list|()
argument_list|,
name|me
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|Value
name|get
parameter_list|(
name|Object
name|k
parameter_list|)
block|{
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
name|currentNode
init|=
name|cache
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentNode
operator|!=
literal|null
condition|)
block|{
name|int
name|currentFrequency
init|=
name|currentNode
operator|.
name|frequency
decl_stmt|;
if|if
condition|(
name|currentFrequency
operator|<
name|maxFrequency
condition|)
block|{
name|int
name|nextFrequency
init|=
name|currentFrequency
operator|+
literal|1
decl_stmt|;
name|LinkedHashSet
argument_list|<
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
name|currentNodes
init|=
name|frequencyList
index|[
name|currentFrequency
index|]
decl_stmt|;
name|LinkedHashSet
argument_list|<
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
name|newNodes
init|=
name|frequencyList
index|[
name|nextFrequency
index|]
decl_stmt|;
name|moveToNextFrequency
argument_list|(
name|currentNode
argument_list|,
name|nextFrequency
argument_list|,
name|currentNodes
argument_list|,
name|newNodes
argument_list|)
expr_stmt|;
name|cache
operator|.
name|put
argument_list|(
operator|(
name|Key
operator|)
name|k
argument_list|,
name|currentNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowestFrequency
operator|==
name|currentFrequency
operator|&&
name|currentNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lowestFrequency
operator|=
name|nextFrequency
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Hybrid with LRU: put most recently accessed ahead of others:
name|LinkedHashSet
argument_list|<
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
name|nodes
init|=
name|frequencyList
index|[
name|currentFrequency
index|]
decl_stmt|;
name|nodes
operator|.
name|remove
argument_list|(
name|currentNode
argument_list|)
expr_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|currentNode
argument_list|)
expr_stmt|;
block|}
return|return
name|currentNode
operator|.
name|v
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|Value
name|remove
parameter_list|(
name|Object
name|k
parameter_list|)
block|{
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
name|currentNode
init|=
name|cache
operator|.
name|remove
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentNode
operator|!=
literal|null
condition|)
block|{
name|LinkedHashSet
argument_list|<
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
name|nodes
init|=
name|frequencyList
index|[
name|currentNode
operator|.
name|frequency
index|]
decl_stmt|;
name|nodes
operator|.
name|remove
argument_list|(
name|currentNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowestFrequency
operator|==
name|currentNode
operator|.
name|frequency
condition|)
block|{
name|findNextLowestFrequency
argument_list|()
expr_stmt|;
block|}
return|return
name|currentNode
operator|.
name|v
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|public
name|int
name|frequencyOf
parameter_list|(
name|Key
name|k
parameter_list|)
block|{
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
name|node
init|=
name|cache
operator|.
name|get
argument_list|(
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
return|return
name|node
operator|.
name|frequency
operator|+
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|maxFrequency
condition|;
name|i
operator|++
control|)
block|{
name|frequencyList
index|[
name|i
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|lowestFrequency
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|Set
argument_list|<
name|Key
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|this
operator|.
name|cache
operator|.
name|keySet
argument_list|()
return|;
block|}
specifier|public
name|Collection
argument_list|<
name|Value
argument_list|>
name|values
parameter_list|()
block|{
return|return
literal|null
return|;
comment|//To change body of implemented methods use File | Settings | File Templates.
block|}
specifier|public
name|Set
argument_list|<
name|Entry
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
literal|null
return|;
comment|//To change body of implemented methods use File | Settings | File Templates.
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|cache
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|this
operator|.
name|cache
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|this
operator|.
name|cache
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
literal|false
return|;
comment|//To change body of implemented methods use File | Settings | File Templates.
block|}
specifier|private
name|void
name|initFrequencyList
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|maxFrequency
condition|;
name|i
operator|++
control|)
block|{
name|frequencyList
index|[
name|i
index|]
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|doEviction
parameter_list|()
block|{
name|int
name|currentlyDeleted
init|=
literal|0
decl_stmt|;
name|float
name|target
init|=
name|maxCacheSize
operator|*
name|evictionFactor
decl_stmt|;
while|while
condition|(
name|currentlyDeleted
operator|<
name|target
condition|)
block|{
name|LinkedHashSet
argument_list|<
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
name|nodes
init|=
name|frequencyList
index|[
name|lowestFrequency
index|]
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Lowest frequency constraint violated!"
argument_list|)
throw|;
block|}
else|else
block|{
name|Iterator
argument_list|<
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
name|it
init|=
name|nodes
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
operator|&&
name|currentlyDeleted
operator|++
operator|<
name|target
condition|)
block|{
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
name|node
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|cache
operator|.
name|remove
argument_list|(
name|node
operator|.
name|k
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|findNextLowestFrequency
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|moveToNextFrequency
parameter_list|(
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
name|currentNode
parameter_list|,
name|int
name|nextFrequency
parameter_list|,
name|LinkedHashSet
argument_list|<
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
name|currentNodes
parameter_list|,
name|LinkedHashSet
argument_list|<
name|CacheNode
argument_list|<
name|Key
argument_list|,
name|Value
argument_list|>
argument_list|>
name|newNodes
parameter_list|)
block|{
name|currentNodes
operator|.
name|remove
argument_list|(
name|currentNode
argument_list|)
expr_stmt|;
name|newNodes
operator|.
name|add
argument_list|(
name|currentNode
argument_list|)
expr_stmt|;
name|currentNode
operator|.
name|frequency
operator|=
name|nextFrequency
expr_stmt|;
block|}
specifier|private
name|void
name|findNextLowestFrequency
parameter_list|()
block|{
while|while
condition|(
name|lowestFrequency
operator|<=
name|maxFrequency
operator|&&
name|frequencyList
index|[
name|lowestFrequency
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lowestFrequency
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lowestFrequency
operator|>
name|maxFrequency
condition|)
block|{
name|lowestFrequency
operator|=
literal|0
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|CacheNode
parameter_list|<
name|Key
parameter_list|,
name|Value
parameter_list|>
block|{
specifier|public
specifier|final
name|Key
name|k
decl_stmt|;
specifier|public
name|Value
name|v
decl_stmt|;
specifier|public
name|int
name|frequency
decl_stmt|;
specifier|public
name|CacheNode
parameter_list|(
name|Key
name|k
parameter_list|,
name|Value
name|v
parameter_list|,
name|int
name|frequency
parameter_list|)
block|{
name|this
operator|.
name|k
operator|=
name|k
expr_stmt|;
name|this
operator|.
name|v
operator|=
name|v
expr_stmt|;
name|this
operator|.
name|frequency
operator|=
name|frequency
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

